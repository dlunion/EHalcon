.版本 2
.支持库 ehalcon
.程序集变量 hal, Halcon12

.程序集 窗口程序集1

.子程序 _启动子程序, 整数型

hal.发生错误后暂停 (真)  ' 这一行是启用调试的，如果程序中发生执行错误，则会暂停以方便检查异常
主程序 ()
返回(0)

.子程序 主程序, , , explore_halcon.hdev
.局部变量 ClampsModelExists, 视觉元组
.局部变量 CookieModelExists, 视觉元组
.局部变量 MainWindowHandle, 视觉元组
.局部变量 NumCurrent, 视觉元组
.局部变量 NumTotal, 视觉元组
.局部变量 StatusWindowHandle, 视觉元组
.局部变量 mCount, 视觉元组

' ****************************************************************************
' 
' Explore the Power of HALCON
' (c) 2005-2014 MVTec Software GmbH
' 
' ****************************************************************************
' 
' This example program will give you an impression of the power
' of HALCON. It is a compilation of selected applications and
' solutions from many different industries and application areas.
' Each application runs live in HALCON HDevelop.
' 
' All applications and solutions that are shown in
' explore_halcon.hdev are also available as individual HDevelop
' programs. They can serve as templates to shorten the development
' time of your application.
' 
' Please note that they are only a small subset of the hundreds of
' examples that are included in the HALCON software. All HALCON
' examples can be found with the Example Browser of HDevelop.
' 
' ****************************************************************************
' 
' Attention: Due to space restrictions, the downloaded HALCON
' installation potentially does not include the pre-generated models
' used for the following application procedures:
' (A) p_do_cookie_box
' (B) p_do_3d_matching_clamps
' In this case, for using these application procedures also in
' "Explore the Power of HALCON", the models have to be generated
' by running the corresponding HDevelop example programs once:
' (A) Applications/Object-Recognition-2D/locate_cookie_box.hdev (cookie_box_model.dsm)
' (B) Applications/Position-Recognition-3D/3d_matching_clamps.hdev (clamp_sloped_35.sm3)
' 
' When starting the application, the procedure do_check_for_model_files
' checks for the presence of these two model files. If any of these
' files are missing by the time you run explore_halcon.hdev, the
' respective procedure will be omitted.
' 
' 
do_check_for_model_files(CookieModelExists,ClampsModelExists)
hal.赋值(mCount,hal.加(CookieModelExists,ClampsModelExists))
' 
' 
' To run this application continuously, simply uncomment the while statement:
'* while (1)
'     
p_show_intro(MainWindowHandle)
'     
p_initialize(StatusWindowHandle)
hal.赋值(NumCurrent,0)
hal.赋值(NumTotal,hal.加(37,mCount))
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Metrology"),hal.创建元组("Measure Geometric Shapes"),hal.创建元组("Measure Geometric Shapes Using a Metrology Model"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_metrology_model()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Optical Character Recognition"),hal.创建元组("Read Expiration Date"),hal.创建元组("Read Expiration Date on Medical Packages"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_find_text_expiration_date()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组("Object Identification"),hal.创建元组("Using Sample Based"),hal.创建元组("Identification"),hal.创建元组("Identify Wine Bottles"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_apply_sample_identifier_wine_bottle()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Inspection"),hal.创建元组("Using Bead Inspection Model"),hal.创建元组("Bead Inspection"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_bead_inspection()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("3D Reconstruction"),hal.创建元组("and 3D Surface Comparison"),hal.创建元组("Measure a Metal Part and Compare it to a Reference"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_compare_surface_sheet_of_light()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Inspection"),hal.创建元组("Using GMM Classifier"),hal.创建元组("Inspect Pill Types in a Blister"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_blister_mixed()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组("Multi-View Stereo"),hal.创建元组("Reconstruction and "),hal.创建元组("3D Surface-Based Matching"),hal.创建元组("Locate Pipe Joints from a Pile"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_locate_pipe_joints_stereo()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Identification"),hal.创建元组("Read Data Codes"),hal.创建元组("Read Distorted ECC200 Codes"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_ecc200_finder_pattern_tolerance()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Robot Vision"),hal.创建元组("for Automotive Industry"),hal.创建元组("Track an Engine Part"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_track_engine_part()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Identification"),hal.创建元组("Read Bar Codes"),hal.创建元组("Read Different Bar Codes"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_find_barcode()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Read Braille Characters"),hal.创建元组("Using Photometric Stereo"),hal.创建元组("Read Braille Characters on a Pharmaceutical Package"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_read_braille_photometric_stereo()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Camera Calibration"),hal.创建元组("with Scheimpflug Lens"),hal.创建元组("Calibrate a Camera with Telecentric Tilt Lens"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_calibrate_cameras_telecentric_tilt()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Inspection for"),hal.创建元组("Packaging Industry"),hal.创建元组("Inspect Bottle Mouth for Damages"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_bottle_mouth()
hal.wait_seconds(1)
'     
.判断开始 (hal.是否为真(ClampsModelExists))
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("3D Matching"),hal.创建元组("Based on a CAD Model"),hal.创建元组("Find Objects in Arbitrary 3D Poses"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_3d_matching_clamps()
hal.wait_seconds(1)
.判断结束

'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Optical Character Recognition"),hal.创建元组("Text Line Orientation"),hal.创建元组("Detect Rotated Dot Prints"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_textline_orientation()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Local Deformable Matching"),hal.创建元组("for Food Industry"),hal.创建元组("Locate Cocoa Packages"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_find_cocoa_package_local_deformable()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Surface Inspection"),hal.创建元组("Using Photometric Stereo"),hal.创建元组("Inspect the Texture of Leather Samples"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_inspect_leather_photometric_stereo()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Segmentation"),hal.创建元组("Using a GMM Classifier"),hal.创建元组("Detect Errors in a Mesh"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_novelty_detection_gmm()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Optical Flow"),hal.创建元组(""),hal.创建元组("Detect Moving Objects"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_optical_flow_bicycle()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Print Inspection"),hal.创建元组(""),hal.创建元组("Print Inspection using a Variation Model"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_variation_model_illumination()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Board Inspection"),hal.创建元组(""),hal.创建元组("Inspect the Radius of Bonding Balls"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_balls()
hal.wait_seconds(1)
'     
.判断开始 (hal.是否为真(CookieModelExists))
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Descriptor-based"),hal.创建元组("Matching"),hal.创建元组("Determine Pose of Cookie Box"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_cookie_box()
hal.wait_seconds(1)
.判断结束

'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Optical Character Recognition"),hal.创建元组(""),hal.创建元组("Extract the ID Number of Parcels"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_ocr_color()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Identification"),hal.创建元组("2D Data Codes"),hal.创建元组("Read ECC 200, Aztec, QR and Micro QR Data Codes and PDF417"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_2dbarcode()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("PCB Inspection"),hal.创建元组(""),hal.创建元组("Detect Defects on a Printed Circuit Board"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_pcb()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Shape-Based Matching under"),hal.创建元组("Perspective Distortions"),hal.创建元组("Locate Metal Parts in 3D World Coordinates"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_world_plane()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Color Image Processing"),hal.创建元组(""),hal.创建元组("Segment Fuses using Color Information"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_color_fuses()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Image Mosaicking"),hal.创建元组("Using Bundle Adjustment"),hal.创建元组("Create Image Mosaic of a Die"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_mosaicking()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Inspection"),hal.创建元组("of Non-Planar Surfaces"),hal.创建元组("Rectify the Surface of a Can"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_grid_rectification()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Completeness Check"),hal.创建元组(""),hal.创建元组("Inspect a Punching Die of Razors"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_razor_blades()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Medical Image Analysis"),hal.创建元组("Subpixel Line Detection"),hal.创建元组("Find and Measure Vessels in an Angiographic Image"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_angio()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Industrial Inspection"),hal.创建元组(""),hal.创建元组("Measure the Radius of Steel Balls"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_circles()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("3D Reconstruction"),hal.创建元组(""),hal.创建元组("Inspect a Resistor Using Depth From Focus"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_resistors()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Remote Sensing"),hal.创建元组(""),hal.创建元组("Extract Roads from an Aerial Image"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_roads()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Shape Recognition"),hal.创建元组("Using Shape-Based Matching"),hal.创建元组("Recognize Multiple Metal Parts"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_multiple_parts()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Surveillance"),hal.创建元组(""),hal.创建元组("Monitor Cars and People on a Crossing"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_xing()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Print Inspection"),hal.创建元组(""),hal.创建元组("Inspect the Print on a Pen Clip"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_print_check()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("3D Measurement"),hal.创建元组(""),hal.创建元组("Get the 3D Position of Circular Holes"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_3d_position_of_circles()
hal.wait_seconds(1)
'     
hal.赋值(NumCurrent,hal.加(NumCurrent,1))
p_show_status_window(hal.创建元组(""),hal.创建元组("Wood Inspection"),hal.创建元组(""),hal.创建元组("Determine the Age of a Tree"),hal.克隆元组(NumCurrent),hal.克隆元组(NumTotal),hal.克隆元组(StatusWindowHandle),hal.克隆元组(MainWindowHandle))
p_do_wood()
hal.wait_seconds(1)
'     
hal.dev_close_window()
p_show_end(hal.克隆元组(StatusWindowHandle))
'     
'* endwhile
' 

.子程序 p_initialize
.参数 StatusWindowHandle, tuple, 参考
.局部变量 ImgHeight, 视觉元组
.局部变量 ImgWidth, 视觉元组
.局部变量 Path, 视觉元组
.局部变量 StatusBackground, 视觉对象

hal.赋值(Path,"explore_halcon/")
hal.dev_update_off()
' 
hal.read_image(StatusBackground,hal.加(Path,"explore_halcon_bg"))
hal.get_image_size(StatusBackground,ImgWidth,ImgHeight)
hal.dev_open_window(0,648,ImgWidth,ImgHeight,"black",StatusWindowHandle)
' 
return()

.子程序 p_show_status_window
.参数 TitleCurrent0, tuple
.参数 TitleCurrent1, tuple
.参数 TitleCurrent2, tuple
.参数 TitleCurrentApplication, tuple
.参数 NumCurrent, tuple
.参数 NumTotal, tuple
.参数 StatusWindow, tuple
.参数 MainWindow, tuple
.局部变量 Ascent, 视觉元组
.局部变量 Background, 视觉对象
.局部变量 BarGap, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 ImgHeight, 视觉元组
.局部变量 ImgWidth, 视觉元组
.局部变量 Path, 视觉元组
.局部变量 PosCol, 视觉元组
.局部变量 PosRow, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 StartColumn, 视觉元组
.局部变量 StatusBackground, 视觉对象
.局部变量 Step, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WidthBar, 视觉元组

' 
' Show status window and current titles
' 
hal.赋值(Path,"explore_halcon/")
hal.赋值(BarGap,2)
' 
p_set_font(hal.克隆元组(StatusWindow))
hal.dev_set_window(StatusWindow)
' 
hal.read_image(StatusBackground,hal.加(Path,"explore_halcon_bg"))
hal.get_image_size(StatusBackground,ImgWidth,ImgHeight)
hal.dev_set_part(0,0,hal.减(ImgHeight,1),hal.减(ImgWidth,1))
hal.dev_display(StatusBackground)
' 
' MVTec blue
hal.dev_set_color("#003075")
hal.dev_set_line_width(1)
' 
hal.赋值(Step,hal.除(hal.减(ImgWidth,BarGap),NumTotal))
hal.赋值(WidthBar,hal.减(hal.乘(NumTotal,Step),BarGap))
hal.赋值(StartColumn,hal.除(hal.减(ImgWidth,WidthBar),2))
hal.赋值(Row1,hal.gen_tuple_const(NumTotal,140))
hal.赋值(Column1,hal.创建序列(StartColumn,hal.加(StartColumn,hal.乘(hal.减(NumTotal,1),Step)),Step))
hal.赋值(Row2,hal.gen_tuple_const(NumTotal,150))
hal.赋值(Column2,hal.加(Column1,hal.减(Step,BarGap)))
' 
hal.dev_set_draw("fill")
hal.gen_rectangle1(Rectangle,hal.取元素范围(Row1,0,hal.减(NumCurrent,1)),hal.取元素范围(Column1,0,hal.减(NumCurrent,1)),hal.取元素范围(Row2,0,hal.减(NumCurrent,1)),hal.取元素范围(Column2,0,hal.减(NumCurrent,1)))
hal.dev_display(Rectangle)
.判断开始 (hal.小于(NumCurrent,NumTotal))
hal.dev_set_draw("margin")
hal.gen_rectangle1(Rectangle,hal.取元素范围(Row1,NumCurrent,hal.减(NumTotal,1)),hal.取元素范围(Column1,NumCurrent,hal.减(NumTotal,1)),hal.取元素范围(Row2,NumCurrent,hal.减(NumTotal,1)),hal.取元素范围(Column2,NumCurrent,hal.减(NumTotal,1)))
hal.dev_display(Rectangle)
.判断结束

' 
hal.set_tposition(StatusWindow,165,12)
hal.write_string(StatusWindow,TitleCurrent0)
hal.set_tposition(StatusWindow,190,12)
hal.write_string(StatusWindow,TitleCurrent1)
hal.set_tposition(StatusWindow,215,12)
hal.write_string(StatusWindow,TitleCurrent2)
' 
' 
hal.dev_set_window(MainWindow)
hal.read_image(Background,hal.加(Path,"explore_halcon_next_demo"))
hal.get_image_size(Background,Width,Height)
hal.dev_set_window_extents(0,0,640,480)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Background)
p_set_font(hal.克隆元组(MainWindow))
hal.get_string_extents(MainWindow,TitleCurrentApplication,Ascent,Descent,Width,Height)
hal.dev_set_part(0,0,479,639)
hal.赋值(PosRow,hal.减(194,hal.除(Height,到小数(2.))))
hal.赋值(PosCol,hal.除(hal.减(640,Width),到小数(2.)))
hal.dev_set_color("#003075")
hal.set_tposition(MainWindow,PosRow,PosCol)
hal.write_string(MainWindow,TitleCurrentApplication)
hal.wait_seconds(3)
' 
' 
return()

.子程序 p_do_ocr_color
.局部变量 Blue, 视觉对象
.局部变量 Cluster, 视觉对象
.局部变量 Cluster1, 视觉对象
.局部变量 Cluster2, 视觉对象
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 Confidence, 视觉元组
.局部变量 Deviation, 视觉元组
.局部变量 FinalNumbers, 视觉对象
.局部变量 FinalNumbersUnsorted, 视觉对象
.局部变量 Foreground, 视觉对象
.局部变量 ForegroundRaw, 视觉对象
.局部变量 Green, 视觉对象
.局部变量 GreenReduced, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageMean, 视觉对象
.局部变量 ImageOCR, 视觉对象
.局部变量 ImageOCRRaw, 视觉对象
.局部变量 ImageSub, 视觉对象
.局部变量 ImgNr, 视觉元组
.局部变量 Mean, 视觉对象
.局部变量 MeanIntensity, 视觉元组
.局部变量 NoNumbers, 视觉对象
.局部变量 NumNumbers, 视觉元组
.局部变量 NumberCand, 视觉对象
.局部变量 NumberParts, 视觉对象
.局部变量 NumberRegion, 视觉对象
.局部变量 Numbers, 视觉对象
.局部变量 OCRHandle, 视觉元组
.局部变量 Opening, 视觉对象
.局部变量 RecChar, 视觉元组
.局部变量 Red, 视觉对象
.局部变量 RedReduced, 视觉对象
.局部变量 RegionFillUp, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 UsedThreshold, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WidthCluster, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' OCR (numbers) with color segmentation
' 
hal.dev_update_off()
' 
hal.read_image(Image,"ocr/color_form_01")
hal.get_image_size(Image,Width,Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
' 
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_set_line_width(3)
hal.dev_set_draw("margin")
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.read_ocr_class_mlp("Industrial_0-9_NoRej",OCRHandle)
hal.赋值(ImgNr,1)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 40))
hal.read_image(Image,hal.加("ocr/color_form_0",ImgNr))
'     
'     Detect foreground
'     
hal.mean_image(Image,Mean,3,3)
hal.decompose3(Mean,Red,Green,Blue)
hal.threshold(Green,ForegroundRaw,0,220)
hal.clip_region(ForegroundRaw,Foreground,3,3,hal.减(Height,4),hal.减(Width,4))
'     
'     Divide colors
'     
hal.reduce_domain(Red,Foreground,RedReduced)
hal.reduce_domain(Green,Foreground,GreenReduced)
hal.sub_image(RedReduced,GreenReduced,ImageSub,2,128)
hal.mean_image(ImageSub,ImageMean,3,3)
hal.binary_threshold(ImageMean,Cluster1,"smooth_histo","dark",UsedThreshold)
hal.difference(Foreground,Cluster1,Cluster2)
hal.concat_obj(Cluster1,Cluster2,Cluster)
hal.opening_circle(Cluster,Opening,2.5)
hal.smallest_rectangle1(Opening,Row1,Column1,Row2,Column2)
hal.赋值(WidthCluster,hal.加(hal.减(Column2,Column1),1))
.判断开始 (hal.大于(hal.取元素(WidthCluster,0),hal.取元素(WidthCluster,1)))
hal.select_obj(Opening,NumberRegion,2)
.默认
hal.select_obj(Opening,NumberRegion,1)
.判断结束

'     
'     Expand Numbers
'     
hal.closing_rectangle1(NumberRegion,NumberCand,1,20)
hal.difference(Image,NumberCand,NoNumbers)
hal.connection(NumberRegion,NumberParts)
hal.intensity(NumberParts,Green,MeanIntensity,Deviation)
hal.expand_gray_ref(NumberParts,Green,NoNumbers,Numbers,20,"image",MeanIntensity,48)
hal.union1(Numbers,NumberRegion)
hal.connection(NumberRegion,Numbers)
'     
'     Fine tuning
'     
hal.fill_up_shape(Numbers,RegionFillUp,"area",1,100)
hal.opening_circle(RegionFillUp,FinalNumbersUnsorted,3.5)
hal.sort_region(FinalNumbersUnsorted,FinalNumbers,"character","true","row")
hal.dev_set_color("black")
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Extract ID number of parcel","window",-1,-1,"black","true")
.判断开始 (hal.小于(I,3))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.默认
'*         wait_seconds (0.25)
.判断结束

hal.dev_display(FinalNumbers)
hal.count_obj(FinalNumbers,NumNumbers)
hal.union1(FinalNumbers,NumberRegion)
hal.difference(Image,NumberRegion,NoNumbers)
hal.paint_region(NoNumbers,Green,ImageOCRRaw,255,"fill")
hal.paint_region(NumberRegion,ImageOCRRaw,ImageOCR,0,"fill")
'     
'     OCR
'     
hal.do_ocr_multi_class_mlp(FinalNumbers,ImageOCR,OCRHandle,RecChar,Confidence)
hal.disp_message(WindowHandle,hal.加("Extracted ID: ",hal.sum(RecChar)),"window",400,-1,"black","true")
.判断开始 (hal.小于(I,3))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.默认
'*         wait_seconds (0.25)
.判断结束

hal.赋值(ImgNr,hal.加(ImgNr,1))
.判断开始 (hal.大于(ImgNr,8))
hal.赋值(ImgNr,1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.clear_ocr_class_mlp(OCRHandle)
hal.wait_seconds(2)
return()

.子程序 p_do_circles
.局部变量 Attrib, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ContEllipse, 视觉对象
.局部变量 ContoursSplit, 视觉对象
.局部变量 Edges, 视觉对象
.局部变量 EndPhi, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 J, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 PointOrder, 视觉元组
.局部变量 Radius, 视觉元组
.局部变量 Region, 视觉对象
.局部变量 RegionBorder, 视觉对象
.局部变量 RegionClipped, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 StartPhi, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandle1, 视觉元组

' 
hal.dev_update_off()
hal.read_image(Image,"double_circle")
hal.get_image_size(Image,Width,Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
' 
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Measure the radius of steel balls","window",-1,-1,"black","true")
hal.fast_threshold(Image,Region,0,120,7)
hal.boundary(Region,RegionBorder,"inner")
hal.clip_region_rel(RegionBorder,RegionClipped,5,5,5,5)
hal.dilation_circle(RegionClipped,RegionDilation,2.5)
hal.reduce_domain(Image,RegionDilation,ImageReduced)
hal.edges_sub_pix(ImageReduced,Edges,"canny",2,20,60)
hal.segment_contours_xld(Edges,ContoursSplit,"lines_circles",5,4,3)
hal.count_obj(ContoursSplit,Number)
hal.dev_set_draw("margin")
hal.赋值(J,0)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, Number))
hal.dev_set_line_width(3)
hal.select_obj(ContoursSplit,ObjectSelected,I)
hal.get_contour_global_attrib_xld(ObjectSelected,"cont_approx",Attrib)
.判断开始 (hal.大于(Attrib,0))
hal.fit_circle_contour_xld(ObjectSelected,"ahuber",-1,2,0,3,2,Row,Column,Radius,StartPhi,EndPhi,PointOrder)
hal.gen_ellipse_contour_xld(ContEllipse,Row,Column,0,Radius,Radius,0,hal.乘(4,hal.acos(0)),"positive",到小数(1.0))
hal.dev_set_color("green")
hal.dev_display(ContEllipse)
.判断开始 (hal.等于(I,1))
hal.dev_set_line_width(1)
hal.dev_set_color("blue")
hal.disp_line(WindowHandle,169,458,188,379)
hal.disp_message(WindowHandle,hal.加(hal.加("Radius: ",hal.文本格式化(Radius,"5.2f"))," px"),"image",145,390,"black","true")
'             
.判断结束

.判断开始 (hal.等于(I,3))
hal.dev_set_line_width(1)
hal.dev_set_color("blue")
hal.disp_line(WindowHandle,268,181,356,213)
hal.disp_message(WindowHandle,hal.加(hal.加("Radius: ",hal.文本格式化(Radius,"5.2f"))," px"),"window",244,91,"black","true")
.判断结束

.判断开始 (hal.小于(Radius,100))
hal.dev_set_line_width(1)
hal.dev_set_color("blue")
hal.disp_line(WindowHandle,316,373,123,293)
hal.disp_message(WindowHandle,hal.加(hal.加("Radius: ",hal.文本格式化(Radius,"5.2f"))," px"),"window",100,200,"black","true")
hal.dev_open_window(205,20,256,256,"black",WindowHandle1)
hal.dev_set_part(hal.round(hal.减(Row,hal.加(Radius,5))),hal.round(hal.减(Column,hal.加(Radius,5))),hal.round(hal.加(Row,hal.加(Radius,5))),hal.round(hal.加(Column,hal.加(Radius,5))))
hal.dev_display(Image)
hal.dev_set_line_width(3)
hal.dev_set_color("green")
hal.dev_display(ContEllipse)
hal.wait_seconds(4)
hal.dev_close_window()
hal.dev_set_window(WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
.判断结束

hal.赋值(J,hal.加(J,1))
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(4)
' 
' 
return()

.子程序 p_do_razor_blades
.局部变量 Amp11, 视觉元组
.局部变量 Amp12, 视觉元组
.局部变量 Amp21, 视觉元组
.局部变量 Amp22, 视觉元组
.局部变量 AngleCheck, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 CenterROIColumn, 视觉元组
.局部变量 CenterROIRow, 视觉元组
.局部变量 ColEdge11, 视觉元组
.局部变量 ColEdge12, 视觉元组
.局部变量 ColEdge21, 视觉元组
.局部变量 ColEdge22, 视觉元组
.局部变量 ColFault, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 ColumnCheck, 视觉元组
.局部变量 DistColRect1Rect2, 视觉元组
.局部变量 DistRect1CenterCol, 视觉元组
.局部变量 DistRect1CenterRow, 视觉元组
.局部变量 Distance1, 视觉元组
.局部变量 Distance2, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 ImageROI, 视觉对象
.局部变量 Indices, 视觉元组
.局部变量 J, 视觉元组
.局部变量 MeasureHandle1, 视觉元组
.局部变量 MeasureHandle2, 视觉元组
.局部变量 MeasureROI1, 视觉对象
.局部变量 MeasureROI1AtNewPosition, 视觉对象
.局部变量 MeasureROI2, 视觉对象
.局部变量 MeasureROI2AtNewPosition, 视觉对象
.局部变量 ModelAtNewPosition, 视觉对象
.局部变量 ModelID, 视觉元组
.局部变量 ModelImage, 视觉对象
.局部变量 ModelROI, 视觉对象
.局部变量 MovementOfObject, 视觉元组
.局部变量 NumberTeeth1, 视觉元组
.局部变量 NumberTeeth2, 视觉元组
.局部变量 ROIPart1, 视觉对象
.局部变量 ROIPart2, 视觉对象
.局部变量 Rect1Col, 视觉元组
.局部变量 Rect1Row, 视觉元组
.局部变量 Rect2Col, 视觉元组
.局部变量 Rect2ColCheck, 视觉元组
.局部变量 Rect2ColTmp, 视觉元组
.局部变量 Rect2Row, 视觉元组
.局部变量 Rect2RowCheck, 视觉元组
.局部变量 Rect2RowTmp, 视觉元组
.局部变量 RectLength1, 视觉元组
.局部变量 RectLength2, 视觉元组
.局部变量 RectPhi, 视觉元组
.局部变量 RectPhiCheck, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 RowCheck, 视觉元组
.局部变量 RowEdge11, 视觉元组
.局部变量 RowEdge12, 视觉元组
.局部变量 RowEdge21, 视觉元组
.局部变量 RowEdge22, 视觉元组
.局部变量 RowFault, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 SearchImage, 视觉对象
.局部变量 ShapeModel, 视觉对象
.局部变量 ShapeModelImage, 视觉对象
.局部变量 ShapeModelRegion, 视觉对象
.局部变量 Status, 视觉元组
.局部变量 USING_TRANSLATE_MEASURE, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 Width1, 视觉元组
.局部变量 Width2, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandleZoom, 视觉元组
.局部变量 false, 视觉元组
.局部变量 true, 视觉元组

' 
' ------------------------------------------------------------------------------------------------
' This example program uses shape-based matching to align ROIs for the measure
' tool, which then inspects individual razor blades.
' The program can be run in two modes: (1) with the full affine transformation
' (2) using translate_measure
' Modify the next line to switch between the modes.
hal.赋值(USING_TRANSLATE_MEASURE,0)
' ------------------------------------------------------------------------------------------------
' 
hal.dev_update_off()
' image acquisition and window size
hal.read_image(ModelImage,"razors1")
hal.get_image_size(ModelImage,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_display(ModelImage)
' 
' colors and other settings for the visualization
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
' -------------------  start of the application  ----------------
' -> select the model object
hal.赋值(Row1,46)
hal.赋值(Column1,57)
hal.赋值(Row2,79)
hal.赋值(Column2,94)
hal.gen_rectangle1(ROIPart1,Row1,Column1,Row2,Column2)
hal.gen_rectangle1(ROIPart2,hal.加(Row1,364),hal.加(Column1,13),hal.加(Row2,364),hal.加(Column2,13))
hal.union2(ROIPart1,ROIPart2,ModelROI)
hal.area_center(ModelROI,Area,CenterROIRow,CenterROIColumn)
hal.dev_display(ModelImage)
hal.disp_message(WindowHandle,"Inspect a punching die of razors","window",12,12,"black","true")
hal.wait_seconds(3)
hal.dev_display(ModelImage)
hal.dev_set_color("yellow")
hal.dev_display(ModelROI)
hal.disp_message(WindowHandle,"Define a model","window",12,12,"black","true")
hal.wait_seconds(2)
' -> create the model
hal.reduce_domain(ModelImage,ModelROI,ImageROI)
hal.create_shape_model(ImageROI,4,0,0,"auto","none","use_polarity",30,10,ModelID)
hal.inspect_shape_model(ImageROI,ShapeModelImage,ShapeModelRegion,1,30)
hal.gen_contours_skeleton_xld(ShapeModelRegion,ShapeModel,1,"filter")
hal.dev_clear_window()
hal.disp_message(WindowHandle,"Model contour","window",12,12,"black","true")
hal.dev_set_color("blue")
hal.dev_display(ShapeModelRegion)
hal.wait_seconds(2)
' step 1: create variables describing  the measurement ROIs and display them
hal.赋值(Rect1Row,244)
hal.赋值(Rect1Col,73)
hal.赋值(DistColRect1Rect2,17)
hal.赋值(Rect2Row,Rect1Row)
hal.赋值(Rect2Col,hal.加(Rect1Col,DistColRect1Rect2))
hal.赋值(RectPhi,hal.rad(90))
hal.赋值(RectLength1,122)
hal.赋值(RectLength2,2)
hal.gen_rectangle2(MeasureROI1,Rect1Row,Rect1Col,RectPhi,RectLength1,RectLength2)
hal.gen_rectangle2(MeasureROI2,Rect2Row,Rect2Col,RectPhi,RectLength1,RectLength2)
hal.dev_display(ModelImage)
hal.dev_set_color("yellow")
hal.dev_display(MeasureROI1)
hal.dev_display(MeasureROI2)
.判断开始 (hal.不等于(USING_TRANSLATE_MEASURE,0))
'     -> measure objects are created only once in advance and then translated later
hal.gen_measure_rectangle2(Rect1Row,Rect1Col,RectPhi,RectLength1,RectLength2,Width,Height,"bilinear",MeasureHandle1)
hal.gen_measure_rectangle2(Rect2Row,Rect2Col,RectPhi,RectLength1,RectLength2,Width,Height,"bilinear",MeasureHandle2)
.判断结束

' step 2: move the reference point to the center of the first measure rectangle
hal.赋值(DistRect1CenterRow,hal.减(Rect1Row,CenterROIRow))
hal.赋值(DistRect1CenterCol,hal.减(Rect1Col,CenterROIColumn))
hal.set_shape_model_origin(ModelID,DistRect1CenterRow,DistRect1CenterCol)
hal.disp_message(WindowHandle,"Define measurement rectangles","window",12,12,"black","true")
hal.wait_seconds(2)
' step 3: find the objects in another image
hal.read_image(SearchImage,"razors2")
hal.dev_display(SearchImage)
hal.disp_message(WindowHandle,"Perform the quality measurement","window",12,12,"black","true")
hal.set_tposition(WindowHandle,16,12)
'* write_string (WindowHandle, 'Quality inspection of a punching die of razors')
hal.find_shape_model(SearchImage,ModelID,0,0,0.8,0,0.5,"interpolation",0,0.7,RowCheck,ColumnCheck,AngleCheck,Score)
hal.tuple_sort_index(ColumnCheck,Indices)
hal.tuple_select(ColumnCheck,Indices,ColumnCheck)
hal.tuple_select(RowCheck,Indices,RowCheck)
hal.tuple_select(AngleCheck,Indices,AngleCheck)
.判断开始 (hal.大于(hal.取元素总数(Score),0))
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(Score),1)))
'         step 4: determine the affine transformation
hal.vector_angle_to_rigid(Rect1Row,Rect1Col,0,hal.取元素(RowCheck,I),hal.取元素(ColumnCheck,I),hal.取元素(AngleCheck,I),MovementOfObject)
hal.affine_trans_contour_xld(ShapeModel,ModelAtNewPosition,MovementOfObject)
hal.dev_set_color("blue")
hal.dev_display(ModelAtNewPosition)
'         step 5: measure width and distance of the teeth
'         -> display the moved ROIs
hal.affine_trans_region(MeasureROI1,MeasureROI1AtNewPosition,MovementOfObject,"constant")
hal.affine_trans_region(MeasureROI2,MeasureROI2AtNewPosition,MovementOfObject,"constant")
hal.dev_set_color("yellow")
hal.dev_display(MeasureROI1AtNewPosition)
hal.dev_display(MeasureROI2AtNewPosition)
.判断开始 (hal.不等于(USING_TRANSLATE_MEASURE,0))
'             -> translate the already created measure objects
hal.translate_measure(MeasureHandle1,hal.取元素(RowCheck,I),hal.取元素(ColumnCheck,I))
hal.translate_measure(MeasureHandle2,hal.取元素(RowCheck,I),hal.加(hal.取元素(ColumnCheck,I),DistColRect1Rect2))
hal.measure_pairs(SearchImage,MeasureHandle1,2,25,"negative","all",RowEdge11,ColEdge11,Amp11,RowEdge21,ColEdge21,Amp21,Width1,Distance1)
hal.measure_pairs(SearchImage,MeasureHandle2,2,25,"negative","all",RowEdge12,ColEdge12,Amp12,RowEdge22,ColEdge22,Amp22,Width2,Distance2)
.默认
'             -> create new measure objects and destroy them after the measurement
hal.赋值(RectPhiCheck,hal.加(RectPhi,hal.取元素(AngleCheck,I)))
hal.gen_measure_rectangle2(hal.取元素(RowCheck,I),hal.取元素(ColumnCheck,I),RectPhiCheck,RectLength1,RectLength2,Width,Height,"bilinear",MeasureHandle1)
'             -> transform the center of the second measure ROIs
hal.affine_trans_point_2d(MovementOfObject,hal.加(Rect2Row,0.5),hal.加(Rect2Col,0.5),Rect2RowTmp,Rect2ColTmp)
hal.赋值(Rect2RowCheck,hal.减(Rect2RowTmp,0.5))
hal.赋值(Rect2ColCheck,hal.减(Rect2ColTmp,0.5))
hal.gen_measure_rectangle2(Rect2RowCheck,Rect2ColCheck,RectPhiCheck,RectLength1,RectLength2,Width,Height,"bilinear",MeasureHandle2)
hal.measure_pairs(SearchImage,MeasureHandle1,2,25,"negative","all",RowEdge11,ColEdge11,Amp11,RowEdge21,ColEdge21,Amp21,Width1,Distance1)
hal.measure_pairs(SearchImage,MeasureHandle2,2,25,"negative","all",RowEdge12,ColEdge12,Amp12,RowEdge22,ColEdge22,Amp22,Width2,Distance2)
hal.close_measure(MeasureHandle1)
hal.close_measure(MeasureHandle2)
.判断结束

'         step 6: check for too short or missing teeth
hal.赋值(NumberTeeth1,hal.取元素总数(Width1))
hal.赋值(NumberTeeth2,hal.取元素总数(Width2))
hal.dev_set_color("red")
hal.赋值(Status,true)
.判断开始 (hal.小于(NumberTeeth1,37))
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(NumberTeeth1,2)))
.判断开始 (hal.大于(hal.取元素(Distance1,J),到小数(4.0)))
hal.赋值(RowFault,hal.round(hal.乘(0.5,hal.加(hal.取元素(RowEdge11,hal.加(J,1)),hal.取元素(RowEdge21,J)))))
hal.赋值(ColFault,hal.round(hal.乘(0.5,hal.加(hal.取元素(ColEdge11,hal.加(J,1)),hal.取元素(ColEdge21,J)))))
hal.disp_rectangle2(WindowHandle,RowFault,ColFault,0,4,4)
hal.set_tposition(WindowHandle,hal.减(hal.取元素(RowEdge11,hal.减(NumberTeeth1,1)),30),hal.减(hal.取元素(ColEdge11,hal.减(NumberTeeth1,1)),12))
hal.write_string(WindowHandle,"nok")
hal.dev_open_window(hal.减(RowFault,40),hal.加(ColFault,30),80,80,"black",WindowHandleZoom)
hal.dev_set_part(hal.减(RowFault,10),hal.减(ColFault,10),hal.加(RowFault,10),hal.加(ColFault,10))
hal.dev_display(SearchImage)
hal.disp_rectangle2(WindowHandleZoom,RowFault,ColFault,0,4,4)
hal.wait_seconds(4)
hal.dev_close_window()
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.赋值(Status,false)
.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
.判断结束

.判断开始 (hal.小于(NumberTeeth2,37))
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(NumberTeeth2,2)))
.判断开始 (hal.大于(hal.取元素(Distance2,J),到小数(4.0)))
hal.赋值(RowFault,hal.round(hal.乘(0.5,hal.加(hal.取元素(RowEdge12,hal.加(J,1)),hal.取元素(RowEdge22,J)))))
hal.赋值(ColFault,hal.round(hal.乘(0.5,hal.加(hal.取元素(ColEdge12,hal.加(J,1)),hal.取元素(ColEdge22,J)))))
hal.disp_rectangle2(WindowHandle,RowFault,ColFault,0,4,4)
hal.set_tposition(WindowHandle,hal.减(hal.取元素(RowEdge12,hal.减(NumberTeeth2,1)),30),hal.减(hal.取元素(ColEdge12,hal.减(NumberTeeth2,1)),25))
hal.write_string(WindowHandle,"nok")
hal.dev_open_window(hal.减(RowFault,40),hal.加(ColFault,30),80,80,"black",WindowHandleZoom)
hal.dev_set_part(hal.减(RowFault,10),hal.减(ColFault,10),hal.加(RowFault,10),hal.加(ColFault,10))
hal.dev_display(SearchImage)
hal.disp_rectangle2(WindowHandleZoom,RowFault,ColFault,0,4,4)
hal.dev_set_window(WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.wait_seconds(3)
hal.dev_set_window(WindowHandleZoom)
hal.dev_close_window()
hal.赋值(Status,false)
.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
.判断结束

hal.dev_set_window(WindowHandle)
.判断开始 (hal.是否为真(Status))
hal.dev_set_color("green")
hal.set_tposition(WindowHandle,hal.减(hal.取元素(RowEdge11,hal.减(NumberTeeth1,1)),30),hal.减(hal.取元素(ColEdge11,hal.减(NumberTeeth1,1)),3))
hal.write_string(WindowHandle,"ok")
.判断结束

hal.dev_set_color("yellow")
hal.wait_seconds(0.3)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
.判断结束

' -------------------  end of the application  -----------------
' clean up
.判断开始 (hal.不等于(USING_TRANSLATE_MEASURE,0))
hal.close_measure(MeasureHandle1)
hal.close_measure(MeasureHandle2)
.判断结束

hal.clear_shape_model(ModelID)
hal.wait_seconds(2)
return()

.子程序 p_do_pcb
.局部变量 Area, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageClosing, 视觉对象
.局部变量 ImageOpening, 视觉对象
.局部变量 Number, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 RegionDynThresh, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandle1, 视觉元组

' 
hal.dev_update_off()
hal.read_image(Image,"pcb")
hal.get_image_size(Image,Width,Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
' 
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Image)
p_set_font(hal.克隆元组(WindowHandle))
hal.disp_message(WindowHandle,"Detect defects on a Printed Circuit Board","window",12,12,"black","true")
hal.wait_seconds(3)
' 
hal.dev_set_color("black")
' detect defects...
hal.gray_opening_shape(Image,ImageOpening,7,7,"octagon")
hal.gray_closing_shape(Image,ImageClosing,7,7,"octagon")
hal.dyn_threshold(ImageOpening,ImageClosing,RegionDynThresh,75,"not_equal")
hal.connection(RegionDynThresh,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",3,99999)
hal.dev_open_window(220,380,256,256,"black",WindowHandle1)
hal.count_obj(SelectedRegions,Number)
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, Number))
hal.dev_set_window(WindowHandle)
hal.dev_set_draw("margin")
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Image)
hal.dev_set_color("red")
hal.select_obj(SelectedRegions,ObjectSelected,I)
hal.dev_display(SelectedRegions)
hal.area_center(ObjectSelected,Area,Row,Column)
hal.dev_set_color("blue")
hal.dev_set_line_width(3)
hal.disp_rectangle1(WindowHandle,hal.round(hal.减(Row,11)),hal.round(hal.减(Column,11)),hal.round(hal.加(Row,11)),hal.round(hal.加(Column,11)))
hal.dev_set_line_width(2)
hal.disp_message(WindowHandle,"Detect defects on a Printed Circuit Board","window",12,12,"black","true")
hal.dev_set_window(WindowHandle1)
hal.dev_set_part(hal.round(hal.减(Row,10)),hal.round(hal.减(Column,10)),hal.round(hal.加(Row,10)),hal.round(hal.加(Column,10)))
hal.dev_display(Image)
hal.dev_set_color("red")
hal.dev_display(ObjectSelected)
.判断开始 (hal.小于(I,10))
hal.wait_seconds(0.9)
.默认
hal.wait_seconds(0.1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(1)
hal.dev_set_window(WindowHandle1)
hal.dev_close_window()
' 
' 
return()

.子程序 p_do_resistors
.局部变量 Confidence, 视觉对象
.局部变量 ConnectedRes, 视觉对象
.局部变量 ConnectedSol, 视觉对象
.局部变量 Depth, 视觉对象
.局部变量 DepthHighConf, 视觉对象
.局部变量 DepthMean, 视觉对象
.局部变量 Exception, 视觉元组
.局部变量 FillUpSol, 视觉对象
.局部变量 FinalRes, 视觉对象
.局部变量 FinalSol, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 Image1, 视觉对象
.局部变量 ImageExtended, 视觉对象
.局部变量 ImageScaleMax, 视觉对象
.局部变量 Names, 视觉元组
.局部变量 Resistor, 视觉对象
.局部变量 Selected, 视觉对象
.局部变量 SelectedSol, 视觉对象
.局部变量 Solder, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' Extract depth using multiple focus levels
' 
hal.赋值(Names,hal.创建元组())
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 10))
hal.赋值(Names,hal.创建元组(Names,hal.加("dff/focus_",hal.文本格式化(I,".2"))))
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.dev_update_off()
hal.read_image(Image,Names)
hal.channels_to_image(Image,Image)
hal.get_image_size(Image,Width,Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_set_window(WindowHandle)
' 
p_set_font(hal.克隆元组(WindowHandle))
' Access a channel of a multichannel image
hal.dev_set_color("red")
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 10))
hal.access_channel(Image,Image1,I)
hal.dev_display(Image1)
hal.disp_message(WindowHandle,"Reconstruct the height by depth from focus","window",12,12,"black","true")
hal.disp_message(WindowHandle,hal.加("Image ",I),"window",42,12,"black","true")
hal.wait_seconds(0.3)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.depth_from_focus(Image,Depth,Confidence,"highpass","next_maximum")
' Smooth by averaging
hal.mean_image(Depth,DepthHighConf,11,11)
hal.select_grayvalues_from_channels(Image,DepthHighConf,Selected)
hal.scale_image_max(DepthHighConf,ImageScaleMax)
hal.mean_image(ImageScaleMax,DepthMean,51,51)
hal.threshold(DepthMean,Resistor,158,255)
hal.connection(Resistor,ConnectedRes)
' Select regions of a given shape
hal.select_shape_std(ConnectedRes,FinalRes,"max_area",0)
hal.threshold(DepthMean,Solder,125,158)
hal.connection(Solder,ConnectedSol)
hal.select_shape_std(ConnectedSol,SelectedSol,"max_area",0)
' Fill up holes
hal.fill_up(SelectedSol,FillUpSol)
hal.opening_circle(FillUpSol,FinalSol,7.5)
hal.dev_display(Selected)
hal.disp_message(WindowHandle,"Reconstructed sharp image","window",12,12,"black","true")
hal.wait_seconds(3)
hal.dev_set_color("black")
hal.dev_clear_window()
hal.append_channel(DepthMean,Selected,ImageExtended)
'try
hal.dev_set_paint(hal.创建元组("3d_plot","texture",4,0.9,0.03,0.45,-0.1,0.4,-0.03,-0.08,0.01))
*' 不支持的方法：hal.catch(Exception)
hal.dev_set_paint(hal.创建元组("3d_plot_lines",5,1,110,160,450,0,0))
'endtry
hal.dev_display(ImageExtended)
hal.disp_message(WindowHandle,"Extracted height information","window",12,12,"black","true")
hal.disp_message(WindowHandle,"Top of SMD","image",90,130,"black","true")
hal.disp_message(WindowHandle,"Solder","image",220,160,"black","true")
hal.dev_set_color("yellow")
hal.disp_line(WindowHandle,146,358,112,285)
hal.disp_line(WindowHandle,263,368,239,264)
hal.wait_seconds(5)
hal.dev_set_paint("default")
hal.dev_display(Selected)
hal.dev_set_line_width(2)
hal.dev_set_draw("margin")
hal.disp_message(WindowHandle,"Solder","image",254,90,"black","true")
hal.dev_set_color("blue")
hal.dev_display(FinalSol)
hal.dev_set_color("orange")
hal.dev_display(FinalRes)
hal.disp_message(WindowHandle,"Top of solder","image",120,15,"black","true")
hal.disp_message(WindowHandle,"Processed height information","window",12,12,"black","true")
hal.dev_set_color("yellow")
hal.dev_set_line_width(2)
hal.disp_line(WindowHandle,114,208,122,191)
hal.disp_line(WindowHandle,254,232,263,195)
hal.wait_seconds(4)
' 
' 
return()

.子程序 p_do_balls
.局部变量 Balls, 视觉对象
.局部变量 Bond, 视觉对象
.局部变量 Bright, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 Diameter, 视觉元组
.局部变量 Die, 视觉对象
.局部变量 DieGrey, 视觉对象
.局部变量 FinalBalls, 视觉对象
.局部变量 Forbidden, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 ImageNames, 视觉元组
.局部变量 IntermediateBalls, 视觉对象
.局部变量 J, 视觉元组
.局部变量 Max, 视觉元组
.局部变量 Min, 视觉元组
.局部变量 NumBalls, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 Radius, 视觉元组
.局部变量 Range, 视觉元组
.局部变量 Rect, 视觉对象
.局部变量 Rectangle, 视觉对象
.局部变量 RegionExpand, 视觉对象
.局部变量 RoundBalls, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 SingleBalls, 视觉对象
.局部变量 StoreEmpty, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 Wires, 视觉对象
.局部变量 WiresFilled, 视觉对象
.局部变量 k, 视觉元组
.局部变量 meanDiameter, 视觉元组
.局部变量 mimDiameter, 视觉元组

' 
' Inspection of Ball Bonding
' 
hal.赋值(ImageNames,hal.创建元组("die/die_02","die/die_03","die/die_04","die/die_07"))
hal.read_image(Bond,hal.取元素(ImageNames,0))
hal.get_image_size(Bond,Width,Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_update_off()
' 
p_set_font(hal.克隆元组(WindowHandle))
hal.get_system("store_empty_region",StoreEmpty)
hal.set_system("store_empty_region","false")
hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
hal.赋值 (k, 1)
.判断循环首 (hal.小于等于 (k, 1))
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(ImageNames),1)))
hal.read_image(Bond,hal.取元素(ImageNames,I))
hal.dev_display(Bond)
hal.min_max_gray(Bond,Bond,0,Min,Max,Range)
hal.threshold(Bond,Bright,hal.减(Max,80),255)
hal.shape_trans(Bright,Die,"rectangle2")
hal.dev_set_color("yellow")
hal.dev_display(Die)
hal.reduce_domain(Bond,Die,DieGrey)
hal.min_max_gray(Die,Bond,0,Min,Max,Range)
hal.threshold(DieGrey,Wires,0,hal.加(Min,30))
hal.fill_up_shape(Wires,WiresFilled,"area",1,100)
hal.opening_circle(WiresFilled,Balls,9.5)
hal.connection(Balls,SingleBalls)
hal.select_shape_std(SingleBalls,Rect,"rectangle1",90)
hal.difference(SingleBalls,Rect,IntermediateBalls)
hal.gen_empty_region(Forbidden)
hal.expand_gray(IntermediateBalls,Bond,Forbidden,RegionExpand,4,"image",6)
hal.opening_circle(RegionExpand,RoundBalls,15.5)
hal.sort_region(RoundBalls,FinalBalls,"first_point","true","column")
hal.smallest_circle(FinalBalls,Row,Column,Radius)
hal.赋值(NumBalls,hal.取元素总数(Radius))
hal.赋值(Diameter,hal.乘(2,Radius))
hal.赋值(meanDiameter,hal.除(hal.sum(Diameter),NumBalls))
hal.赋值(mimDiameter,hal.求最小值(Diameter))
'*         dev_display (RoundBalls)
hal.dev_set_draw("fill")
hal.dev_set_color("light gray")
hal.gen_rectangle1(Rectangle,hal.加(hal.减(hal.除(Height,2),54),3),hal.加(hal.除(Width,2),3),hal.加(hal.加(hal.减(hal.除(Height,2),54),hal.乘(hal.加(hal.取元素总数(Radius),1),24)),3),hal.加(hal.加(hal.除(Width,2),250),3))
hal.dev_display(Rectangle)
hal.dev_set_color("white")
hal.gen_rectangle1(Rectangle,hal.减(hal.除(Height,2),54),hal.除(Width,2),hal.加(hal.减(hal.除(Height,2),54),hal.乘(hal.加(hal.取元素总数(Radius),1),24)),hal.加(hal.除(Width,2),250))
hal.dev_display(Rectangle)
hal.dev_set_draw("margin")
hal.dev_set_color("black")
hal.disp_line(WindowHandle,224,365,224,611)
hal.disp_line(WindowHandle,201,415,hal.加(201,hal.乘(hal.加(hal.取元素总数(Radius),1),24)),415)
hal.set_tposition(WindowHandle,hal.减(hal.除(Height,2),54),hal.除(Width,2))
hal.write_string(WindowHandle,"No     Radius")
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(Radius),1)))
hal.select_obj(FinalBalls,ObjectSelected,hal.加(J,1))
hal.dev_set_color("white")
hal.set_tposition(WindowHandle,hal.减(hal.取元素(Row,J),10),hal.减(hal.取元素(Column,J),10))
hal.write_string(WindowHandle,hal.加(J,1))
hal.dev_set_color("black")
hal.set_tposition(WindowHandle,hal.加(hal.减(hal.除(Height,2),30),hal.乘(J,24)),hal.除(Width,2))
hal.write_string(WindowHandle,hal.加(hal.加(hal.文本格式化(hal.加(J,1),"2d"),"   "),hal.文本格式化(hal.取元素(Radius,J),".3f")))
.判断开始 (hal.小于(hal.取元素(Radius,J),17))
hal.dev_set_color("red")
hal.write_string(WindowHandle," (nok)")
.默认
hal.dev_set_color("forest green")
hal.write_string(WindowHandle,"  (ok)")
hal.dev_set_color("green")
.判断结束

hal.dev_display(ObjectSelected)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.disp_message(WindowHandle,"Inspect the radius of bonding balls on a die","window",12,12,"black","true")
hal.wait_seconds(3)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
k ＝ hal.加 (k, 1)
.判断循环尾 ()
hal.set_system("store_empty_region",StoreEmpty)
' 
' 
return()

.子程序 p_do_world_plane
.局部变量 Angle, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 C, 视觉元组
.局部变量 CalibDataID, 视觉元组
.局部变量 CaltabName, 视觉元组
.局部变量 CamParam, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ColumnRef, 视觉元组
.局部变量 Contours, 视觉对象
.局部变量 Cross, 视觉对象
.局部变量 Error, 视觉元组
.局部变量 HomMat2D, 视觉元组
.局部变量 HomMat3D, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageRectified, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImgNo, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 J, 视觉元组
.局部变量 Map, 视觉对象
.局部变量 Message, 视觉元组
.局部变量 Model, 视觉对象
.局部变量 ModelBorder, 视觉对象
.局部变量 ModelBorderTrans, 视觉对象
.局部变量 ModelID, 视觉元组
.局部变量 ModelImages, 视觉对象
.局部变量 ModelRegions, 视觉对象
.局部变量 ModelWorld, 视觉对象
.局部变量 Num, 视觉元组
.局部变量 NumImages, 视觉元组
.局部变量 PixelDist, 视觉元组
.局部变量 Pose, 视觉元组
.局部变量 PoseCalib, 视觉元组
.局部变量 R, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 RowRef, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 StartCamPar, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 X, 视觉元组
.局部变量 Xc, 视觉元组
.局部变量 Xs, 视觉元组
.局部变量 Y, 视觉元组
.局部变量 Yc, 视觉元组
.局部变量 Ys, 视觉元组
.局部变量 Z, 视觉元组
.局部变量 Zc, 视觉元组

' 
' This example program shows how to recognize planar objects using HALCON's
' shape-based matching if the camera is not mounted perpendicular to the plane
' in which the objects lie. Tho recognize the objects, the images are rectified, i.e.,
' the perspective distortions are removed from the images.  To do so, the camera
' is calibrated and the plane in which the objects lie is obtained from the external
' camera parameters of the image in which the calibration target lies on this plane
' Once this plane is known, the image of the model object can be rectified and
' hence the model can be generated in the world plane, i.e., without distortions.
' Similarly, the search images are also rectified, and hence the shape-based
' matching becomes invariant to perspective distortions.
' 
hal.dev_update_off()
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,481,645)
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
' Perform the camera calibration
hal.赋值(CaltabName,"caltab_30mm.descr")
hal.赋值(StartCamPar,hal.创建元组(0.008,0,0.0000073,0.0000073,323,241,646,482))
hal.create_calib_data("calibration_object",1,1,CalibDataID)
hal.set_calib_data_cam_param(CalibDataID,0,"area_scan_division",StartCamPar)
hal.set_calib_data_calib_object(CalibDataID,0,CaltabName)
hal.赋值(NumImages,15)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, NumImages))
hal.read_image(Image,hal.加("radius-gauges/calib-",hal.文本格式化(I,"02d")))
hal.dev_display(Image)
hal.赋值(Message,hal.加(hal.加(hal.加(hal.加("Find calibration plate in"+#换行符+"all calibration images (",I),"/"),NumImages),")"))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
'     Find the calibration plate
hal.find_calib_object(Image,CalibDataID,0,0,hal.减(I,1),hal.创建元组(),hal.创建元组())
hal.get_calib_data(CalibDataID,"camera",0,"init_params",StartCamPar)
hal.get_calib_data_observ_points(CalibDataID,0,0,hal.减(I,1),Row,Column,Index,Pose)
hal.get_calib_data_observ_contours(Contours,CalibDataID,"caltab",0,0,hal.减(I,1))
hal.gen_cross_contour_xld(Cross,Row,Column,6,0.785398)
hal.dev_set_color("green")
hal.dev_display(Contours)
hal.dev_set_color("yellow")
hal.dev_display(Cross)
hal.wait_seconds(0.1)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.calibrate_cameras(CalibDataID,Error)
hal.get_calib_data(CalibDataID,"camera",0,"params",CamParam)
hal.wait_seconds(3)
hal.read_image(Image,"radius-gauges/calib-01")
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Recognize metal parts in 3D","window",-1,-1,"black","true")
hal.disp_message(WindowHandle,"Image defining the reference plane","window",45,-1,"black","true")
hal.wait_seconds(2)
' The pose of the calibration target in the first image defines a plane that is
' parallel to the plane in which the objects lie.  This pose can be used to see how
' much the camera is rotated with respect to this plane.
hal.get_calib_data(CalibDataID,"calib_obj_pose",hal.创建元组(0,0),"pose",PoseCalib)
' The pose of the calibration target in the first image defines a plane that is offset
' from the plane in which the objects lie by the thickness of the calibration target.
' Therefore, we need to shift the origin of the pose in the z direction by the
' thickness. Note that the thickness of the calibration target used for this
' example is 0.63 mm. If you adapt this example program to your application, it
' is necessary to determine the thickness of your specific calibration target and to
' use this value instead. Furthermore, we need to shift the origin so that the top left corner
' of the image lies approximately in the top left corner of the rectified image.
hal.set_origin_pose(PoseCalib,-0.066,-0.048,0.00063,Pose)
' We also need to define the pixel spacing in the rectified image.  In this case,
' we set it to 0.2mm (i.e., 0.0002m).
hal.赋值(PixelDist,0.0002)
' We now can compute the mapping function to rectify the image because it does
' not change (the camera does not move with respect to the world plane).
hal.gen_image_to_world_plane_map(Map,CamParam,Pose,646,482,596,448,PixelDist,"bilinear")
' We also compute the transformation from the world coordinate system, i.e., the
' coordinate system of the plane, to the camera coordinate system.  This
' transformation is later used to visualize the recognized objects in the distorted
' (i.e., original, unrectified) images.
hal.pose_to_hom_mat3d(Pose,HomMat3D)
' Now that we are able to rectify the images, we can create the shape model.
hal.read_image(Image,"radius-gauges/radius-gauges-00")
hal.dev_display(Image)
' Display the pose of the world plane.
hal.disp_message(WindowHandle,"Recognize metal parts in 3D","window",-1,-1,"black","true")
hal.disp_message(WindowHandle,"Model image (generating shape model...)","window",45,-1,"black","true")
hal.赋值(Message,hal.创建元组("Rotation of the camera:",hal.加(hal.加("x axis: ",hal.文本格式化(hal.取元素(PoseCalib,3),"7.1f")),"°"),hal.加(hal.加("y axis: ",hal.文本格式化(hal.取元素(PoseCalib,4),"7.1f")),"°"),hal.加(hal.加("z axis: ",hal.文本格式化(hal.取元素(PoseCalib,5),"7.1f")),"°")))
hal.disp_message(WindowHandle,Message,"window",350,-1,"black","true")
' We rectify the model image and create the shape model in the rectified image.
hal.map_image(Image,Map,ImageRectified)
hal.gen_rectangle1(Rectangle,120,220,340,450)
hal.area_center(Rectangle,Area,RowRef,ColumnRef)
hal.reduce_domain(ImageRectified,Rectangle,ImageReduced)
hal.inspect_shape_model(ImageReduced,ModelImages,ModelRegions,1,30)
' For visualization purposes, we also create a contour that corresponds to the
' outer boundary of the object.  This is done because the model contains a hole,
' and hence consists of multiple contours.  This allows us to visualize the
' recognized models in the original images in a simplified manner.
hal.gen_contours_skeleton_xld(ModelRegions,Model,1,"filter")
hal.select_contours_xld(Model,ModelBorder,"length",200,1000,-0.5,0.5)
hal.create_shape_model(ImageReduced,5,0,hal.rad(360),"auto","none","use_polarity",30,5,ModelID)
' Now we are going to visualize the model in the original image.  To do so, we
' read out the coordinates of the model points.
hal.get_contour_xld(ModelBorder,Ys,Xs)
' Since we have rectified the image, the pixel coordinates correspond to 0.2mm
' increments.  Since the projection operator expects coordinates in meters, we
' need to multiply them by the pixel distance.
hal.赋值(X,hal.乘(Xs,PixelDist))
hal.赋值(Y,hal.乘(Ys,PixelDist))
hal.赋值(Z,hal.gen_tuple_const(hal.取元素总数(X),到小数(0.0)))
' We now must transform the model points into the camera coordinate system.
hal.affine_trans_point_3d(HomMat3D,X,Y,Z,Xc,Yc,Zc)
' Finally, we can project the points from the camera coordinate system to the
' image plane.
hal.project_3d_point(Xc,Yc,Zc,CamParam,R,C)
' We now create a contour from the projected points.
hal.gen_contour_polygon_xld(ModelWorld,R,C)
' For visualization purposes, we also will display an arrow from the reference
' point of the model.  The arrow is exactly 10mm long and oriented horizontally in
' the world coordinate system.  As with the model, the arrow will be displayed in
' the original image, where it will not be horizontal because of the perspective
' distortion.
hal.赋值(X,hal.创建元组(hal.乘(ColumnRef,PixelDist),hal.加(hal.乘(ColumnRef,PixelDist),hal.除(到小数(1.),100))))
hal.赋值(Y,hal.创建元组(hal.乘(RowRef,PixelDist),hal.乘(RowRef,PixelDist)))
hal.赋值(Z,hal.gen_tuple_const(hal.取元素总数(X),到小数(0.0)))
hal.affine_trans_point_3d(HomMat3D,X,Y,Z,Xc,Yc,Zc)
hal.project_3d_point(Xc,Yc,Zc,CamParam,R,C)
hal.dev_set_color("green")
hal.dev_display(ModelWorld)
hal.dev_set_color("orange")
hal.disp_arrow(WindowHandle,hal.取元素(R,0),hal.取元素(C,0),hal.取元素(R,1),hal.取元素(C,1),2)
' The final part of the program performs the object recognition.  Up to three
' objects will be visible in the images.  Note that these objects are not exactly
' identical.  The circular indentations and protrusions have different radii (5.5mm,
' 6mm, and 6.5mm).  Therefore, in addition to the occlusions of the objects, the
' shape-based matching must compensate for these (significant) variations in
' the objects' shape.  The model was actually created from the object with the
' 6mm radii.
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 3))
hal.read_image(Image,hal.加("radius-gauges/radius-gauges-",hal.文本格式化(J,"02d")))
hal.find_shape_model(ImageRectified,ModelID,0,hal.rad(360),0.5,0,0.5,"interpolation",0,0.9,Row,Column,Angle,Score)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.赋值(ImgNo,11)
hal.wait_seconds(3)
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 48))
hal.read_image(Image,hal.加("radius-gauges/radius-gauges-",hal.文本格式化(ImgNo,"02d")))
'     We will count the time to rectify the image and to find the objects.
hal.count_seconds(S1)
hal.map_image(Image,Map,ImageRectified)
hal.find_shape_model(ImageRectified,ModelID,0,hal.rad(360),0.5,0,0.5,"least_squares",0,0.8,Row,Column,Angle,Score)
hal.count_seconds(S2)
hal.dev_display(Image)
hal.赋值(Time,hal.减(S2,S1))
hal.赋值(Num,hal.取元素总数(Score))
hal.dev_set_color("white")
hal.disp_message(WindowHandle,hal.加(hal.加(hal.加(hal.文本格式化(Num,"1d")," objects found in "),hal.文本格式化(hal.乘(1000,Time),"4.1f"))," ms"),"window",-1,-1,"black","true")
'     We will now project the contours of the found instances of the model back to
'     the perspectively distorted image plane.  The following code is identical to
'     the code above that displays the model in the perspectively distorted image.
hal.赋值(Message,hal.创建元组())
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(Num,1)))
hal.赋值(Message,hal.创建元组(Message,hal.加(hal.加(hal.加(hal.加(hal.加(hal.加(hal.加(hal.加("Pose ",I),": ("),hal.文本格式化(hal.乘(hal.乘(hal.取元素(Column,I),PixelDist),1000),"3.2f")),", "),hal.文本格式化(hal.乘(hal.乘(hal.取元素(Row,I),PixelDist),1000),"3.2f")),")[mm], "),hal.文本格式化(hal.deg(hal.取元素(Angle,I)),"3.2f")),"°")))
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.disp_message(WindowHandle,Message,"window",380,-1,"black","true")
.判断开始 (hal.大于(Num,0))
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(Num,1)))
hal.vector_angle_to_rigid(RowRef,ColumnRef,0,hal.取元素(Row,I),hal.取元素(Column,I),hal.取元素(Angle,I),HomMat2D)
hal.affine_trans_contour_xld(ModelBorder,ModelBorderTrans,HomMat2D)
hal.get_contour_xld(ModelBorderTrans,Ys,Xs)
hal.赋值(X,hal.乘(Xs,PixelDist))
hal.赋值(Y,hal.乘(Ys,PixelDist))
hal.赋值(Z,hal.gen_tuple_const(hal.取元素总数(X),到小数(0.0)))
hal.affine_trans_point_3d(HomMat3D,X,Y,Z,Xc,Yc,Zc)
hal.project_3d_point(Xc,Yc,Zc,CamParam,R,C)
hal.gen_contour_polygon_xld(ModelWorld,R,C)
hal.赋值(X,hal.创建元组(hal.乘(hal.取元素(Column,I),PixelDist),hal.加(hal.乘(hal.取元素(Column,I),PixelDist),hal.除(hal.cos(hal.取元素(Angle,I)),100))))
hal.赋值(Y,hal.创建元组(hal.乘(hal.取元素(Row,I),PixelDist),hal.减(hal.乘(hal.取元素(Row,I),PixelDist),hal.除(hal.sin(hal.取元素(Angle,I)),100))))
hal.赋值(Z,hal.gen_tuple_const(hal.取元素总数(X),到小数(0.0)))
hal.affine_trans_point_3d(HomMat3D,X,Y,Z,Xc,Yc,Zc)
hal.project_3d_point(Xc,Yc,Zc,CamParam,R,C)
hal.dev_set_color("green")
hal.dev_display(ModelWorld)
hal.dev_set_color("orange")
hal.disp_arrow(WindowHandle,hal.取元素(R,0),hal.取元素(C,0),hal.取元素(R,1),hal.取元素(C,1),2)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
.判断结束

hal.赋值(ImgNo,hal.加(ImgNo,1))
.判断开始 (hal.大于(ImgNo,20))
hal.赋值(ImgNo,1)
.判断结束

.判断开始 (hal.小于(J,3))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.wait_seconds(2)
hal.clear_shape_model(ModelID)
hal.clear_calib_data(CalibDataID)
return()

.子程序 p_do_multiple_parts
.局部变量 Angle, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 Colors, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 ColumnsRef, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 HomMat2D, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImgNo, 视觉元组
.局部变量 IndexE, 视觉元组
.局部变量 IndexS, 视觉元组
.局部变量 J, 视觉元组
.局部变量 Model, 视觉元组
.局部变量 ModelContours, 视觉对象
.局部变量 ModelID, 视觉元组
.局部变量 ModelIDs, 视觉元组
.局部变量 ModelImages, 视觉对象
.局部变量 ModelRegions, 视觉对象
.局部变量 ModelSelected, 视觉对象
.局部变量 ModelTrans, 视觉对象
.局部变量 Models, 视觉对象
.局部变量 Num, 视觉元组
.局部变量 NumModel, 视觉元组
.局部变量 NumModels, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 RowsRef, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 Time, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' This example program shows how to use HALCON's shape-based matching
' to find multiple different models in one call to find_shape_models.  Note that this
' is one mode of operation that is frequently useful.  However, the number of
' applications that can be solved with this mechanism is much larger.  For
' another application where finding multiple models in one call is useful are
' applications where the same object can only occur in small angle ranges
' around a discrete set of angles, e.g., 0°, 90°, 180°, and 270°.  In these cases,
' it would be wasteful to train the model for the full 360° rotation range and to
' match the model in this range.  Instead, four models using the small angle
' ranges around the discrete set of angles should be generated from the same
' model image and used in the matching stage using four different angle ranges.
' 
hal.dev_update_off()
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,476,"black",WindowHandle)
hal.dev_set_part(0,0,481,645)
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
' These colors will be used to graphically discern the different models in the
' visualization code below.
hal.赋值(Colors,hal.创建元组("blue","orange","yellow"))
' The models will be generated from hard-coded rectangles given by the
' following coordinates:
hal.赋值(Row1,hal.创建元组(135,150,185))
hal.赋值(Column1,hal.创建元组(250,170,220))
hal.赋值(Row2,hal.创建元组(375,310,335))
hal.赋值(Column2,hal.创建元组(355,395,375))
' The object Models will hold a set of XLD contours that represent the different
' models.  They are used below to overlay the found models on the current
' image.  XLD contours are used because they can be transformed much faster
' than regions.  This creates a slight problem because in general multiple XLD
' contours will represent one model.  Therefore, the start and end indices of the
' different models will be stored in IndexS and IndexE, respectively.
hal.gen_empty_obj(Models)
hal.赋值(IndexS,hal.创建元组())
hal.赋值(IndexE,hal.创建元组())
' The variable ModelIDs holds the different models that are created below.
hal.赋值(ModelIDs,hal.创建元组())
' Likewise, RowsRef and ColumnsRef store the reference points of the different
' models.  They are necessary to transform the models to the found instances
' in the current image.
hal.赋值(RowsRef,hal.创建元组())
hal.赋值(ColumnsRef,hal.创建元组())
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 3))
hal.read_image(Image,hal.加("metal-parts/metal-part-model-",hal.文本格式化(J,"02d")))
hal.dev_display(Image)
'     
hal.disp_message(WindowHandle,"Find multiple different metal parts","window",12,12,"black","true")
hal.disp_message(WindowHandle,hal.加("Generating shape model ",hal.文本格式化(J,"d")),"window",40,12,"black","true")
hal.gen_rectangle1(Rectangle,hal.取元素(Row1,hal.减(J,1)),hal.取元素(Column1,hal.减(J,1)),hal.取元素(Row2,hal.减(J,1)),hal.取元素(Column2,hal.减(J,1)))
hal.area_center(Rectangle,Area,Row,Column)
hal.reduce_domain(Image,Rectangle,ImageReduced)
hal.inspect_shape_model(Image,ModelImages,ModelRegions,1,30)
'     Since the shape models contain a few extraneous edges, they will be
'     removed here to give a slightly nicer visualization.
hal.connection(ModelRegions,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",20,100000)
hal.union1(SelectedRegions,ModelRegions)
hal.gen_contours_skeleton_xld(ModelRegions,ModelContours,1,"filter")
hal.dev_set_color(hal.取元素(Colors,hal.减(J,1)))
hal.dev_display(ModelContours)
'     Count how many XLD contours there are in the current model and in the
'     already stored models.  This is necessary to compute IndexS and IndexE.
hal.count_obj(ModelContours,NumModel)
hal.count_obj(Models,NumModels)
hal.create_shape_model(ImageReduced,5,hal.rad(0),hal.rad(360),0,"pregeneration","use_polarity",30,10,ModelID)
hal.concat_obj(Models,ModelContours,Models)
hal.赋值(IndexS,hal.创建元组(IndexS,hal.加(NumModels,1)))
hal.赋值(IndexE,hal.创建元组(IndexE,hal.加(NumModels,NumModel)))
hal.赋值(ModelIDs,hal.创建元组(ModelIDs,ModelID))
hal.赋值(RowsRef,hal.创建元组(RowsRef,Row))
hal.赋值(ColumnsRef,hal.创建元组(ColumnsRef,Column))
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 3))
hal.read_image(Image,hal.加("metal-parts/metal-parts-",hal.文本格式化(I,"02d")))
hal.find_shape_models(Image,ModelIDs,hal.rad(0),hal.rad(360),0.6,0,0.5,"interpolation",0,0.6,Row,Column,Angle,Score,Model)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.dev_set_color("red")
hal.赋值(ImgNo,14)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 60))
hal.read_image(Image,hal.加("metal-parts/metal-parts-",hal.文本格式化(ImgNo,"02d")))
hal.count_seconds(S1)
hal.find_shape_models(Image,ModelIDs,hal.rad(0),hal.rad(360),0.6,0,0.5,"interpolation",0,0.6,Row,Column,Angle,Score,Model)
hal.count_seconds(S2)
hal.赋值(Time,hal.减(S2,S1))
hal.dev_display(Image)
hal.赋值(Num,hal.取元素总数(Score))
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(Num,1)))
'         Select the correct XLD contours from the Models object.
hal.copy_obj(Models,ModelSelected,hal.取元素(IndexS,hal.取元素(Model,J)),hal.加(hal.减(hal.取元素(IndexE,hal.取元素(Model,J)),hal.取元素(IndexS,hal.取元素(Model,J))),1))
'         Compute the transformation from the model object to the current instance.
hal.vector_angle_to_rigid(hal.取元素(RowsRef,hal.取元素(Model,J)),hal.取元素(ColumnsRef,hal.取元素(Model,J)),0,hal.取元素(Row,J),hal.取元素(Column,J),hal.取元素(Angle,J),HomMat2D)
hal.affine_trans_contour_xld(ModelSelected,ModelTrans,HomMat2D)
hal.dev_set_color(hal.取元素(Colors,hal.取元素(Model,J)))
hal.dev_display(ModelTrans)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.dev_set_color("yellow")
hal.set_tposition(WindowHandle,20,20)
.判断开始 (hal.等于(Num,1))
hal.disp_message(WindowHandle,hal.加(hal.加(hal.加(hal.文本格式化(Num,"1d")," object  found in "),hal.文本格式化(hal.乘(1000,Time),"4.2f"))," ms"),"window",12,12,"black","true")
.默认
hal.disp_message(WindowHandle,hal.加(hal.加(hal.加(hal.文本格式化(Num,"1d")," objects  found in "),hal.文本格式化(hal.乘(1000,Time),"4.2f"))," ms"),"window",12,12,"black","true")
.判断结束

hal.赋值(ImgNo,hal.加(ImgNo,1))
.判断开始 (hal.大于(ImgNo,15))
hal.赋值(ImgNo,1)
.判断结束

.判断开始 (hal.小于(I,3))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(1)
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(ModelIDs),1)))
hal.clear_shape_model(hal.取元素(ModelIDs,J))
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
return()

.子程序 p_do_print_check
.局部变量 Angle, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ColumnRef, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 HomMat2D, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImageTrans, 视觉对象
.局部变量 MeanImage, 视觉对象
.局部变量 Model, 视觉对象
.局部变量 ModelImages, 视觉对象
.局部变量 ModelRegions, 视觉对象
.局部变量 NumError, 视觉元组
.局部变量 Region, 视觉对象
.局部变量 RegionDiff, 视觉对象
.局部变量 RegionDifference, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionFillUp, 视觉对象
.局部变量 RegionROI, 视觉对象
.局部变量 RegionTrans, 视觉对象
.局部变量 RegionsError, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 RowRef, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 ShapeModelID, 视觉元组
.局部变量 VarImage, 视觉对象
.局部变量 VariationModelID, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' This example program shows how to use HALCON's variation model operators
' to perform a typical print quality inspection.  The program detects incorrect
' prints on the clips of pens.  In the first step, the variation model is constructed
' from images of correct prints.  Since the position of the objects can vary, the
' images must be transformed to a reference position (the position of the print
' in the first image in this example).  HALCON's shape-based matching is used
' to detect the position and angle of the print in the images.  The found position
' and angle are used to transform the images to the reference position.
' In the second part of the program, the prints of the correct clips and of several
' incorrect clips is checked and classified.
' 
hal.dev_update_off()
' 
hal.read_image(Image,"pen/pen-01")
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_display(Image)
hal.dev_set_line_width(3)
hal.dev_set_color("green")
hal.disp_message(WindowHandle,"Inspect the print on a pen clip","window",12,12,"black","true")
hal.wait_seconds(3)
' Note: the shape model will be constructed from a ROI that is computed
' automatically based on a simple image segmentation.
hal.threshold(Image,Region,100,255)
hal.fill_up(Region,RegionFillUp)
hal.difference(RegionFillUp,Region,RegionDifference)
hal.shape_trans(RegionDifference,RegionTrans,"convex")
hal.dilation_circle(RegionTrans,RegionDilation,8.5)
hal.reduce_domain(Image,RegionDilation,ImageReduced)
hal.inspect_shape_model(ImageReduced,ModelImages,ModelRegions,1,20)
hal.gen_contours_skeleton_xld(ModelRegions,Model,1,"filter")
hal.area_center(RegionDilation,Area,RowRef,ColumnRef)
hal.create_shape_model(ImageReduced,5,hal.rad(-10),hal.rad(20),0,"none","use_polarity",20,10,ShapeModelID)
hal.create_variation_model(Width,Height,"byte","standard",VariationModelID)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 15))
hal.read_image(Image,hal.加("pen/pen-",hal.文本格式化(I,"02d")))
hal.find_shape_model(Image,ShapeModelID,hal.rad(-30),hal.rad(60),0.5,1,0.5,"interpolation",0,0.9,Row,Column,Angle,Score)
.判断开始 (hal.等于(hal.取元素总数(Score),1))
hal.vector_angle_to_rigid(Row,Column,Angle,RowRef,ColumnRef,0,HomMat2D)
hal.affine_trans_image(Image,ImageTrans,HomMat2D,"constant","false")
hal.train_variation_model(ImageTrans,VariationModelID)
hal.dev_display(ImageTrans)
hal.dev_set_color("green")
hal.dev_display(Model)
hal.disp_message(WindowHandle,"Train a variation model","window",12,12,"black","true")
hal.wait_seconds(0.25)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.get_variation_model(MeanImage,VarImage,VariationModelID)
hal.prepare_variation_model(VariationModelID,20,3)
' Note: the checking of the print will be restricted to the region of the clip.
' Sometimes the print is also in an incorrect position of the clip.  This will lead
' to erroneous regions at the top or bottom border of the clip and hence can
' be detected easily.
hal.erosion_rectangle1(RegionFillUp,RegionROI,1,15)
hal.dev_display(MeanImage)
hal.disp_message(WindowHandle,"Reference image","window",12,12,"black","true")
hal.wait_seconds(3)
hal.dev_display(VarImage)
hal.disp_message(WindowHandle,"Variation image","window",12,12,"black","true")
hal.wait_seconds(3)
hal.dev_set_draw("margin")
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 30))
hal.read_image(Image,hal.加("pen/pen-",hal.文本格式化(I,"02d")))
hal.find_shape_model(Image,ShapeModelID,hal.rad(-10),hal.rad(20),0.5,1,0.5,"interpolation",0,0.9,Row,Column,Angle,Score)
.判断开始 (hal.等于(hal.取元素总数(Score),1))
hal.vector_angle_to_rigid(Row,Column,Angle,RowRef,ColumnRef,0,HomMat2D)
hal.affine_trans_image(Image,ImageTrans,HomMat2D,"constant","false")
hal.reduce_domain(ImageTrans,RegionROI,ImageReduced)
hal.compare_variation_model(ImageReduced,RegionDiff,VariationModelID)
hal.connection(RegionDiff,ConnectedRegions)
hal.select_shape(ConnectedRegions,RegionsError,"area","and",20,1000000)
hal.count_obj(RegionsError,NumError)
hal.dev_clear_window()
hal.dev_display(ImageTrans)
hal.dev_set_color("red")
hal.dev_display(RegionsError)
hal.set_tposition(WindowHandle,20,20)
.判断开始 (hal.等于(NumError,0))
hal.dev_set_color("green")
hal.write_string(WindowHandle,"Clip OK")
hal.wait_seconds(0.2)
.默认
hal.dev_set_color("red")
hal.write_string(WindowHandle,"Clip not OK")
hal.wait_seconds(0.5)
.判断结束

.判断结束

I ＝ hal.加 (I, 2)
.判断循环尾 ()
hal.clear_shape_model(ShapeModelID)
hal.clear_variation_model(VariationModelID)
hal.wait_seconds(1)
return()

.子程序 p_do_wood
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 ConnectedInters, 视觉对象
.局部变量 ConnectedRegions, 视觉对象
.局部变量 Dark, 视觉对象
.局部变量 DarkDilation, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 ImageMean, 视觉对象
.局部变量 ImageScaled, 视觉对象
.局部变量 Inters, 视觉对象
.局部变量 Line, 视觉对象
.局部变量 Max, 视觉元组
.局部变量 Min, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 Range, 视觉元组
.局部变量 RegionBright, 视觉对象
.局部变量 Regions, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WoodPiece1, 视觉对象

' Determine the age of a tree by counting its annual rings
' 
hal.dev_update_off()
hal.dev_close_window()
' 
hal.read_image(WoodPiece1,"woodring")
hal.get_image_size(WoodPiece1,Width,Height)
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.min_max_gray(WoodPiece1,WoodPiece1,2,Min,Max,Range)
hal.scale_image(WoodPiece1,ImageScaled,hal.除(255,hal.减(Max,Min)),hal.乘(hal.除(-255,hal.减(Max,Min)),Min))
hal.dev_display(ImageScaled)
hal.disp_message(WindowHandle,"Count annual rings","window",-1,-1,"black","true")
hal.wait_seconds(3)
' Segmentation of annual ring
hal.mean_image(WoodPiece1,ImageMean,9,9)
hal.dyn_threshold(WoodPiece1,ImageMean,Regions,到小数(5.0),"dark")
hal.threshold(WoodPiece1,Dark,0,90)
hal.dilation_rectangle1(Dark,DarkDilation,30,7)
hal.difference(Regions,DarkDilation,RegionBright)
' Eliminate tiny regions that are no annual rings
hal.connection(RegionBright,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",30,10000000)
' Define the start and end point of a line across the annual rings
' using the mouse. The number of intersections with annual rings
' is counted along this line
hal.赋值(Row1,290)
hal.赋值(Column1,6)
hal.赋值(Row2,69.5)
hal.赋值(Column2,1406.5)
hal.gen_region_line(Line,Row1,Column1,Row2,Column2)
hal.intersection(Line,SelectedRegions,Inters)
hal.connection(Inters,ConnectedInters)
hal.count_obj(ConnectedInters,Number)
hal.dev_set_color("green")
hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
hal.dev_display(Line)
hal.disp_message(WindowHandle,hal.加(hal.加("Age: ",Number)," years"),"window",100,160,"black","true")
hal.wait_seconds(4)
' 
' 
return()

.子程序 p_do_angio
.局部变量 Angio, 视觉对象
.局部变量 Angle, 视觉元组
.局部变量 Col, 视觉元组
.局部变量 ColL, 视觉元组
.局部变量 ColR, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 J, 视觉元组
.局部变量 Line, 视觉对象
.局部变量 Lines, 视觉对象
.局部变量 Number, 视觉元组
.局部变量 ProcessedTime, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 RowL, 视觉元组
.局部变量 RowR, 视觉元组
.局部变量 Seconds1, 视觉元组
.局部变量 Seconds2, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WidthL, 视觉元组
.局部变量 WidthR, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandle1, 视觉元组

' 
hal.dev_update_off()
' 
hal.read_image(Angio,"angio-part")
hal.get_image_size(Angio,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Angio)
hal.dev_open_window(hal.减(480,260),hal.减(640,260),256,256,"black",WindowHandle1)
hal.dev_set_window(WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_set_color("blue")
hal.lines_gauss(Angio,Lines,2.3,0,0.7,"dark","true","true","true")
hal.count_obj(Lines,Number)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, Number))
hal.disp_message(WindowHandle,"Measure Vessels in an Angiographic Image","window",-1,-1,"black","true")
hal.select_obj(Lines,Line,I)
hal.get_contour_xld(Line,Row,Col)
hal.get_contour_attrib_xld(Line,"angle",Angle)
hal.get_contour_attrib_xld(Line,"width_left",WidthL)
hal.get_contour_attrib_xld(Line,"width_right",WidthR)
'     To display the lines, the point at which the gray value drops to
'     25% of the contrast between the line and the background will be
'     displayed.  This point is given by sqrt(3/4) for the parabolic
'     line model.
hal.赋值(RowR,hal.加(Row,hal.乘(hal.乘(hal.cos(Angle),WidthR),hal.sqrt(0.75))))
hal.赋值(ColR,hal.加(Col,hal.乘(hal.乘(hal.sin(Angle),WidthR),hal.sqrt(0.75))))
hal.赋值(RowL,hal.减(Row,hal.乘(hal.乘(hal.cos(Angle),WidthL),hal.sqrt(0.75))))
hal.赋值(ColL,hal.减(Col,hal.乘(hal.乘(hal.sin(Angle),WidthL),hal.sqrt(0.75))))
hal.dev_set_color("red")
hal.dev_display(Line)
hal.dev_set_color("green")
hal.disp_polygon(WindowHandle,RowL,ColL)
hal.disp_polygon(WindowHandle,RowR,ColR)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, Number))
hal.select_obj(Lines,Line,I)
hal.get_contour_xld(Line,Row,Col)
.判断开始 (hal.且(hal.大于(hal.取元素总数(Row),100),hal.取反(hal.求模(I,2))))
hal.get_contour_attrib_xld(Line,"angle",Angle)
hal.get_contour_attrib_xld(Line,"width_left",WidthL)
hal.get_contour_attrib_xld(Line,"width_right",WidthR)
hal.赋值(RowR,hal.加(Row,hal.乘(hal.cos(Angle),WidthR)))
hal.赋值(ColR,hal.加(Col,hal.乘(hal.sin(Angle),WidthR)))
hal.赋值(RowL,hal.减(Row,hal.乘(hal.cos(Angle),WidthL)))
hal.赋值(ColL,hal.减(Col,hal.乘(hal.sin(Angle),WidthL)))
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(Row),1)))
hal.count_seconds(Seconds1)
hal.dev_set_window(WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_set_color("red")
hal.dev_display(Line)
hal.dev_set_color("yellow")
hal.disp_circle(WindowHandle,hal.取元素(Row,J),hal.取元素(Col,J),1.5)
hal.dev_set_window(WindowHandle1)
hal.dev_set_part(hal.round(hal.减(hal.取元素(Row,J),12)),hal.round(hal.减(hal.取元素(Col,J),12)),hal.round(hal.加(hal.取元素(Row,J),12)),hal.round(hal.加(hal.取元素(Col,J),12)))
hal.dev_display(Angio)
hal.dev_set_color("red")
hal.dev_display(Line)
hal.dev_set_color("green")
hal.disp_polygon(WindowHandle1,RowL,ColL)
hal.disp_polygon(WindowHandle1,RowR,ColR)
hal.dev_set_color("yellow")
hal.disp_circle(WindowHandle1,hal.取元素(Row,J),hal.取元素(Col,J),1.5)
hal.count_seconds(Seconds2)
.判断开始 (hal.等于(I,10))
hal.赋值(ProcessedTime,hal.减(Seconds2,Seconds1))
hal.wait_seconds(hal.求最大值(hal.创建元组(hal.减(0.04,ProcessedTime),0)))
.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.dev_set_window(WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.dev_set_line_width(3)
hal.dev_set_color("yellow")
hal.dev_display(Lines)
hal.dev_set_color("red")
hal.dev_set_line_width(1)
hal.dev_display(Lines)
hal.wait_seconds(3)
hal.dev_set_window(WindowHandle1)
hal.dev_close_window()
return()

.子程序 p_do_roads
.局部变量 Bright, 视觉对象
.局部变量 ClippedEdges, 视觉对象
.局部变量 ClippedRoadCenters, 视觉对象
.局部变量 EdgeRegion, 视觉对象
.局部变量 EdgeSkeleton, 视觉对象
.局部变量 ExtParallelRoadEdges, 视觉对象
.局部变量 HomMat2DIdentity, 视觉元组
.局部变量 HomMat2DScale, 视觉元组
.局部变量 HomMat2DTranslate, 视觉元组
.局部变量 ModParallelRoadEdges, 视觉对象
.局部变量 Mreut43, 视觉对象
.局部变量 Mreut43Bright, 视觉对象
.局部变量 Mreut43Height, 视觉元组
.局部变量 Mreut43Width, 视觉元组
.局部变量 ParallelRoadEdges, 视觉对象
.局部变量 Part, 视觉对象
.局部变量 PartAmp, 视觉对象
.局部变量 PartDir, 视觉对象
.局部变量 PartHeight, 视觉元组
.局部变量 PartWidth, 视觉元组
.局部变量 RoadCenterPolygons, 视觉对象
.局部变量 RoadCenters, 视觉对象
.局部变量 RoadEdgePolygons, 视觉对象
.局部变量 RoadEdges, 视觉对象
.局部变量 RoadSides, 视觉对象
.局部变量 ScaledRoadCenters, 视觉对象
.局部变量 TopCol, 视觉元组
.局部变量 TopRow, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
hal.dev_update_off()
' 
hal.赋值(PartWidth,512)
hal.赋值(PartHeight,512)
hal.赋值(TopRow,250)
hal.赋值(TopCol,600)
' 
hal.read_image(Part,"mreut_y")
hal.read_image(Mreut43,"mreut4_3")
hal.get_image_size(Mreut43,Mreut43Width,Mreut43Height)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,Mreut43Width,Mreut43Height,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Mreut43Height,1),hal.减(Mreut43Width,1))
hal.dev_display(Mreut43)
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.disp_message(WindowHandle,"Extract road centers from aerial image","window",12,12,"black","true")
hal.dev_set_line_width(3)
hal.wait_seconds(3)
hal.threshold(Mreut43,Bright,160,255)
hal.reduce_domain(Mreut43,Bright,Mreut43Bright)
hal.lines_gauss(Mreut43Bright,RoadCenters,1.2,5,14,"light","true","bar-shaped","true")
hal.hom_mat2d_identity(HomMat2DIdentity)
hal.hom_mat2d_scale(HomMat2DIdentity,8,8,0,0,HomMat2DScale)
hal.hom_mat2d_translate(HomMat2DScale,-hal.取元组小数(TopRow,),-hal.取元组小数(TopCol,),HomMat2DTranslate)
hal.affine_trans_contour_xld(RoadCenters,ScaledRoadCenters,HomMat2DTranslate)
hal.clip_contours_xld(ScaledRoadCenters,ClippedRoadCenters,0,0,PartWidth,PartHeight)
hal.gen_polygons_xld(ClippedRoadCenters,RoadCenterPolygons,"ramer",2)
hal.dev_set_colored(6)
hal.dev_display(RoadCenters)
hal.disp_message(WindowHandle,"Extract road centers from aerial image","window",12,12,"black","true")
hal.wait_seconds(3)
hal.dev_set_part(0,0,hal.减(PartHeight,1),hal.减(PartWidth,1))
hal.dev_display(Part)
hal.disp_message(WindowHandle,"Extract road sides from aerial image","window",12,12,"black","true")
hal.edges_image(Part,PartAmp,PartDir,"mderiche2",0.3,"nms",20,40)
hal.threshold(PartAmp,EdgeRegion,1,255)
hal.clip_region(EdgeRegion,ClippedEdges,2,2,hal.减(PartWidth,3),hal.减(PartHeight,3))
hal.skeleton(ClippedEdges,EdgeSkeleton)
hal.gen_contours_skeleton_xld(EdgeSkeleton,RoadEdges,1,"filter")
hal.gen_polygons_xld(RoadEdges,RoadEdgePolygons,"ramer",2)
hal.gen_parallels_xld(RoadEdgePolygons,ParallelRoadEdges,10,30,0.15,"true")
hal.mod_parallels_xld(ParallelRoadEdges,Part,ModParallelRoadEdges,ExtParallelRoadEdges,0.3,160,220,10)
hal.combine_roads_xld(RoadEdgePolygons,ModParallelRoadEdges,ExtParallelRoadEdges,RoadCenterPolygons,RoadSides,hal.rad(40),hal.rad(20),40,40)
hal.dev_set_color("green")
hal.dev_display(RoadSides)
hal.dev_set_line_width(1)
hal.disp_message(WindowHandle,"Extract road sides from aerial image","window",12,12,"black","true")
hal.wait_seconds(3)
' 
' 
return()

.子程序 p_do_xing
.局部变量 ActualImage, 视觉对象
.局部变量 BackGround, 视觉对象
.局部变量 BackGroundZoom, 视觉对象
.局部变量 BgEstiHandle, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 FinalConnected, 视觉对象
.局部变量 ForegroundRegion, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageZoomed, 视觉对象
.局部变量 Rects, 视觉对象
.局部变量 RegionClipped, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionIntersection, 视觉对象
.局部变量 RegionTrans, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 RegionUnionFinal, 视觉对象
.局部变量 RegionZoom, 视觉对象
.局部变量 SelectedRegions, 视觉对象
.局部变量 SelectedRegionsGray, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 XingRegion, 视觉对象

' 
hal.dev_update_off()
' 
hal.read_image(Image,"xing/init")
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
' 
hal.read_region(XingRegion,"xing/xing_region")
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_set_draw("margin")
hal.dev_set_colored(12)
hal.dev_set_line_width(3)
hal.dev_display(Image)
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.disp_message(WindowHandle,"Monitor cars and people on a crossing","window",12,12,"black","true")
hal.wait_seconds(3)
hal.zoom_image_factor(Image,ImageZoomed,0.5,0.5,"constant")
hal.create_bg_esti(ImageZoomed,0.7,0.7,"fixed",0.001,0.03,"on",到小数(8.0),10,3.25,15,BgEstiHandle)
hal.赋值 (I, 120)
.判断循环首 (hal.小于等于 (I, 420))
hal.read_image(ActualImage,hal.加("xing/xing",hal.文本格式化(I,"03")))
hal.zoom_image_factor(ActualImage,ImageZoomed,0.5,0.5,"constant")
hal.run_bg_esti(ImageZoomed,ForegroundRegion,BgEstiHandle)
hal.zoom_region(ForegroundRegion,RegionZoom,2,2)
hal.intersection(RegionZoom,XingRegion,RegionIntersection)
hal.connection(RegionIntersection,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",20,99999)
hal.shape_trans(SelectedRegions,RegionTrans,"convex")
hal.union1(RegionTrans,RegionUnion)
hal.connection(RegionUnion,FinalConnected)
hal.select_gray(FinalConnected,ActualImage,SelectedRegionsGray,"deviation","and",25,1000)
hal.union1(SelectedRegionsGray,RegionUnionFinal)
hal.dilation_rectangle1(RegionUnionFinal,RegionDilation,5,5)
hal.complement(RegionDilation,BackGround)
hal.clip_region(BackGround,RegionClipped,0,0,hal.减(Height,1),hal.减(Width,1))
hal.zoom_region(RegionClipped,BackGroundZoom,0.5,0.5)
hal.update_bg_esti(ImageZoomed,BackGroundZoom,BgEstiHandle)
hal.shape_trans(SelectedRegionsGray,Rects,"rectangle1")
'     
hal.set_system("flush_graphic","false")
hal.dev_display(ActualImage)
hal.dev_set_color("orange")
hal.dev_display(Rects)
hal.disp_message(WindowHandle,"Monitor cars and people on a crossing","window",12,12,"black","true")
hal.set_system("flush_graphic","true")
hal.set_tposition(WindowHandle,-10,-10)
hal.write_string(WindowHandle,"")
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.close_bg_esti(BgEstiHandle)
hal.wait_seconds(2)
return()

.子程序 p_set_font
.参数 WindowHandle, tuple

hal.set_display_font(WindowHandle,16,"mono","true","false")
return()

.子程序 p_do_mosaicking
.局部变量 Alpha, 视觉元组
.局部变量 CamParOut, 视觉元组
.局部变量 CamParam, 视觉元组
.局部变量 ColF, 视觉元组
.局部变量 ColFAll, 视觉元组
.局部变量 ColMove, 视觉元组
.局部变量 ColT, 视觉元组
.局部变量 ColTAll, 视觉元组
.局部变量 ColTolerance, 视觉元组
.局部变量 Cols, 视觉元组
.局部变量 Cols1, 视觉元组
.局部变量 Cols2, 视觉元组
.局部变量 DistanceThreshold, 视觉元组
.局部变量 Error, 视觉元组
.局部变量 F, 视觉元组
.局部变量 FShiftC, 视觉元组
.局部变量 FShiftR, 视觉元组
.局部变量 From, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageBlank, 视觉对象
.局部变量 ImageBorder, 视觉对象
.局部变量 ImageF, 视觉对象
.局部变量 ImageT, 视觉对象
.局部变量 Images, 视觉对象
.局部变量 ImagesBorder, 视觉对象
.局部变量 ImgName, 视觉元组
.局部变量 ImgPath, 视觉元组
.局部变量 J, 视觉元组
.局部变量 K, 视觉元组
.局部变量 MaskSize, 视觉元组
.局部变量 Match, 视觉对象
.局部变量 MatchThreshold, 视觉元组
.局部变量 Matches, 视觉对象
.局部变量 MosaicImage, 视觉对象
.局部变量 MosaicImageBorder, 视觉对象
.局部变量 MosaicMatrices2D, 视觉元组
.局部变量 Num, 视觉元组
.局部变量 NumCorrespondences, 视觉元组
.局部变量 PartCenterCol, 视觉元组
.局部变量 PartCenterRow, 视觉元组
.局部变量 PartHeight, 视觉元组
.局部变量 PartWidth, 视觉元组
.局部变量 Points1, 视觉元组
.局部变量 Points2, 视觉元组
.局部变量 PointsF, 视觉对象
.局部变量 PointsT, 视觉对象
.局部变量 ProjMatrices, 视觉元组
.局部变量 ProjMatrix, 视觉元组
.局部变量 RandSeed, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Rotation, 视觉元组
.局部变量 RowF, 视觉元组
.局部变量 RowFAll, 视觉元组
.局部变量 RowMove, 视觉元组
.局部变量 RowT, 视觉元组
.局部变量 RowTAll, 视觉元组
.局部变量 RowTolerance, 视觉元组
.局部变量 Rows, 视觉元组
.局部变量 Rows1, 视觉元组
.局部变量 Rows2, 视觉元组
.局部变量 Seams, 视觉对象
.局部变量 SelectedImages, 视觉元组
.局部变量 SigmaGrad, 视觉元组
.局部变量 SigmaSmooth, 视觉元组
.局部变量 StackingOrder, 视觉元组
.局部变量 StartImage, 视觉元组
.局部变量 T, 视觉元组
.局部变量 TShiftC, 视觉元组
.局部变量 TShiftR, 视觉元组
.局部变量 Threshold, 视觉元组
.局部变量 TiledImage, 视觉对象
.局部变量 To, 视觉元组
.局部变量 TransMat2D, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle1, 视觉元组
.局部变量 WindowHandle2, 视觉元组

' This example program shows how several images can be combined
' into a large mosaic image.  The program shows how to use
' proj_match_points_ransac, bundle_adjust_mosaic, and
' gen_bundle_adjusted_mosaic to achieve this.
' 
' Set image path and name
hal.赋值(ImgPath,"3d_machine_vision/mosaic/")
hal.赋值(ImgName,"bga_r_")
hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle1)
hal.dev_set_line_width(1)
hal.dev_set_color("green")
p_set_font(hal.克隆元组(WindowHandle1))
' The internal camera parameters of the used camera (necessary only, if the
' radial distortions are to be eliminated)
hal.赋值(CamParam,hal.创建元组(0.0121693,-2675.63,7.40046e-006,7.4e-006,290.491,258.887,640,480))
hal.change_radial_distortion_cam_par("adaptive",CamParam,0,CamParOut)
' Read in the images and show them one-by-one.
hal.gen_empty_obj(Images)
hal.赋值(SelectedImages,hal.创建元组(1,2,3,6,7,8))
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 6))
hal.赋值(I,hal.取元素(SelectedImages,hal.减(J,1)))
hal.read_image(Image,hal.加(hal.加(ImgPath,ImgName),hal.文本格式化(I,"02")))
hal.get_image_size(Image,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.change_radial_distortion_image(Image,Image,Image,CamParam,CamParOut)
hal.concat_obj(Images,Image,Images)
hal.dev_display(Image)
hal.disp_message(WindowHandle1,"Create mosaic from 6 images","window",-1,-1,"black","true")
hal.disp_message(WindowHandle1,hal.加("Image ",hal.文本格式化(J,"d")),"window",40,-1,"black","true")
hal.wait_seconds(0.7)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
' To show the point matches that are used to compute the projective
' transformation between the images, we will show all images in a large
' tiled image with some space between the images so that the extents
' of the images are easily visible.
hal.dev_set_window_extents(-1,-1,hal.除(1960,3.0625),hal.除(980,3.0625))
hal.dev_set_part(0,0,979,1959)
hal.tile_images_offset(Images,TiledImage,hal.创建元组(0,0,0,500,500,500),hal.创建元组(0,660,1320,0,660,1320),hal.创建元组(-1,-1,-1,-1,-1,-1),hal.创建元组(-1,-1,-1,-1,-1,-1),hal.创建元组(-1,-1,-1,-1,-1,-1),hal.创建元组(-1,-1,-1,-1,-1,-1),1960,980)
hal.dev_clear_window()
hal.dev_display(TiledImage)
hal.dev_set_color("green")
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 6))
.判断开始 (hal.小于(I,4))
hal.gen_rectangle1(Rectangle,0,hal.乘(hal.减(I,1),660),480,hal.减(hal.乘(I,660),20))
hal.dev_display(Rectangle)
.默认
hal.gen_rectangle1(Rectangle,500,hal.乘(hal.减(I,4),660),980,hal.减(hal.乘(hal.减(I,3),660),20))
hal.dev_display(Rectangle)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.disp_message(WindowHandle1,"All 6 images","window",-1,-1,"black","true")
hal.dev_set_line_width(1)
hal.dev_set_draw("fill")
hal.wait_seconds(3)
' Now we compute point matches between pairs of images and with this
' the projective transformation between the image pairs.
hal.dev_clear_window()
hal.dev_display(TiledImage)
hal.disp_message(WindowHandle1,"Point matches used for bundle adjustment","window",-1,-1,"black","true")
hal.赋值(From,hal.创建元组(1,1,1,4,2,2,2,2,5,3,3))
hal.赋值(To,hal.创建元组(4,5,2,5,4,5,6,3,6,5,6))
hal.赋值(Num,hal.取元素总数(From))
' We need a variable to accumulate the projective transformation matrices,
' the coordinates of the matched points, and the number of matched
' points for each image pair.
hal.赋值(ProjMatrices,hal.创建元组())
hal.赋值(Rows1,hal.创建元组())
hal.赋值(Cols1,hal.创建元组())
hal.赋值(Rows2,hal.创建元组())
hal.赋值(Cols2,hal.创建元组())
hal.赋值(NumCorrespondences,hal.创建元组())
' Now we can determine the transformations between the image pairs.
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(Num,1)))
hal.赋值(F,hal.取元素(From,J))
hal.赋值(T,hal.取元素(To,J))
hal.select_obj(Images,ImageF,F)
hal.select_obj(Images,ImageT,T)
'     Extract the points in both images.
hal.赋值(SigmaGrad,1)
hal.赋值(SigmaSmooth,3)
hal.赋值(Alpha,0.04)
hal.赋值(Threshold,0)
hal.points_harris(ImageF,SigmaGrad,SigmaSmooth,Alpha,Threshold,RowFAll,ColFAll)
hal.points_harris(ImageT,SigmaGrad,SigmaSmooth,Alpha,Threshold,RowTAll,ColTAll)
'     Define initial values for the position of the search window
.判断开始 (hal.大于(F,3))
hal.赋值(FShiftR,500)
hal.赋值(FShiftC,hal.乘(hal.减(F,4),660))
.默认
hal.赋值(FShiftR,0)
hal.赋值(FShiftC,hal.乘(hal.减(F,1),660))
.判断结束

.判断开始 (hal.大于(T,3))
hal.赋值(TShiftR,500)
hal.赋值(TShiftC,hal.乘(hal.减(T,4),660))
.默认
hal.赋值(TShiftR,0)
hal.赋值(TShiftC,hal.乘(hal.减(T,1),660))
.判断结束

hal.赋值(RowMove,hal.除(hal.减(FShiftR,TShiftR),2.7))
hal.赋值(ColMove,hal.除(hal.减(FShiftC,TShiftC),2))
'     Perform the matching
hal.赋值(MaskSize,21)
hal.赋值(RowTolerance,20)
hal.赋值(ColTolerance,20)
hal.赋值(Rotation,0)
hal.赋值(MatchThreshold,50)
hal.赋值(DistanceThreshold,0.25)
hal.赋值(RandSeed,4364537)
hal.proj_match_points_ransac(ImageF,ImageT,RowFAll,ColFAll,RowTAll,ColTAll,"sad",MaskSize,RowMove,ColMove,RowTolerance,ColTolerance,Rotation,MatchThreshold,"gold_standard",DistanceThreshold,RandSeed,ProjMatrix,Points1,Points2)
'     Accumulate the transformation matrices
hal.赋值(ProjMatrices,hal.创建元组(ProjMatrices,ProjMatrix))
'     and the matched points.
hal.赋值(Rows1,hal.创建元组(Rows1,hal.subset(RowFAll,Points1)))
hal.赋值(Cols1,hal.创建元组(Cols1,hal.subset(ColFAll,Points1)))
hal.赋值(Rows2,hal.创建元组(Rows2,hal.subset(RowTAll,Points2)))
hal.赋值(Cols2,hal.创建元组(Cols2,hal.subset(ColTAll,Points2)))
hal.赋值(NumCorrespondences,hal.创建元组(NumCorrespondences,hal.取元素总数(Points1)))
'     Generate crosses that represent the extracted points in the tiled image.
'     Note that we have to take the row offsets of the images in the tiled image
'     into account.
hal.gen_cross_contour_xld(PointsF,hal.加(RowFAll,FShiftR),hal.加(ColFAll,FShiftC),6,hal.rad(45))
hal.gen_cross_contour_xld(PointsT,hal.加(RowTAll,TShiftR),hal.加(ColTAll,TShiftC),6,hal.rad(45))
'     Generate a representation of the matched point pairs as lines.  We create
'     XLD contours from the lines so that we can zoom into the graphics window
'     to take a closer look at the matches.
hal.赋值(RowF,hal.加(hal.subset(RowFAll,Points1),FShiftR))
hal.赋值(ColF,hal.加(hal.subset(ColFAll,Points1),FShiftC))
hal.赋值(RowT,hal.加(hal.subset(RowTAll,Points2),TShiftR))
hal.赋值(ColT,hal.加(hal.subset(ColTAll,Points2),TShiftC))
hal.gen_empty_obj(Matches)
hal.赋值 (K, 0)
.判断循环首 (hal.小于等于 (K, hal.减(hal.取元素总数(RowF),1)))
hal.gen_contour_polygon_xld(Match,hal.创建元组(hal.取元素(RowF,K),hal.取元素(RowT,K)),hal.创建元组(hal.取元素(ColF,K),hal.取元素(ColT,K)))
hal.concat_obj(Matches,Match,Matches)
K ＝ hal.加 (K, 1)
.判断循环尾 ()
'     Now display the extracted data.
hal.dev_set_color("blue")
hal.dev_display(Matches)
hal.dev_set_color("green")
hal.dev_display(PointsF)
hal.dev_display(PointsT)
hal.disp_message(WindowHandle1,"Point matches used for bundle adjustment","window",-1,-1,"black","true")
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.wait_seconds(3)
' Set the stacking order
hal.赋值(StartImage,2)
hal.赋值(StackingOrder,hal.创建元组(4,5,6,1,2,3))
' Finally, we can generate the bundle adjusted mosaic image from the projective transformations.
hal.bundle_adjust_mosaic(6,StartImage,From,To,ProjMatrices,Rows1,Cols1,Rows2,Cols2,NumCorrespondences,"projective",MosaicMatrices2D,Rows,Cols,Error)
hal.gen_bundle_adjusted_mosaic(Images,MosaicImage,MosaicMatrices2D,StackingOrder,"false",TransMat2D)
hal.get_image_size(MosaicImage,Width,Height)
hal.dev_set_window_extents(-1,-1,640,hal.除(hal.乘(Height,到小数(640.)),Width))
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_clear_window()
hal.dev_display(MosaicImage)
hal.disp_message(WindowHandle1,"Image mosaic","window",-1,-1,"black","true")
hal.wait_seconds(4)
' To investigate the seam between two images, we first display the borders
' of the individual images.
' This can be done most easily by creating an image that contains the border
' of the images, generating a mosaic from it, and segmenting the resulting
' mosaic image.
hal.get_image_size(Image,Width,Height)
hal.gen_image_const(ImageBlank,"byte",Width,Height)
hal.gen_rectangle1(Rectangle,0,0,hal.减(Height,1),hal.减(Width,1))
hal.paint_region(Rectangle,ImageBlank,ImageBorder,255,"margin")
hal.gen_empty_obj(ImagesBorder)
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 6))
hal.concat_obj(ImagesBorder,ImageBorder,ImagesBorder)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.gen_bundle_adjusted_mosaic(ImagesBorder,MosaicImageBorder,MosaicMatrices2D,StackingOrder,"false",TransMat2D)
hal.threshold(MosaicImageBorder,Seams,128,255)
hal.dev_clear_window()
hal.dev_display(MosaicImage)
hal.set_tposition(WindowHandle1,20,10)
hal.dev_set_color("green")
hal.dev_display(Seams)
hal.disp_message(WindowHandle1,"Seams between the images","window",-1,-1,"black","true")
hal.dev_set_color("blue")
' Now, open a zoom window, showing the area around
' the seam between images 2,3,5,6.
hal.get_image_size(MosaicImage,Width,Height)
hal.赋值(PartHeight,85)
hal.赋值(PartWidth,320)
hal.赋值(PartCenterRow,486)
hal.赋值(PartCenterCol,329)
hal.dev_open_window(hal.加(hal.除(hal.乘(Height,到小数(640.)),Width),66),0,hal.乘(PartWidth,2),hal.乘(PartHeight,2),"black",WindowHandle2)
p_set_font(hal.克隆元组(WindowHandle2))
hal.dev_set_part(hal.加(hal.减(PartCenterRow,hal.除(PartHeight,2)),1),hal.加(hal.减(PartCenterCol,hal.除(PartWidth,2)),1),hal.加(PartCenterRow,hal.除(PartHeight,2)),hal.加(PartCenterCol,hal.除(PartWidth,2)))
hal.dev_display(MosaicImage)
hal.dev_set_color("green")
hal.dev_display(Seams)
hal.disp_message(WindowHandle2,"Close-up view","window",-1,-1,"black","true")
hal.dev_set_window(WindowHandle1)
hal.get_image_size(MosaicImage,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_set_line_width(3)
'* dev_display (MosaicImage)
hal.dev_set_draw("margin")
hal.dev_set_color("blue")
hal.disp_rectangle1(WindowHandle1,hal.加(hal.减(PartCenterRow,hal.除(PartHeight,2)),1),hal.加(hal.减(PartCenterCol,hal.除(PartWidth,2)),1),hal.加(PartCenterRow,hal.除(PartHeight,2)),hal.加(PartCenterCol,hal.除(PartWidth,2)))
hal.wait_seconds(6)
hal.dev_set_line_width(1)
hal.dev_set_window(WindowHandle2)
hal.dev_close_window()
return()

.子程序 p_do_grid_rectification
.局部变量 Col, 视觉元组
.局部变量 ConnectingLines, 视觉对象
.局部变量 GridRegion, 视觉对象
.局部变量 GridSpacing, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageCan, 视觉对象
.局部变量 ImageCanMapped, 视觉对象
.局部变量 ImageHeight, 视觉元组
.局部变量 ImageMapped, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImageWidth, 视觉元组
.局部变量 Map, 视觉对象
.局部变量 MaxDist, 视觉元组
.局部变量 Meshes, 视觉对象
.局部变量 MinContrast, 视觉元组
.局部变量 NumSquares, 视觉元组
.局部变量 Radius, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SaddlePoints, 视觉对象
.局部变量 SigmaConnectGridPoints, 视觉元组
.局部变量 SigmaSaddlePoints, 视觉元组
.局部变量 Threshold, 视觉元组
.局部变量 WidthOfGrid, 视觉元组
.局部变量 WindowID1, 视觉元组
.局部变量 WindowID2, 视觉元组

' This example illustrates how to use the operators for the grid-rectification.
' 
' The following command creates a postscript file
' that contains the rectification grid. This grid must be
' printed. Then it must be mounted on the object surface.
hal.赋值(WidthOfGrid,0.17)
hal.赋值(NumSquares,17)
' 
' Read the image of the object wrapped by the rectification grid
' and reopen the window with an appropriate size.
hal.read_image(ImageCan,"can")
hal.get_image_size(ImageCan,ImageWidth,ImageHeight)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowID1)
hal.dev_set_part(0,0,hal.减(ImageHeight,1),hal.减(ImageWidth,1))
p_set_font(hal.克隆元组(WindowID1))
hal.dev_display(ImageCan)
hal.disp_message(WindowID1,"Rectify the surface of a can","window",12,12,"black","true")
hal.wait_seconds(3)
' 
' Part 1: Determination of the image map
' The surface to be rectified is wrapped by a checkered pattern, which
' is used to determine the mapping between the distorted image and
' the rectified image. Note the orientation of the two circular marks. When
' in gen_grid_rectification_map() the parameter Rotation is 'auto', the rectified
' image is rotated such that the black mark is left of the white mark.
' 
hal.read_image(Image,"can_with_grid")
hal.dev_display(Image)
hal.disp_message(WindowID1,"Apply rectification grid","window",12,12,"black","true")
hal.wait_seconds(2)
' 
' Determination of the region that contains the rectification grid.
hal.赋值(MinContrast,25)
hal.赋值(Radius,10)
hal.find_rectification_grid(Image,GridRegion,MinContrast,Radius)
hal.reduce_domain(Image,GridRegion,ImageReduced)
' 
' Determination of the grid points.
hal.赋值(SigmaSaddlePoints,1.5)
hal.赋值(Threshold,5)
hal.saddle_points_sub_pix(ImageReduced,"facet",SigmaSaddlePoints,Threshold,Row,Col)
hal.gen_cross_contour_xld(SaddlePoints,Row,Col,6,0.785398)
' 
' Determination of the image map.
hal.赋值(SigmaConnectGridPoints,0.9)
hal.赋值(MaxDist,到小数(5.0))
hal.赋值(GridSpacing,20)
hal.connect_grid_points(ImageReduced,ConnectingLines,Row,Col,SigmaConnectGridPoints,MaxDist)
hal.gen_grid_rectification_map(ImageReduced,ConnectingLines,Map,Meshes,GridSpacing,0,Row,Col,"bilinear")
hal.map_image(ImageReduced,Map,ImageMapped)
' 
p_grid_visualization_of_intermediate_results(hal.克隆对象(Image),hal.克隆对象(ConnectingLines),hal.克隆对象(Meshes),hal.克隆对象(Map),hal.克隆对象(ImageMapped),hal.克隆对象(SaddlePoints),hal.克隆元组(WindowID1),hal.克隆元组(ImageWidth),WindowID2)
' 
' Part 2: Application of the image map
' The original surface (without the checkered pattern) is rectified
' using the previously calculated image map.
' 
' Read in the image to be rectified.
hal.disp_message(WindowID1,"Original image","window",12,12,"black","true")
' 
' Rectification of the image using the previously calculated image map.
hal.map_image(ImageCan,Map,ImageCanMapped)
' 
p_grid_visualization_of_results(hal.克隆对象(ImageCan),hal.克隆对象(ImageCanMapped),hal.克隆元组(WindowID1),hal.克隆元组(WindowID2))
' 
hal.wait_seconds(3)
' Try to read the barcodes
p_grid_read_and_display_1d_bar_code(hal.克隆对象(ImageCanMapped),hal.创建元组(hal.创建元组()),hal.克隆元组(WindowID2))
hal.wait_seconds(4)
hal.dev_set_window(WindowID2)
hal.dev_close_window()
return()

.子程序 p_grid_visualization_of_intermediate_results
.参数 Image, obj
.参数 ConnectingLines, obj
.参数 Meshes, obj
.参数 Map, obj
.参数 ImageMapped, obj
.参数 SaddlePoints, obj
.参数 WindowID1, tuple
.参数 ImageWidth, tuple
.参数 WindowID2, tuple, 参考
.局部变量 Height, 视觉元组
.局部变量 MapHeight, 视觉元组
.局部变量 MapWidth, 视觉元组
.局部变量 Width, 视觉元组

hal.dev_set_window(WindowID1)
hal.dev_display(Image)
hal.dev_set_color("green")
hal.dev_display(Meshes)
hal.disp_message(WindowID1,"Meshes used for rectification","window",12,12,"black","true")
hal.wait_seconds(2)
hal.dev_close_window()
hal.dev_open_window(0,0,320,240,"black",WindowID1)
hal.get_image_size(Image,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowID1))
hal.dev_display(Image)
hal.dev_set_color("green")
hal.dev_display(Meshes)
hal.disp_message(WindowID1,"Original grid","window",12,12,"black","true")
hal.get_image_size(Map,MapWidth,MapHeight)
hal.dev_open_window(0,334,305,hal.除(hal.乘(MapHeight,到小数(305.)),MapWidth),"black",WindowID2)
hal.dev_set_part(0,0,hal.减(MapHeight,1),hal.减(MapWidth,1))
p_set_font(hal.克隆元组(WindowID2))
hal.dev_display(ImageMapped)
hal.disp_message(WindowID2,"Rectified grid","window",12,12,"black","true")
hal.wait_seconds(3)
return()

.子程序 p_grid_visualization_of_results
.参数 Image, obj
.参数 ImageMapped, obj
.参数 WindowID1, tuple
.参数 WindowID2, tuple
.局部变量 Height, 视觉元组
.局部变量 Width, 视觉元组

hal.dev_set_window(WindowID1)
hal.get_image_size(Image,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Image)
hal.disp_message(WindowID1,"Original image","window",12,12,"black","true")
hal.dev_set_window(WindowID2)
hal.get_image_size(ImageMapped,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(ImageMapped)
hal.disp_message(WindowID2,"Rectified image","window",12,12,"black","true")
return()

.子程序 p_do_2dbarcode
.局部变量 ImageAztec, 视觉对象
.局部变量 ImageAztecPart, 视觉对象
.局部变量 ImageECC200, 视觉对象
.局部变量 ImageECC200Part, 视觉对象
.局部变量 ImageMicroQR, 视觉对象
.局部变量 ImageMicroQRPart, 视觉对象
.局部变量 ImagePDF417, 视觉对象
.局部变量 ImagePDF417Parts, 视觉对象
.局部变量 ImageQRCode, 视觉对象
.局部变量 ImageQRCodePart, 视觉对象
.局部变量 Images, 视觉对象
.局部变量 TiledImage, 视觉对象
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandle1, 视觉元组

hal.read_image(ImageECC200,"datacode/ecc200/ecc200_disturbed_005")
hal.crop_rectangle1(ImageECC200,ImageECC200Part,110,30,hal.加(110,284),hal.加(30,284))
hal.read_image(ImageQRCode,"datacode/qrcode/qr_workpiece_05")
hal.crop_rectangle1(ImageQRCode,ImageQRCodePart,110,60,hal.加(110,284),hal.加(60,284))
hal.read_image(ImagePDF417,"datacode/pdf417/pdf417_misc_06")
hal.crop_rectangle1(ImagePDF417,ImagePDF417Parts,hal.创建元组(190,190),hal.创建元组(60,hal.加(60,285)),hal.创建元组(hal.加(190,284),hal.加(190,284)),hal.创建元组(hal.加(60,284),hal.加(hal.加(60,285),284)))
hal.read_image(ImageMicroQR,"datacode/micro_qr/micro_qr_cell_phone_02")
hal.crop_rectangle1(ImageMicroQR,ImageMicroQRPart,110,160,hal.加(110,284),hal.加(160,284))
hal.read_image(ImageAztec,"datacode/aztec/aztec_ticket_04")
hal.crop_rectangle1(ImageAztec,ImageAztecPart,170,130,hal.加(170,284),hal.加(130,284))
hal.concat_obj(ImageQRCodePart,ImageECC200Part,Images)
hal.concat_obj(Images,ImageAztecPart,Images)
hal.concat_obj(Images,ImageMicroQRPart,Images)
hal.concat_obj(Images,ImagePDF417Parts,Images)
hal.tile_images(Images,TiledImage,3,"horizontal")
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,50,"black",WindowHandle)
p_set_font(hal.克隆元组(WindowHandle))
hal.disp_message(WindowHandle,"Find and decode 2D data codes","window",-1,-1,"black","true")
' 
hal.dev_open_window_fit_image(TiledImage,113,0,640,-1,WindowHandle1)
p_set_font(hal.克隆元组(WindowHandle1))
hal.dev_display(TiledImage)
' 
hal.disp_message(WindowHandle1,"QR code","image",240,12,"black","true")
hal.disp_message(WindowHandle1,"ECC 200","image",240,hal.加(12,284),"black","true")
hal.disp_message(WindowHandle1,"Aztec code","image",240,hal.加(hal.加(12,284),284),"black","true")
hal.disp_message(WindowHandle1,"Micro QR","image",hal.加(240,284),12,"black","true")
hal.disp_message(WindowHandle1,"PDF 417","image",hal.加(240,284),hal.加(12,284),"black","true")
' 
hal.wait_seconds(4)
hal.dev_set_window(WindowHandle1)
hal.dev_close_window()
' 
p_do_qrcode()
p_do_ecc200()
p_do_aztec()
p_do_microqr()
p_do_pdf417()
' 
return()

.子程序 p_grid_read_and_display_1d_bar_code
.参数 Image, obj
.参数 BarCodeDescr, tuple
.参数 Window, tuple
.局部变量 BarCodeHandle, 视觉元组
.局部变量 BarcodeFound, 视觉元组
.局部变量 CodeRegion, 视觉对象
.局部变量 DecodedDataStrings, 视觉元组

hal.create_bar_code_model(hal.创建元组(),hal.创建元组(),BarCodeHandle)
hal.set_bar_code_param(BarCodeHandle,"element_size_min",1.5)
hal.find_bar_code(Image,CodeRegion,BarCodeHandle,"EAN-13",DecodedDataStrings)
hal.赋值(BarcodeFound,hal.大于(hal.取元素总数(DecodedDataStrings),0))
hal.clear_bar_code_model(BarCodeHandle)
hal.dev_set_line_width(2)
hal.dev_set_draw("margin")
hal.dev_set_color("yellow")
hal.dev_display(CodeRegion)
.判断开始 (hal.等于(BarcodeFound,1))
hal.disp_message(Window,hal.创建元组("Bar code: ",DecodedDataStrings),"window",40,-1,"black","true")
.默认
hal.disp_message(Window,"No bar code found.","window",40,-1,"black","true")
.判断结束

hal.dev_set_draw("fill")
hal.dev_set_line_width(2)
return()

.子程序 p_do_ecc200
.局部变量 AllCandidates, 视觉对象
.局部变量 AllStatus, 视觉元组
.局部变量 Ascent, 视觉元组
.局部变量 CandNum, 视觉元组
.局部变量 Contrast, 视觉元组
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 DecodingError, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 FileNames, 视觉元组
.局部变量 GenParamNames, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 K, 视觉元组
.局部变量 Mirrored, 视觉元组
.局部变量 ModuleHeight, 视觉元组
.局部变量 ModuleWidth, 视觉元组
.局部变量 Numbers, 视觉元组
.局部变量 Passes, 视觉元组
.局部变量 Paths, 视觉元组
.局部变量 Polarity, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 ResultNum, 视觉元组
.局部变量 ResultObjectNames, 视觉元组
.局部变量 ResultParamNames, 视觉元组
.局部变量 SL, 视觉元组
.局部变量 Sequence, 视觉元组
.局部变量 Slant, 视觉元组
.局部变量 SymbolCols, 视觉元组
.局部变量 SymbolRows, 视觉元组
.局部变量 SymbolXLD, 视觉对象
.局部变量 SymbolXLDs, 视觉对象
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 THeight, 视觉元组
.局部变量 TPosCol, 视觉元组
.局部变量 TPosRow, 视觉元组
.局部变量 TWidth, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 UndecNum, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' *****************************************************************************
' Example program for demonstrating the 2d data code operators.
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (ECC 200, data matrix).
' This program uses the model without any adaptions, tuning, or
' symbol specific modifications.
' Only the opportunity to switch the complete set of model
' parameters from the standard to the enhanced settings is
' demonstrated.
' Searching the symbols with the standard setting is faster,
' especially, if no readable symbol is found.  On the other hand,
' there are a number of restrictions concerning the symbol size,
' the module size, the polarity, and the minimum contrast, that
' prevent a number of symbols from being detected.
' 
' Number of image files contained in the sequence
hal.赋值(Paths,hal.创建元组("datacode/ecc200/ecc200_disturbed_","datacode/ecc200/ecc200_cpu_"))
hal.赋值(Sequence,hal.创建序列(1,20, 1))
hal.赋值(Numbers,hal.文本格式化(Sequence,".03"))
hal.赋值(FileNames,hal.加(hal.取元素(Paths,0),hal.取元素范围(Numbers,0,16)))
hal.赋值(FileNames,hal.创建元组(FileNames,hal.加(hal.取元素(Paths,1),Numbers)))
' 
' The first two images in the array are specially illustrative of
' the difficulty of the task at hand, therefore there will be shown
' in more detail
hal.赋值(FileNames,hal.创建元组(hal.取元素(FileNames,12),hal.取元素(FileNames,19),FileNames))
' 
hal.read_image(Image,hal.取元素(FileNames,2))
hal.get_image_size(Image,Width,Height)
hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.get_string_extents(WindowHandle,"decqde-Err: ",Ascent,Descent,TWidth,THeight)
' 
' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' You can choose between two default parameter settings:
' the standard and an enhanced one.
' --------------------------------------------------
' --------   ATTENTION !!!   --------
' --------------------------------------------------
' Please recognize that there are symbols that cannot be found with the
' standard default parameters.
' The reasons for that are:
' + the contrast is too low
' + some symbols are printed light on dark, which is not covered by
' the standard model
' + the symbols are too big (>48x48 modules)
' + the modules are printed as small unconnected dots
' Changing the default parameter set to 'enhanced recognition' enables
' HALCON to find most of the symbols that couldn't be detected before.
' The price for the improved recognition rate is an increasing runtime,
' especially when no datacode symbols are found.
' --------------------------------------------------
' 
hal.create_data_code_2d_model("Data Matrix ECC 200",hal.创建元组(),hal.创建元组(),DataCodeHandle)
' 
' by (un)commenting the appropriate command line one can
' switch between standard and enhanced mode
' The standard mode is the default!
' 
hal.set_data_code_2d_param(DataCodeHandle,"default_parameters","enhanced_recognition")
' 
' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.
' 
hal.query_data_code_2d_params(DataCodeHandle,"get_model_params",GenParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_params",ResultParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_objects",ResultObjectNames)
' 
' 
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(FileNames),1)))
'     
'     read the next image
hal.read_image(Image,hal.取元素(FileNames,I))
'     
'     
'     in the sequence 'datacode/ecc200/ecc200_cpu_007', ..., there is inversion of polarity
.判断开始 (hal.且(hal.大于(I,24),hal.小于(I,35)))
hal.set_data_code_2d_param(DataCodeHandle,"polarity","light_on_dark")
.默认
hal.set_data_code_2d_param(DataCodeHandle,"polarity","dark_on_light")
.判断结束

'     
'     
'     look for the 2d data code symbols
'     - stop after finding the expected number of symbols (or after the last search pass)
'     - measure the run time of find_data_code_2d
'     
hal.dev_update_var("off")
hal.count_seconds(T1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(T2)
hal.dev_update_var("on")
hal.赋值(Time,hal.乘(1000,hal.减(T2,T1)))
'     
'     get some interesting information about the search in general
'     
hal.get_data_code_2d_results(DataCodeHandle,"general","result_num",ResultNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","candidate_num",CandNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","pass_num",Passes)
hal.get_data_code_2d_results(DataCodeHandle,"general","undecoded_num",UndecNum)
hal.get_data_code_2d_results(DataCodeHandle,"general",hal.创建元组("search_level","min_search_level","max_search_level"),SL)
'     
'     get some interesting information about all successfully detected symbols
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_rows",SymbolRows)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_cols",SymbolCols)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_height",ModuleHeight)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_width",ModuleWidth)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mirrored",Mirrored)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","contrast",Contrast)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","decoding_error",DecodingError)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","slant",Slant)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","polarity",Polarity)
'     
'     get some information about all investigated symbol candidates in order to get a first
'     hint why a symbol could not be read
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_candidates","status",AllStatus)
hal.get_data_code_2d_objects(AllCandidates,DataCodeHandle,"all_candidates","candidate_xld")
'     
'     display some of the general information (runtime, number of found symbols and passes)
'     and display all candidates that were investigated (red) and the decoded symbols (green)
'     
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.加(hal.加("ECC 200 found and decoded in ",hal.文本格式化(Time,".1f"))," ms"),"window",-1,-1,"black","true")
hal.dev_set_color("green")
hal.dev_set_line_width(3)
hal.dev_display(SymbolXLDs)
hal.dev_set_line_width(1)
'     
'     for all symbols display the encoded data string and some
'     info about the symbol and the reading process
'     
hal.赋值 (K, 0)
.判断循环首 (hal.小于等于 (K, hal.减(hal.取元素总数(ResultHandles),1)))
hal.select_obj(SymbolXLDs,SymbolXLD,hal.加(K,1))
hal.dev_set_window(WindowHandle)
p_datacode_result_pos(hal.克隆对象(SymbolXLD),hal.创建元组(hal.乘(1.7,TWidth)),hal.克隆元组(THeight),hal.创建元组(7),hal.克隆元组(Width),hal.克隆元组(Height),TPosRow,TPosCol)
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(0),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Symbol:"),hal.创建元组(hal.加(hal.加(hal.取元素(SymbolRows,K),"x"),hal.取元素(SymbolCols,K))),hal.创建元组("orange"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(1),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Modules:"),hal.创建元组(hal.加(hal.加(hal.文本格式化(hal.取元素(ModuleHeight,K),".1f"),"x"),hal.文本格式化(hal.取元素(ModuleWidth,K),".1f"))),hal.创建元组("orange"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(2),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Mirrored:"),hal.创建元组(hal.取元素(Mirrored,K)),hal.创建元组("orange"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(3),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Contrast:"),hal.创建元组(hal.取元素(Contrast,K)),hal.创建元组("orange"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(4),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Decode-err:"),hal.创建元组(hal.取元素(DecodingError,K)),hal.创建元组("orange"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(6),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Result:"),hal.创建元组(""),hal.创建元组("green"))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(7),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组(hal.取元素(DecodedDataStrings,K)),hal.创建元组(""),hal.创建元组("green"))
K ＝ hal.加 (K, 1)
.判断循环尾 ()
'     
'       make a pause when displaying results on the two illustrative images
.判断开始 (hal.小于等于(I,1))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
' cleanup: close the 2d data code model
' 
hal.clear_data_code_2d_model(DataCodeHandle)
return()

.子程序 p_do_qrcode
.局部变量 AllCandidates, 视觉对象
.局部变量 AllStatus, 视觉元组
.局部变量 Ascent, 视觉元组
.局部变量 CandNum, 视觉元组
.局部变量 Color, 视觉元组
.局部变量 Contrast, 视觉元组
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 DecodingError, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 ErrorCorrectionLevel, 视觉元组
.局部变量 FileNames, 视觉元组
.局部变量 GenParamNames, 视觉元组
.局部变量 GenParamValues, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 K, 视觉元组
.局部变量 MaskPattern, 视觉元组
.局部变量 Mirrored, 视觉元组
.局部变量 ModelType, 视觉元组
.局部变量 ModuleHeight, 视觉元组
.局部变量 ModuleWidth, 视觉元组
.局部变量 Numbers, 视觉元组
.局部变量 Passes, 视觉元组
.局部变量 Paths, 视觉元组
.局部变量 Polarity, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 ResultNum, 视觉元组
.局部变量 ResultObjectNames, 视觉元组
.局部变量 ResultParamNames, 视觉元组
.局部变量 SL, 视觉元组
.局部变量 Sequence, 视觉元组
.局部变量 SymbolXLD, 视觉对象
.局部变量 SymbolXLDs, 视觉对象
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 THeight, 视觉元组
.局部变量 TPosCol, 视觉元组
.局部变量 TPosRow, 视觉元组
.局部变量 TWidth, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 UndecNum, 视觉元组
.局部变量 Version, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' *****************************************************************************
' Example program for demonstrating the 2d data code operators.
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (QR code).
' This program uses the model without any adaptions, tuning, or
' symbol specific modifications.
' Only the opportunity to switch the complete set of model
' parameters from the standard to the enhanced settings is
' demonstrated.
' Searching the symbols with the standard setting is faster,
' especially, if no readable symbol is found.  On the other hand,
' there are a number of restrictions concerning the symbol size,
' the module size, the polarity, and the minimum contrast, that
' prevent a number of symbols from being detected.
' 
' The first two images in the array are specially illustrative of
' the difficulty of the task at hand, therefore there will be shown
' in more detail
hal.赋值(Paths,"datacode/qrcode/qr_workpiece_")
hal.赋值(Sequence,hal.创建序列(1,9, 1))
hal.赋值(Numbers,hal.文本格式化(Sequence,".02"))
hal.赋值(FileNames,hal.加(hal.取元素(Paths,0),Numbers))
hal.赋值(FileNames,hal.创建元组(hal.取元素(FileNames,0),hal.取元素(FileNames,8),FileNames,hal.取元素范围(FileNames,0,5)))
' 
' 
hal.read_image(Image,hal.取元素(FileNames,0))
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.get_string_extents(WindowHandle,"Err-cqrr-level: ",Ascent,Descent,TWidth,THeight)
' 
' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' For the model, you can choose between two default parameter settings:
' the standard and an enhanced one.  The standard mode is the default
' mode that is chosen if no parameter setting is explicitly specified.
' --------------------------------------------------
' --------   ATTENTION !!!   --------
' --------------------------------------------------
' Please recognize that there are symbols that cannot be found with the
' standard default parameters.
' The reasons for that are:
' + the contrast is too low
' + some symbols are printed light on dark, which is not covered by
' the standard model
' + the symbols are too big (>version 15 = >71x71 modules)
' + the modules are printed as small unconnected dots
' Changing the default parameter set to 'enhanced recognition' enables
' HALCON to find most of the symbols that couldn't be detected before.
' The price for the improved recognition rate is an increasing runtime,
' especially if no datacode symbols are found.
' --------------------------------------------------
' 
hal.create_data_code_2d_model("QR Code",hal.创建元组(),hal.创建元组(),DataCodeHandle)
' 
' by (un)commenting the appropriate command line one can
' switch between standard and enhanced mode
' After the model creation the standard mode is the default!
' 
hal.set_data_code_2d_param(DataCodeHandle,"default_parameters","enhanced_recognition")
' 
' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.
' 
hal.query_data_code_2d_params(DataCodeHandle,"get_model_params",GenParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_params",ResultParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_objects",ResultObjectNames)
' 
' within a loop:
' + read the next image from the image sequence file
' + try to recognize the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process
' 
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(FileNames),1)))
'     
'     read the next image
hal.read_image(Image,hal.取元素(FileNames,I))
'     
'     
'     re-read the current settings of the model
hal.get_data_code_2d_param(DataCodeHandle,GenParamNames,GenParamValues)
'     
'     look for the 2d data code symbols
'     - stop after finding the expected number of symbols (or after the last search pass)
'     - measure the run time of find_data_code_2d
'     
hal.dev_update_var("off")
hal.count_seconds(T1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(T2)
hal.dev_update_var("on")
hal.赋值(Time,hal.乘(1000,hal.减(T2,T1)))
'     
'     get some interesting information about the search in general
'     
hal.get_data_code_2d_results(DataCodeHandle,"general","result_num",ResultNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","candidate_num",CandNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","pass_num",Passes)
hal.get_data_code_2d_results(DataCodeHandle,"general","undecoded_num",UndecNum)
hal.get_data_code_2d_results(DataCodeHandle,"general",hal.创建元组("search_level","min_search_level","max_search_level"),SL)
'     
'     get some interesting information about all successfully detected symbols
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_results","model_type",ModelType)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","version",Version)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_height",ModuleHeight)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_width",ModuleWidth)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mirrored",Mirrored)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","contrast",Contrast)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","decoding_error",DecodingError)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mask_pattern_ref",MaskPattern)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","error_correction_level",ErrorCorrectionLevel)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","polarity",Polarity)
'     
'     get some information about all investigated symbol candidates in order to get a first
'     hint why a symbol could not be read
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_candidates","status",AllStatus)
hal.get_data_code_2d_objects(AllCandidates,DataCodeHandle,"all_candidates","candidate_xld")
'     
'     display some of the general information (runtime, number of found symbols and passes)
'     and display all candidates that were investigated (red) and the decoded symbols (green)
'     
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.加(hal.加("QR Code found and decoded in ",hal.文本格式化(Time,".1f"))," ms"),"window",12,12,"black","true")
hal.dev_set_color("green")
hal.dev_set_line_width(3)
hal.dev_display(SymbolXLDs)
hal.dev_set_line_width(1)
'     
'     for all symbols display the encoded data string and some
'     info about the symbol and the reading process
'     
hal.赋值 (K, 0)
.判断循环首 (hal.小于等于 (K, hal.减(hal.取元素总数(ResultHandles),1)))
hal.select_obj(SymbolXLDs,SymbolXLD,hal.加(K,1))
hal.dev_set_window(WindowHandle)
hal.赋值(Color,"orange")
p_datacode_result_pos(hal.克隆对象(SymbolXLD),hal.创建元组(hal.乘(1.7,TWidth)),hal.克隆元组(THeight),hal.创建元组(10),hal.克隆元组(Width),hal.克隆元组(Height),TPosRow,TPosCol)
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(0),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Model type:"),hal.创建元组(hal.取元素(ModelType,K)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(1),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Version:"),hal.创建元组(hal.加(hal.加(hal.加(hal.加(hal.加(hal.取元素(Version,K),"  ("),hal.加(hal.乘(hal.取元素(Version,K),4),17)),"x"),hal.加(hal.乘(hal.取元素(Version,K),4),17)),")")),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(2),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Modules:"),hal.创建元组(hal.加(hal.加(hal.文本格式化(hal.取元素(ModuleHeight,K),".1f"),"x"),hal.文本格式化(hal.取元素(ModuleWidth,K),".1f"))),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(3),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Mirrored:"),hal.创建元组(hal.取元素(Mirrored,K)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(4),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Contrast:"),hal.创建元组(hal.取元素(Contrast,K)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(5),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Decod.err:"),hal.创建元组(hal.取元素(DecodingError,K)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(6),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Mask pattern:"),hal.创建元组(hal.取元素(MaskPattern,K)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(7),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Err-corr-level:"),hal.创建元组(hal.取元素(ErrorCorrectionLevel,K)),hal.克隆元组(Color))
hal.赋值(Color,"green")
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(9),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组("Result:"),hal.创建元组(""),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(10),hal.克隆元组(TWidth),hal.克隆元组(THeight),hal.创建元组(hal.取元素(DecodedDataStrings,K)),hal.创建元组(""),hal.克隆元组(Color))
'         
K ＝ hal.加 (K, 1)
.判断循环尾 ()
'     
.判断开始 (hal.小于等于(I,1))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(4)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
' cleanup: close the 2d data code model
' 
hal.clear_data_code_2d_model(DataCodeHandle)
' 
return()

.子程序 p_datacode_write_result
.参数 WindowHandle, tuple
.参数 Row, tuple
.参数 Col, tuple
.参数 Number, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 Name, tuple
.参数 Value, tuple
.参数 Color, tuple
.局部变量 C, 视觉元组
.局部变量 R, 视觉元组

' 
hal.赋值(R,hal.加(Row,hal.乘(Number,Height)))
hal.赋值(C,Col)
hal.disp_message(WindowHandle,Name,"window",hal.加(R,1),hal.加(C,1),"black","false")
hal.disp_message(WindowHandle,Name,"window",hal.减(R,1),hal.减(C,1),"black","false")
hal.disp_message(WindowHandle,Name,"window",hal.加(R,1),hal.减(C,1),"black","false")
hal.disp_message(WindowHandle,Name,"window",hal.减(R,1),hal.加(C,1),"black","false")
hal.disp_message(WindowHandle,Name,"window",R,C,Color,"false")
hal.赋值(C,hal.加(Col,Width))
hal.disp_message(WindowHandle,Value,"window",hal.加(R,1),hal.加(C,1),"black","false")
hal.disp_message(WindowHandle,Value,"window",hal.减(R,1),hal.减(C,1),"black","false")
hal.disp_message(WindowHandle,Value,"window",hal.加(R,1),hal.减(C,1),"black","false")
hal.disp_message(WindowHandle,Value,"window",hal.减(R,1),hal.加(C,1),"black","false")
hal.disp_message(WindowHandle,Value,"window",R,C,Color,"false")
' 
return()

.子程序 p_datacode_result_pos
.参数 DataCode, obj
.参数 TWidth, tuple
.参数 THeight, tuple
.参数 Num, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 PosRow, tuple, 参考
.参数 PosCol, tuple, 参考
.局部变量 Col, 视觉元组
.局部变量 Cut, 视觉元组
.局部变量 Max, 视觉元组
.局部变量 Row, 视觉元组

hal.get_contour_xld(DataCode,Row,Col)
hal.赋值(PosRow,hal.mean(Row))
hal.赋值(PosCol,hal.mean(Col))
hal.赋值(Max,hal.除(hal.乘(hal.乘(-hal.取元组小数(Num,),THeight),TWidth),2))
' Above
hal.赋值(Cut,hal.求最小值(hal.创建元组(hal.乘(hal.减(hal.求最小值(Row),hal.乘(Num,THeight)),TWidth),hal.乘(hal.减(Width,hal.加(hal.求最小值(Col),TWidth)),THeight))))
.判断开始 (hal.大于(Cut,Max))
hal.赋值(PosRow,hal.减(hal.求最小值(Row),hal.乘(Num,THeight)))
hal.赋值(PosCol,hal.求最小值(Col))
hal.赋值(Max,Cut)
.判断结束

' Below
hal.赋值(Cut,hal.求最小值(hal.创建元组(hal.乘(hal.减(Height,hal.加(hal.求最大值(Row),hal.乘(Num,THeight))),TWidth),hal.乘(hal.减(Width,hal.加(hal.求最小值(Col),TWidth)),THeight))))
.判断开始 (hal.大于(Cut,Max))
hal.赋值(PosRow,hal.求最大值(Row))
hal.赋值(PosCol,hal.求最小值(Col))
hal.赋值(Max,Cut)
.判断结束

' Left
hal.赋值(Cut,hal.求最小值(hal.创建元组(hal.乘(hal.乘(hal.减(hal.求最小值(Col),TWidth),Num),THeight),hal.乘(hal.减(Height,hal.加(hal.求最小值(Row),hal.乘(Num,THeight))),TWidth))))
.判断开始 (hal.大于(Cut,Max))
hal.赋值(PosRow,hal.求最小值(Row))
hal.赋值(PosCol,hal.减(hal.求最小值(Col),TWidth))
hal.赋值(Max,Cut)
.判断结束

' Right
hal.赋值(Cut,hal.求最小值(hal.创建元组(hal.乘(hal.乘(hal.减(Width,hal.加(hal.求最大值(Col),TWidth)),Num),THeight),hal.乘(hal.减(Height,hal.加(hal.求最小值(Row),hal.乘(Num,THeight))),TWidth))))
.判断开始 (hal.大于(Cut,Max))
hal.赋值(PosRow,hal.求最小值(Row))
hal.赋值(PosCol,hal.求最大值(Col))
hal.赋值(Max,Cut)
.判断结束

return()

.子程序 p_disp_pause_sign
.参数 WindowHandle, tuple
.参数 Position, tuple
.局部变量 Ascent, 视觉元组
.局部变量 C1, 视觉元组
.局部变量 C2, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Column1Part, 视觉元组
.局部变量 Column2Part, 视觉元组
.局部变量 ColumnWin, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 DrawMode, 视觉元组
.局部变量 FactorColumn, 视觉元组
.局部变量 FactorRow, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 HeightWin, 视觉元组
.局部变量 R1, 视觉元组
.局部变量 R2, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1Part, 视觉元组
.局部变量 Row2Part, 视觉元组
.局部变量 RowWin, 视觉元组
.局部变量 String, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WidthWin, 视觉元组

hal.get_part(WindowHandle,Row1Part,Column1Part,Row2Part,Column2Part)
hal.get_window_extents(WindowHandle,RowWin,ColumnWin,WidthWin,HeightWin)
hal.set_display_font(WindowHandle,11,"mono","true","false")
hal.赋值(String," Slow motion ")
hal.get_string_extents(WindowHandle,String,Ascent,Descent,Width,Height)
hal.赋值(Row,12)
hal.赋值(Column,hal.减(hal.减(WidthWin,12),Width))
' Adapt Height for different font sizes!
hal.赋值(Height,15)
' Adapt text position and extents because of image zooming
hal.赋值(FactorRow,hal.除(hal.乘(到小数(1.),hal.加(hal.减(Row2Part,Row1Part),1)),HeightWin))
hal.赋值(FactorColumn,hal.除(hal.乘(到小数(1.),hal.加(hal.减(Column2Part,Column1Part),1)),WidthWin))
hal.get_draw(WindowHandle,DrawMode)
hal.dev_set_draw("fill")
hal.dev_set_color("#F28D26")
hal.赋值(R1,hal.加(hal.加(hal.乘(Row,FactorRow),0.5),Row1Part))
hal.赋值(C1,hal.加(hal.加(hal.乘(Column,FactorColumn),0.5),Column1Part))
hal.赋值(R2,hal.加(hal.加(hal.乘(hal.减(hal.加(Row,Height),1),FactorRow),0.5),Row1Part))
hal.赋值(C2,hal.加(hal.加(hal.乘(hal.减(hal.加(Column,Width),1),FactorColumn),0.5),Column1Part))
hal.gen_rectangle1(Rectangle,R1,C1,R2,C2)
hal.dev_display(Rectangle)
hal.dev_set_color("black")
hal.set_tposition(WindowHandle,R1,C1)
hal.dev_set_color("black")
hal.write_string(WindowHandle,String)
hal.dev_set_draw(DrawMode)
p_set_font(hal.克隆元组(WindowHandle))
return()

.子程序 p_show_intro
.参数 MainWindow, tuple, 参考
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Path, 视觉元组
.局部变量 Slide, 视觉对象
.局部变量 TimeToWait, 视觉元组
.局部变量 Width, 视觉元组

hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",MainWindow)
hal.dev_set_window(MainWindow)
hal.dev_update_off()
' 
hal.赋值(Path,"explore_halcon/")
hal.赋值(TimeToWait,hal.创建元组(2,8,6,10,12,12,8))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 7))
hal.read_image(Slide,hal.加(hal.加(hal.加(Path,"explore_halcon_"),hal.文本格式化(I,".2")),"_start"))
hal.get_image_size(Slide,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Slide)
hal.wait_seconds(0.1)
hal.read_image(Slide,hal.加(hal.加(Path,"explore_halcon_"),hal.文本格式化(I,".2")))
hal.dev_display(Slide)
p_wait_mouse_click(hal.克隆元组(MainWindow),hal.创建元组(452),hal.创建元组(379),hal.创建元组(470),hal.创建元组(419),hal.创建元组(hal.取元素(TimeToWait,hal.减(I,1))))
I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
return()

.子程序 p_show_end
.参数 StatusWindow, tuple
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Path, 视觉元组
.局部变量 Slide, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

hal.dev_set_window(StatusWindow)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_window(WindowHandle)
hal.dev_update_window("off")
' 
hal.赋值(Path,"explore_halcon/")
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 6))
hal.read_image(Slide,hal.加(hal.加(Path,"explore_halcon_more_"),hal.文本格式化(I,".2")))
hal.get_image_size(Slide,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Slide)
hal.wait_seconds(1)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
'* dev_close_window ()
' 
return()

.子程序 p_wait_mouse_click
.参数 WindowHandle, tuple
.参数 RectR1, tuple
.参数 RectC1, tuple
.参数 RectR2, tuple
.参数 RectC2, tuple
.参数 WaitSeconds, tuple
.局部变量 Button, 视觉元组
.局部变量 Clicked, 视觉元组
.局部变量 Col, 视觉元组
.局部变量 Error, 视觉元组
.局部变量 Information, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Seconds1, 视觉元组
.局部变量 Seconds2, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 false, 视觉元组
.局部变量 true, 视觉元组

hal.dev_update_off()
hal.gen_rectangle1(Rectangle,RectR1,RectC1,RectR2,RectC2)
hal.get_system("clock_mode",Information)
hal.set_system("clock_mode","elapsed_time")
hal.count_seconds(Seconds1)
hal.赋值(Time,0)
hal.赋值(Clicked,false)
.判断循环首 (hal.且(hal.小于(Time,WaitSeconds),hal.取反(Clicked)))
'*     wait_seconds (0.2)
hal.count_seconds(Seconds2)
hal.赋值(Time,hal.减(Seconds2,Seconds1))
hal.dev_error_var(Error,1)
hal.dev_set_check("~give_error")
hal.get_mposition(WindowHandle,Row,Col,Button)
hal.dev_error_var(Error,0)
hal.dev_set_check("give_error")
.判断开始 (hal.不等于(Error,#视觉_错误代码_无错误))
hal.赋值(Button,0)
.判断结束

.判断开始 (hal.且(hal.且(hal.且(hal.且(hal.等于(Button,1),hal.大于(Row,RectR1)),hal.小于(Row,RectR2)),hal.大于(Col,RectC1)),hal.小于(Col,RectC2)))
hal.赋值(Clicked,true)
.判断结束

.判断循环尾 ()
hal.set_system("clock_mode",Information)
hal.dev_update_on()
return()

.子程序 p_do_pdf417
.局部变量 AllCandidates, 视觉对象
.局部变量 AllStatus, 视觉元组
.局部变量 Ascent, 视觉元组
.局部变量 CandNum, 视觉元组
.局部变量 Col, 视觉元组
.局部变量 Color, 视觉元组
.局部变量 Contrast, 视觉元组
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedData, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 DecodingError, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 ErrorCorrectionLevel, 视觉元组
.局部变量 FileNames, 视觉元组
.局部变量 GenParamNames, 视觉元组
.局部变量 GenParamValues, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageEmpty, 视觉对象
.局部变量 J, 视觉元组
.局部变量 MacroExist, 视觉元组
.局部变量 Mirrored, 视觉元组
.局部变量 ModuleAspect, 视觉元组
.局部变量 ModuleHeight, 视觉元组
.局部变量 ModuleWidth, 视觉元组
.局部变量 Numbers, 视觉元组
.局部变量 Passes, 视觉元组
.局部变量 Paths, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 ResultNum, 视觉元组
.局部变量 ResultObjectNames, 视觉元组
.局部变量 ResultParamNames, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SL, 视觉元组
.局部变量 Sequence, 视觉元组
.局部变量 SymbolColumns, 视觉元组
.局部变量 SymbolRows, 视觉元组
.局部变量 SymbolXLD, 视觉对象
.局部变量 SymbolXLDs, 视觉对象
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 THeight, 视觉元组
.局部变量 THeightResult, 视觉元组
.局部变量 TPosCol, 视觉元组
.局部变量 TPosRow, 视觉元组
.局部变量 TWidth, 视觉元组
.局部变量 TWidthResult, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 UndecNum, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandleResult, 视觉元组

' 
' *****************************************************************************
' Example program for demonstrating the 2d data code operators
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (PDF417). To optimize the run time the
' parameters are set manually.
' In particular, the setting of the polarity helps to reduce the run time.
' In this example the polarity, the symbol size, the module size, and
' the minimum contrast are set.
' Note that in general the parameters can be chosen even more restrictive
' because the symbol variations in practice are smaller than in this example.
' 
hal.赋值(Paths,"datacode/pdf417/pdf417_misc_")
hal.赋值(Sequence,hal.创建序列(1,10, 1))
hal.赋值(Numbers,hal.文本格式化(Sequence,".02"))
hal.赋值(FileNames,hal.加(hal.取元素(Paths,0),Numbers))
hal.赋值(FileNames,hal.创建元组(hal.取元素(FileNames,7),hal.取元素(FileNames,4),FileNames))
' 
hal.read_image(Image,hal.取元素(FileNames,2))
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_open_window(489,0,640,95,"black",WindowHandleResult)
hal.dev_set_part(0,0,94,639)
hal.set_display_font(WindowHandleResult,11,"mono","true","false")
hal.get_string_extents(WindowHandleResult,"Symbol columns: ",Ascent,Descent,TWidthResult,THeightResult)
hal.gen_image_const(ImageEmpty,"byte",640,95)
p_set_font(hal.克隆元组(WindowHandle))
hal.get_string_extents(WindowHandle,"ymbol columns: ",Ascent,Descent,TWidth,THeight)
hal.dev_set_window(WindowHandle)
' 
' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' 
hal.create_data_code_2d_model("PDF417",hal.创建元组(),hal.创建元组(),DataCodeHandle)
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("symbol_rows_min","symbol_rows_max"),hal.创建元组(6,16))
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("symbol_cols_min","symbol_cols_max"),hal.创建元组(5,9))
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("module_width_min","module_width_max"),hal.创建元组(到小数(2.0),到小数(4.0)))
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("module_aspect_min","module_aspect_max"),hal.创建元组(2.5,到小数(4.0)))
hal.set_data_code_2d_param(DataCodeHandle,"polarity","dark_on_light")
hal.set_data_code_2d_param(DataCodeHandle,"contrast_min",10)
' 
' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.
' 
hal.query_data_code_2d_params(DataCodeHandle,"get_model_params",GenParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_params",ResultParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_objects",ResultObjectNames)
' 
' 
' Within a loop:
' + read the next image from the image sequence file
' + try to recognize the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process
' 
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(FileNames),1)))
'     
'     Read the next image
hal.read_image(Image,hal.取元素(FileNames,I))
'     
'     Re-read the current settings of the model
hal.get_data_code_2d_param(DataCodeHandle,GenParamNames,GenParamValues)
'     
'     Look for the 2d data code symbols
'     - stop after finding the expected number of symbols (or after the last search pass)
'     - measure the run time of find_data_code_2d
'     
hal.count_seconds(T1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(T2)
hal.赋值(Time,hal.乘(1000,hal.减(T2,T1)))
'     
'     Get some interesting information about the search in general
'     
hal.get_data_code_2d_results(DataCodeHandle,"general","result_num",ResultNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","candidate_num",CandNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","pass_num",Passes)
hal.get_data_code_2d_results(DataCodeHandle,"general","undecoded_num",UndecNum)
hal.get_data_code_2d_results(DataCodeHandle,"general",hal.创建元组("search_level","min_search_level","max_search_level"),SL)
'     
'     Get some interesting information about all successfully detected symbols
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_height",ModuleHeight)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_width",ModuleWidth)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_aspect",ModuleAspect)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_rows",SymbolRows)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_cols",SymbolColumns)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mirrored",Mirrored)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","contrast",Contrast)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","decoding_error",DecodingError)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","error_correction_level",ErrorCorrectionLevel)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","macro_exist",MacroExist)
'     
'     Get some information about all investigated symbol candidates in order to get a first
'     hint why a symbol could not be read
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_candidates","status",AllStatus)
hal.get_data_code_2d_objects(AllCandidates,DataCodeHandle,"all_candidates","candidate_xld")
'     
'     Display some of the general information (runtime, number of found symbols and passes)
'     and display all candidates that were investigated (red) and the decoded symbols (green)
'     
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.加(hal.加("PDF417 found and decoded in ",hal.文本格式化(Time,".0f"))," ms"),"window",12,12,"black","true")
hal.dev_set_color("green")
hal.dev_set_line_width(3)
hal.dev_display(SymbolXLDs)
hal.dev_set_line_width(1)
'     
'     For all symbols display the encoded data string and some
'     info about the symbol and the reading process
'     
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(ResultHandles),1)))
hal.select_obj(SymbolXLDs,SymbolXLD,hal.加(J,1))
hal.get_contour_xld(SymbolXLD,Row,Col)
hal.赋值(Color,"orange")
'         
p_datacode_result_pos(hal.克隆对象(SymbolXLD),hal.创建元组(hal.乘(1.3,TWidth)),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组(7),hal.克隆元组(Width),hal.克隆元组(Height),TPosRow,TPosCol)
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(0),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Symbol rows:"),hal.创建元组(hal.取元素(SymbolRows,J)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(1),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Symbol columns:"),hal.创建元组(hal.取元素(SymbolColumns,J)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(2),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Modules:"),hal.创建元组(hal.加(hal.加(hal.文本格式化(hal.取元素(ModuleHeight,J),".1f"),"x"),hal.文本格式化(hal.取元素(ModuleWidth,J),".1f"))),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(3),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Mirrored:"),hal.创建元组(hal.取元素(Mirrored,J)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(4),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Contrast:"),hal.创建元组(hal.取元素(Contrast,J)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(5),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Decod.err:"),hal.创建元组(hal.取元素(DecodingError,J)),hal.克隆元组(Color))
p_datacode_write_result(hal.克隆元组(WindowHandle),hal.克隆元组(TPosRow),hal.克隆元组(TPosCol),hal.创建元组(6),hal.克隆元组(TWidth),hal.创建元组(hal.乘(THeight,0.9)),hal.创建元组("Err-corr-level:"),hal.创建元组(hal.取元素(ErrorCorrectionLevel,J)),hal.克隆元组(Color))
'         Because some of the symbols encode escape sequences we should not output the
'         decoded string directly. Therefore, we base the output on the ASCII values of the
'         decoded data and interpret these values manually.
hal.dev_set_window(WindowHandleResult)
hal.dev_set_color("green")
hal.dev_display(ImageEmpty)
hal.get_data_code_2d_results(DataCodeHandle,hal.取元素(ResultHandles,J),"decoded_data",DecodedData)
hal.set_tposition(WindowHandleResult,5,10)
hal.write_string(WindowHandleResult,"Result:")
write_encoded_data(hal.克隆元组(WindowHandleResult),hal.克隆元组(DecodedData),hal.创建元组(5),hal.创建元组(80),hal.克隆元组(TWidthResult),hal.创建元组(hal.乘(THeightResult,0.9)),hal.创建元组(95),hal.克隆元组(Width),hal.创建元组("green"))
hal.dev_set_window(WindowHandle)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
'     
.判断开始 (hal.小于等于(I,1))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
' Cleanup: close the 2d data code model
' 
hal.clear_data_code_2d_model(DataCodeHandle)
hal.dev_set_window(WindowHandleResult)
hal.dev_close_window()
return()

.子程序 write_encoded_data
.参数 WindowHandle, tuple
.参数 DecodedData, tuple
.参数 Row, tuple
.参数 Col, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 ImageHeight, tuple
.参数 ImageWidth, tuple
.参数 Color, tuple
.局部变量 Ascent, 视觉元组
.局部变量 Char, 视觉元组
.局部变量 CharASCII, 视觉元组
.局部变量 ColumnCurrent, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 Height1, 视觉元组
.局部变量 I, 视觉元组
.局部变量 LastSpace, 视觉元组
.局部变量 LetterWidth, 视觉元组
.局部变量 RectangleDelete, 视觉对象
.局部变量 RowCurrent, 视觉元组
.局部变量 TextLine, 视觉元组

' Count the number of lines to write
'* I := 0
'* TextLine := 0
'* while (I < |DecodedData|)
'*     Char := DecodedData[I]
'*     tuple_chr (Char, CharASCII)
'*     if (Char == 10)
'         simulate LF (line feed) only if no CR follows
'*         if (I + 1 == |DecodedData|)
'*             TextLine := TextLine + 1
'*         else
'*             if (DecodedData[I + 1] != 13)
'*                 TextLine := TextLine + 1
'*             endif
'*         endif
'*     endif
'*     if (Char == 13)
'         simulate CR (carriage return) only if no LF follows
'*         if (I + 1 == |DecodedData|)
'*             TextLine := TextLine + 1
'*         else
'*             if (DecodedData[I + 1] != 10)
'*                 TextLine := TextLine + 1
'*             endif
'*         endif
'*     endif
'*     if (Char == 94)
'*         TextLine := TextLine + 1
'*     endif
'*     I := I + 1
'* endwhile
'* if (Row + (TextLine + 1) * Height > ImageHeight)
'*     Row := ImageHeight - (TextLine + 1) * Height
'* endif
hal.dev_set_color("green")
hal.set_tposition(WindowHandle,Row,Col)
hal.赋值(I,0)
hal.赋值(TextLine,0)
hal.赋值(LastSpace,-1)
hal.get_string_extents(WindowHandle,"a",Ascent,Descent,LetterWidth,Height1)
' Interpret the decoded data
.判断循环首 (hal.小于(I,hal.取元素总数(DecodedData)))
hal.赋值(Char,hal.取元素(DecodedData,I))
hal.tuple_chr(Char,CharASCII)
.判断开始 (hal.等于(Char,32))
hal.赋值(LastSpace,I)
.判断结束

.判断开始 (hal.且(hal.且(hal.且(hal.且(hal.且(hal.且(hal.且(hal.不等于(Char,2),hal.不等于(Char,3)),hal.不等于(Char,9)),hal.不等于(Char,10)),hal.不等于(Char,13)),hal.不等于(Char,26)),hal.不等于(Char,31)),hal.不等于(Char,94)))
hal.write_string(WindowHandle,CharASCII)
.默认
.判断开始 (hal.等于(Char,2))
'             ignore STX (start of text)
.判断结束

.判断开始 (hal.等于(Char,3))
'             ignore ETX (end of text)
.判断结束

.判断开始 (hal.等于(Char,9))
'             simulate TAB (horizontal tab)
hal.write_string(WindowHandle,"  ")
.判断结束

.判断开始 (hal.等于(Char,10))
'             simulate LF (line feed) only if no CR follows
.判断开始 (hal.等于(hal.加(I,1),hal.取元素总数(DecodedData)))
hal.赋值(TextLine,hal.加(TextLine,1))
hal.set_tposition(WindowHandle,hal.加(Row,hal.乘(Height,TextLine)),Col)
.默认
.判断开始 (hal.不等于(hal.取元素(DecodedData,hal.加(I,1)),13))
hal.赋值(TextLine,hal.加(TextLine,1))
hal.set_tposition(WindowHandle,hal.加(Row,hal.乘(Height,TextLine)),Col)
.判断结束

.判断结束

.判断结束

.判断开始 (hal.等于(Char,13))
'             simulate CR (carriage return) only if no LF follows
.判断开始 (hal.等于(hal.加(I,1),hal.取元素总数(DecodedData)))
hal.赋值(TextLine,hal.加(TextLine,1))
hal.set_tposition(WindowHandle,hal.加(Row,hal.乘(Height,TextLine)),Col)
.默认
.判断开始 (hal.不等于(hal.取元素(DecodedData,hal.加(I,1)),10))
hal.赋值(TextLine,hal.加(TextLine,1))
hal.set_tposition(WindowHandle,hal.加(Row,hal.乘(Height,TextLine)),Col)
.判断结束

.判断结束

.判断结束

.判断开始 (hal.等于(Char,26))
'             ignore SUB (substitution)
.判断结束

.判断开始 (hal.等于(Char,31))
'             ignore VT (vertical tab)
.判断结束

.判断开始 (hal.等于(Char,94))
'             replace ^ by LF
'*             TextLine := TextLine + 1
'*             set_tposition (WindowHandle, Row + Height * TextLine, Col)
'             replace ^ by ' '
hal.赋值(LastSpace,I)
hal.write_string(WindowHandle," ")
.判断结束

.判断结束

hal.get_tposition(WindowHandle,RowCurrent,ColumnCurrent)
.判断开始 (hal.且(hal.大于(ColumnCurrent,ImageWidth),hal.不等于(LastSpace,-1)))
hal.gen_rectangle1(RectangleDelete,hal.加(Row,hal.乘(Height,TextLine)),hal.减(ColumnCurrent,hal.乘(hal.减(I,LastSpace),LetterWidth)),hal.加(hal.加(Row,hal.乘(Height,TextLine)),Height),ColumnCurrent)
hal.dev_set_color("black")
hal.dev_display(RectangleDelete)
hal.dev_set_color("green")
hal.赋值(TextLine,hal.加(TextLine,1))
hal.set_tposition(WindowHandle,hal.加(Row,hal.乘(Height,TextLine)),Col)
hal.赋值(I,LastSpace)
.判断结束

hal.赋值(I,hal.加(I,1))
.判断循环尾 ()
return()

.子程序 p_do_3d_position_of_circles
.局部变量 CamParam, 视觉元组
.局部变量 CenterNormal1, 视觉元组
.局部变量 CenterNormal2, 视觉元组
.局部变量 ClusterCN1, 视觉元组
.局部变量 ClusterCN2, 视觉元组
.局部变量 ClusterP1, 视觉元组
.局部变量 ClusterP2, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Cross, 视觉对象
.局部变量 EllipseContours, 视觉对象
.局部变量 EllipseContoursLarge, 视觉对象
.局部变量 EllipseContoursSmall, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 HomMat3D, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 NumberLarge, 视觉元组
.局部变量 NumberSmall, 视觉元组
.局部变量 Pose1, 视觉元组
.局部变量 Pose2, 视觉元组
.局部变量 Qx, 视觉元组
.局部变量 Qy, 视觉元组
.局部变量 Qz, 视觉元组
.局部变量 RadiusLarge, 视觉元组
.局部变量 RadiusSmall, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 false, 视觉元组

' This example program shows how to use the operator get_circle_pose.
' First, the contours of the drill-holes of a rim are extracted.
' Then, the 3D position of the center of these contours is determined with the operator get_circle_pose.
' 
' Read the image and initialize the program.
hal.read_image(Image,"rim")
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window_fit_image(Image,0,0,640,-1,WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_display(Image)
hal.dev_set_line_width(2)
' 
' Determine the elliptical contours of the drill-holes.
p_determine_ellipse_contours(hal.克隆对象(Image),EllipseContoursLarge,EllipseContoursSmall,hal.创建元组(false),NumberLarge,NumberSmall)
hal.concat_obj(EllipseContoursLarge,EllipseContoursSmall,EllipseContours)
' 
' Set the radius of the drill-holes and the camera parameters (result from a camera calibration)
hal.赋值(RadiusLarge,hal.除(10.25,到小数(1000.0)))
hal.赋值(RadiusSmall,hal.除(5.91,到小数(1000.0)))
hal.赋值(CamParam,hal.创建元组(0.0122,-261.04,7.39e-6,7.4e-6,303.12,234.17,652,494))
' 
' Apply the operator get_circle_pos to determine the position and orientation of the circles.
' Note that in this case the operator get_circle_pose is called two times: First to determine  the poses of the circles,
' then, to determine the normal vectors of the 3D circles.
' For each circle, two possible 3D positions and orientations are determined by the operator get_circle_pose.
' The normal vectors of the 3D circles are used to cluster the results such that all the
' circles that lie within one plane are grouped together. This clustering is carried out by
' the procedure p_cluster_normals.
hal.get_circle_pose(EllipseContours,CamParam,hal.创建元组(hal.gen_tuple_const(NumberLarge,RadiusLarge),hal.gen_tuple_const(NumberSmall,RadiusSmall)),"pose",Pose1,Pose2)
hal.get_circle_pose(EllipseContours,CamParam,hal.创建元组(hal.gen_tuple_const(NumberLarge,RadiusLarge),hal.gen_tuple_const(NumberSmall,RadiusSmall)),"center_normal",CenterNormal1,CenterNormal2)
p_cluster_normals(hal.克隆元组(Pose1),hal.克隆元组(Pose2),hal.克隆元组(CenterNormal1),hal.克隆元组(CenterNormal2),ClusterP1,ClusterP2,ClusterCN1,ClusterCN2)
' 
' Visualize the results.
hal.dev_display(Image)
hal.dev_set_color("blue")
hal.dev_set_line_width(2)
hal.dev_display(EllipseContours)
hal.disp_message(WindowHandle,"Fitted ellipses","image",-1,-1,"black","true")
hal.wait_seconds(3)
' 
hal.disp_message(WindowHandle,hal.创建元组("3D position of the circles","determined solely from the ellipses"),"image",10,-1,"black","true")
hal.dev_set_color("green")
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.加(NumberLarge,NumberSmall),1)))
hal.pose_to_hom_mat3d(hal.取元素范围(ClusterP1,hal.乘(I,7),hal.加(hal.乘(I,7),6)),HomMat3D)
hal.affine_trans_point_3d(HomMat3D,0,0,0,Qx,Qy,Qz)
hal.project_3d_point(Qx,Qy,Qz,CamParam,Row,Column)
hal.gen_cross_contour_xld(Cross,Row,Column,10,0.785398)
hal.dev_display(Cross)
.判断开始 (hal.小于(I,hal.减(hal.加(NumberLarge,NumberSmall),1)))
hal.disp_message(WindowHandle,hal.创建元组(hal.加(hal.加("X= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.乘(I,6)),1000),"3.1f"))," mm"),hal.加(hal.加("Y= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.加(hal.乘(I,6),1)),1000),"3.1f"))," mm"),hal.加(hal.加("Z= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.加(hal.乘(I,6),2)),1000),"3.1f"))," mm")),"image",hal.减(Row,40),hal.减(Column,270),"black","true")
.默认
hal.disp_message(WindowHandle,hal.创建元组(hal.加(hal.加("X= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.乘(I,6)),1000),"3.1f"))," mm"),hal.加(hal.加("Y= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.加(hal.乘(I,6),1)),1000),"3.1f"))," mm"),hal.加(hal.加("Z= ",hal.文本格式化(hal.乘(hal.取元素(ClusterCN1,hal.加(hal.乘(I,6),2)),1000),"3.1f"))," mm")),"image",hal.减(Row,200),hal.减(Column,170),"black","true")
hal.dev_set_color("blue")
hal.disp_line(WindowHandle,404,660,487,709)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(5)
return()

.子程序 p_determine_ellipse_contours
.参数 Image, obj
.参数 EllipseContoursLarge, obj, 参考
.参数 EllipseContoursSmall, obj, 参考
.参数 visualization, tuple
.参数 NumberLarge, tuple, 参考
.参数 NumberSmall, tuple, 参考
.局部变量 Circles, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 Dark, 视觉对象
.局部变量 DarkRegions, 视觉对象
.局部变量 Edges, 视觉对象
.局部变量 EdgesLarge, 视觉对象
.局部变量 EdgesSmall, 视觉对象
.局部变量 EndPhi, 视觉元组
.局部变量 Phi, 视觉元组
.局部变量 PointOrder, 视觉元组
.局部变量 ROI, 视觉对象
.局部变量 ROIEdges, 视觉对象
.局部变量 ROIInner, 视觉对象
.局部变量 ROIOuter, 视觉对象
.局部变量 Ra, 视觉元组
.局部变量 Rb, 视觉元组
.局部变量 RimReduced, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 StartPhi, 视觉元组

hal.threshold(Image,Dark,0,128)
.判断开始 (hal.是否为真(visualization))
hal.dev_display(Image)
hal.dev_set_color("green")
hal.dev_set_draw("fill")
hal.dev_display(Dark)
hal.stop()
.判断结束

' 
hal.connection(Dark,DarkRegions)
hal.select_shape(DarkRegions,Circles,hal.创建元组("circularity","area"),"and",hal.创建元组(0.85,50),hal.创建元组(到小数(1.0),99999))
.判断开始 (hal.是否为真(visualization))
hal.dev_display(Image)
hal.dev_set_colored(12)
hal.dev_display(Circles)
hal.stop()
.判断结束

' 
hal.dilation_circle(Circles,ROIOuter,8.5)
hal.erosion_circle(Circles,ROIInner,8.5)
hal.difference(ROIOuter,ROIInner,ROI)
hal.union1(ROI,ROIEdges)
.判断开始 (hal.是否为真(visualization))
hal.dev_display(Image)
hal.dev_set_draw("margin")
hal.dev_set_color("green")
hal.dev_display(ROIEdges)
hal.stop()
.判断结束

' 
hal.reduce_domain(Image,ROIEdges,RimReduced)
hal.edges_sub_pix(RimReduced,Edges,"canny",2,20,40)
' 
hal.select_contours_xld(Edges,EdgesLarge,"contour_length",200,300,0,0)
hal.count_obj(EdgesLarge,NumberLarge)
hal.fit_ellipse_contour_xld(EdgesLarge,"ftukey",-1,2,0,200,3,2,Row,Column,Phi,Ra,Rb,StartPhi,EndPhi,PointOrder)
hal.gen_ellipse_contour_xld(EllipseContoursLarge,Row,Column,hal.gen_tuple_const(NumberLarge,0),Ra,Rb,hal.gen_tuple_const(NumberLarge,0),hal.gen_tuple_const(NumberLarge,hal.rad(360)),hal.gen_tuple_const(NumberLarge,"positive"),1.5)
' 
hal.select_contours_xld(Edges,EdgesSmall,"contour_length",100,200,0,0)
hal.count_obj(EdgesSmall,NumberSmall)
hal.fit_ellipse_contour_xld(EdgesSmall,"ftukey",-1,2,0,200,3,2,Row,Column,Phi,Ra,Rb,StartPhi,EndPhi,PointOrder)
hal.gen_ellipse_contour_xld(EllipseContoursSmall,Row,Column,hal.gen_tuple_const(NumberSmall,0),Ra,Rb,hal.gen_tuple_const(NumberSmall,0),hal.gen_tuple_const(NumberSmall,hal.rad(360)),hal.gen_tuple_const(NumberSmall,"positive"),1.5)
' 
.判断开始 (hal.是否为真(visualization))
hal.dev_display(Image)
hal.dev_set_color("green")
hal.dev_display(EllipseContoursLarge)
hal.dev_set_color("blue")
hal.dev_display(EllipseContoursSmall)
hal.stop()
.判断结束

return()

.子程序 p_cluster_normals
.参数 Pose1, tuple
.参数 Pose2, tuple
.参数 CenterNormal1, tuple
.参数 CenterNormal2, tuple
.参数 ClusterP1, tuple, 参考
.参数 ClusterP2, tuple, 参考
.参数 ClusterCN1, tuple, 参考
.参数 ClusterCN2, tuple, 参考
.局部变量 DeviationC1, 视觉元组
.局部变量 DeviationC2, 视觉元组
.局部变量 Help, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Indices, 视觉元组
.局部变量 N1, 视觉元组
.局部变量 N1NA, 视觉元组
.局部变量 N1NB, 视觉元组
.局部变量 N2, 视觉元组
.局部变量 N2NA, 视觉元组
.局部变量 N2NB, 视觉元组
.局部变量 NA, 视觉元组
.局部变量 NB, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 idx, 视觉元组

hal.赋值(Number,hal.除(hal.取元素总数(CenterNormal1),6))
hal.赋值(ClusterP1,hal.取元素范围(Pose1,0,6))
hal.赋值(ClusterP2,hal.取元素范围(Pose2,0,6))
hal.赋值(ClusterCN1,hal.取元素范围(CenterNormal1,0,5))
hal.赋值(ClusterCN2,hal.取元素范围(CenterNormal2,0,5))
hal.赋值(NA,hal.取元素范围(ClusterCN1,3,5))
hal.赋值(NB,hal.取元素范围(ClusterCN2,3,5))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, hal.减(Number,1)))
hal.赋值(N1,hal.取元素范围(CenterNormal1,hal.加(hal.乘(I,6),3),hal.加(hal.乘(I,6),5)))
hal.赋值(N2,hal.取元素范围(CenterNormal2,hal.加(hal.乘(I,6),3),hal.加(hal.乘(I,6),5)))
hal.赋值(N1NA,hal.sum(hal.乘(N1,NA)))
hal.赋值(N1NB,hal.sum(hal.乘(N1,NB)))
hal.赋值(N2NA,hal.sum(hal.乘(N2,NA)))
hal.赋值(N2NB,hal.sum(hal.乘(N2,NB)))
hal.tuple_sort_index(hal.乘(hal.创建元组(N1NA,N1NB,N2NA,N2NB),-1),Indices)
.判断开始 (hal.或(hal.等于(hal.取元素(Indices,0),0),hal.等于(hal.取元素(Indices,0),3)))
hal.赋值(ClusterP1,hal.创建元组(ClusterP1,hal.取元素范围(Pose1,hal.乘(I,7),hal.加(hal.乘(I,7),6))))
hal.赋值(ClusterP2,hal.创建元组(ClusterP2,hal.取元素范围(Pose2,hal.乘(I,7),hal.加(hal.乘(I,7),6))))
hal.赋值(ClusterCN1,hal.创建元组(ClusterCN1,hal.取元素范围(CenterNormal1,hal.乘(I,6),hal.加(hal.乘(I,6),5))))
hal.赋值(ClusterCN2,hal.创建元组(ClusterCN2,hal.取元素范围(CenterNormal2,hal.乘(I,6),hal.加(hal.乘(I,6),5))))
.默认
hal.赋值(ClusterP1,hal.创建元组(ClusterP1,hal.取元素范围(Pose2,hal.乘(I,7),hal.加(hal.乘(I,7),6))))
hal.赋值(ClusterP2,hal.创建元组(ClusterP2,hal.取元素范围(Pose1,hal.乘(I,7),hal.加(hal.乘(I,7),6))))
hal.赋值(ClusterCN1,hal.创建元组(ClusterCN1,hal.取元素范围(CenterNormal2,hal.乘(I,6),hal.加(hal.乘(I,6),5))))
hal.赋值(ClusterCN2,hal.创建元组(ClusterCN2,hal.取元素范围(CenterNormal1,hal.乘(I,6),hal.加(hal.乘(I,6),5))))
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
hal.赋值(idx,hal.创建元组())
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(Number,1)))
hal.赋值(idx,hal.创建元组(idx,hal.加(hal.乘(I,6),3)))
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.赋值(DeviationC1,hal.加(hal.加(hal.deviation(hal.subset(ClusterCN1,idx)),hal.deviation(hal.subset(ClusterCN1,hal.加(idx,1)))),hal.deviation(hal.subset(ClusterCN1,hal.加(idx,2)))))
hal.赋值(DeviationC2,hal.加(hal.加(hal.deviation(hal.subset(ClusterCN2,idx)),hal.deviation(hal.subset(ClusterCN2,hal.加(idx,1)))),hal.deviation(hal.subset(ClusterCN2,hal.加(idx,2)))))
.判断开始 (hal.小于(DeviationC2,DeviationC1))
hal.赋值(Help,ClusterP1)
hal.赋值(ClusterP1,ClusterP2)
hal.赋值(ClusterP2,Help)
hal.赋值(Help,ClusterCN1)
hal.赋值(ClusterCN1,ClusterCN2)
hal.赋值(ClusterCN2,Help)
.判断结束

return()

.子程序 p_do_color_fuses
.局部变量 Blue, 视觉对象
.局部变量 Column1, 视觉元组
.局部变量 CurrentFuse, 视觉对象
.局部变量 CurrentFuseConn, 视觉对象
.局部变量 CurrentFuseFill, 视觉对象
.局部变量 CurrentFuseSel, 视觉对象
.局部变量 Fuse, 视觉元组
.局部变量 FuseArea, 视觉元组
.局部变量 FuseColors, 视觉元组
.局部变量 FuseTypes, 视觉元组
.局部变量 Green, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 Hue, 视觉对象
.局部变量 HueRanges, 视觉元组
.局部变量 HueSaturated, 视觉对象
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 Intensity, 视觉对象
.局部变量 Red, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Saturated, 视觉对象
.局部变量 Saturation, 视觉对象
.局部变量 WH, 视觉元组
.局部变量 Width, 视觉元组

' ****
' step: set up fuse properties and hue ranges
' ****
hal.赋值(FuseColors,hal.创建元组("Orange","Red","Blue","Yellow","Green"))
hal.赋值(FuseTypes,hal.创建元组(5,10,15,20,30))
' HueRanges: Orange 10-30, Red 0-10...
hal.赋值(HueRanges,hal.创建元组(10,30,0,10,125,162,30,64,96,128))
hal.dev_close_window()
hal.dev_open_window(0,0,640,hal.除(hal.乘(600,到小数(640.)),800),"black",WH)
p_set_font(hal.克隆元组(WH))
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, 4))
'     ****
'     step: acquire image
'     ****
hal.read_image(Image,hal.加("color/color_fuses_",hal.文本格式化(Index,".02")))
hal.get_image_size(Image,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Image)
'     ****
'     step: extract saturated hues
'     ****
hal.decompose3(Image,Red,Green,Blue)
hal.trans_from_rgb(Red,Green,Blue,Hue,Saturation,Intensity,"hsv")
hal.threshold(Saturation,Saturated,60,255)
hal.reduce_domain(Hue,Saturated,HueSaturated)
hal.disp_message(WH,"Result of the color segmentation:","window",10,10,"black","true")
hal.赋值 (Fuse, 0)
.判断循环首 (hal.小于等于 (Fuse, hal.减(hal.取元素总数(FuseTypes),1)))
'         ****
'         step: classify specific fuse
'         ****
hal.threshold(HueSaturated,CurrentFuse,hal.取元素(HueRanges,hal.乘(Fuse,2)),hal.取元素(HueRanges,hal.加(hal.乘(Fuse,2),1)))
hal.connection(CurrentFuse,CurrentFuseConn)
hal.fill_up(CurrentFuseConn,CurrentFuseFill)
hal.select_shape(CurrentFuseFill,CurrentFuseSel,"area","and",6000,20000)
hal.area_center(CurrentFuseSel,FuseArea,Row1,Column1)
hal.dev_set_color("magenta")
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(FuseArea),1)))
hal.disp_message(WH,hal.创建元组(hal.取元素(FuseColors,Fuse),hal.加(hal.加("(",hal.取元素(FuseTypes,Fuse))," A)")),"image",hal.加(hal.取元素(Row1,I),60),hal.减(hal.取元素(Column1,I),70),"black","true")
I ＝ hal.加 (I, 1)
.判断循环尾 ()
Fuse ＝ hal.加 (Fuse, 1)
.判断循环尾 ()
p_disp_pause_sign(hal.克隆元组(WH),hal.创建元组(2))
hal.wait_seconds(3)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()

.子程序 p_do_textline_orientation
.局部变量 Column1, 视觉元组
.局部变量 Column11, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 Column21, 视觉元组
.局部变量 ConnectedDots, 视觉对象
.局部变量 ConnectedLines, 视觉对象
.局部变量 ConnectedRegions, 视觉对象
.局部变量 ConnectedRegions2, 视觉对象
.局部变量 Deviation, 视觉元组
.局部变量 ElementOfLines, 视觉对象
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageDots, 视觉对象
.局部变量 ImageRotate, 视觉对象
.局部变量 ImageScaleMax, 视觉对象
.局部变量 J, 视觉元组
.局部变量 Mean, 视觉元组
.局部变量 OrientationAngle, 视觉元组
.局部变量 Rectangle1, 视觉对象
.局部变量 RectangularShape, 视觉对象
.局部变量 Region, 视觉对象
.局部变量 RegionClosing, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionDots, 视觉对象
.局部变量 RegionThresh, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 RegionUnion3, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row11, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 Row21, 视觉元组
.局部变量 SelectedDots, 视觉对象
.局部变量 SelectedDotsOpening, 视觉对象
.局部变量 SelectedLines, 视觉对象
.局部变量 SelectedRegions, 视觉对象
.局部变量 WindowHandle, 视觉元组

' 
hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
hal.赋值(J,1)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 25))
hal.read_image(Image,hal.加("dot_print_rotated/dot_print_rotated_",hal.文本格式化(J,"02d")))
'     
.判断开始 (hal.小于(I,5))
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Determine text line orientation automatically","window",12,12,"black","true")
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

'*     wait_seconds (1)
hal.text_line_orientation(Image,Image,50,hal.rad(-30),hal.rad(30),OrientationAngle)
hal.rotate_image(Image,ImageRotate,hal.乘(hal.除(-hal.取元组小数(OrientationAngle,),hal.rad(180)),180),"constant")
'     
hal.dots_image(ImageRotate,ImageDots,3,"dark",2)
hal.scale_image_max(ImageDots,ImageScaleMax)
hal.intensity(ImageRotate,ImageRotate,Mean,Deviation)
hal.threshold(ImageScaleMax,RegionThresh,hal.减(Mean,35),255)
hal.connection(RegionThresh,ConnectedDots)
hal.select_shape(ConnectedDots,SelectedDots,"area","and",8,1000)
hal.opening_circle(SelectedDots,SelectedDotsOpening,1.5)
hal.union1(SelectedDotsOpening,Region)
hal.closing_circle(Region,RegionClosing,9.5)
hal.connection(RegionClosing,ConnectedRegions)
'     Connect split parts
hal.smallest_rectangle1(ConnectedRegions,Row11,Column11,Row21,Column21)
hal.gen_rectangle1(Rectangle1,Row11,Column11,Row21,Column21)
hal.union1(Rectangle1,RegionUnion3)
hal.connection(RegionUnion3,ConnectedRegions2)
hal.select_shape(ConnectedRegions2,SelectedRegions,hal.创建元组("area","height","width"),"and",hal.创建元组(1000,30,20),hal.创建元组(3200,70,70))
'     Get rectangular shape
hal.smallest_rectangle1(SelectedRegions,Row1,Column1,Row2,Column2)
hal.gen_rectangle1(RectangularShape,Row1,Column1,Row2,Column2)
'     Build lines
hal.union1(SelectedRegions,RegionUnion)
hal.dilation_rectangle1(RegionUnion,RegionDilation,50,1)
hal.connection(RegionDilation,ConnectedLines)
hal.select_shape(ConnectedLines,SelectedLines,"area","and",10000,99999)
'     Element of lines
hal.intersection(SelectedLines,RectangularShape,ElementOfLines)
hal.intersection(ElementOfLines,SelectedDotsOpening,RegionDots)
hal.dev_clear_window()
hal.dev_display(ImageRotate)
hal.disp_message(WindowHandle,"Rotation corrected","window",-1,-1,"black","true")
'*     dev_set_colored (12)
hal.dev_set_draw("margin")
hal.dev_set_color("blue")
hal.dev_display(ElementOfLines)
hal.dev_set_color("green")
hal.dev_set_draw("fill")
hal.dev_display(RegionDots)
.判断开始 (hal.小于(I,5))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

hal.赋值(J,hal.加(J,1))
.判断开始 (hal.大于(J,5))
hal.赋值(J,1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(2)
return()

.子程序 p_do_novelty_detection_gmm
.局部变量 Centers, 视觉元组
.局部变量 ClassifierFileExists, 视觉元组
.局部变量 Correct, 视觉对象
.局部变量 Errors, 视觉对象
.局部变量 ErrorsClosing, 视觉对象
.局部变量 ErrorsConnected, 视觉对象
.局部变量 ErrorsOpening, 视觉对象
.局部变量 FinalErrors, 视觉对象
.局部变量 GMMClassifierFile, 视觉元组
.局部变量 GMMHandle, 视觉元组
.局部变量 HEXAMPLES, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageTexture, 视觉对象
.局部变量 ImageTextureReduced, 视觉对象
.局部变量 ImageZoomed, 视觉对象
.局部变量 Indices, 视觉元组
.局部变量 Iter, 视觉元组
.局部变量 J, 视觉元组
.局部变量 NumErrors, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' This example program shows you how to use the GMM classifier for novelty
' detection to perform a web inspection task.  To perform the novelty detection,
' all pixels belonging to the single trained class are computed, and are then
' subtracted from the classification ROI to extract the erroneous pixels.  For
' the web inspection task, the GMM can consequently be used to detect
' textures that do not correspond to the texture of the trained good objects.
hal.dev_update_off()
hal.read_image(Image,"plastic_mesh/plastic_mesh_01")
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,Width,Height,"black",WindowHandle)
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Novelty detection with GMM classifier","window",12,12,"black","true")
' The texture filters used for the classification will return artifacts at the image
' borders because the images of the plastic mesh to be inspected do not
' contain an integer number of mesh cells.  Because this would lead to wrongly
' detected errors at the image borders, we must exclude the area close to the
' image border from the training and classification.  This is done with the following
' rectangle.  Note that the image is later scaled down by a factor of two.
hal.gen_rectangle1(Rectangle,10,10,hal.减(hal.除(Height,2),11),hal.减(hal.除(Width,2),11))
' Create the GMM classifier.
' Load pretrained classifier if present
hal.get_system("example_dir",HEXAMPLES)
hal.赋值(GMMClassifierFile,hal.加(HEXAMPLES,"/hdevelop/Segmentation/Classification/novelty_detection.gmm"))
hal.file_exists(GMMClassifierFile,ClassifierFileExists)
.判断开始 (hal.是否为真(ClassifierFileExists))
'     Read training data of GMM
hal.disp_message(WindowHandle,"Load GMM Classifier...","window",45,50,"black","true")
hal.read_class_gmm(GMMClassifierFile,GMMHandle)
.默认
'     Train GMM classifier
hal.disp_message(WindowHandle,"Train GMM Classifier...","window",45,50,"black","true")
hal.create_class_gmm(5,1,hal.创建元组(1,5),"spherical","normalization",5,42,GMMHandle)
'     The training is based on five images that contain no errors.
hal.dev_set_color("red")
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 5))
hal.read_image(Image,hal.加("plastic_mesh/plastic_mesh_",hal.文本格式化(J,"02")))
'         The images are zoomed down because the resolution of the mesh is very
'         high.  This saves a large amount of processing time.
hal.zoom_image_factor(Image,ImageZoomed,0.5,0.5,"constant")
'         Generate the texture image.
gen_texture_image(hal.克隆对象(ImageZoomed),ImageTexture)
'         Add the samples to the classifier.
hal.add_samples_image_class_gmm(ImageTexture,Rectangle,GMMHandle,到小数(2.0))
J ＝ hal.加 (J, 1)
.判断循环尾 ()
'     Train classifier
hal.train_class_gmm(GMMHandle,1000,0.001,"training",1e-04,Centers,Iter)
.判断结束

hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
hal.wait_seconds(1.5)
hal.赋值(Indices,hal.创建元组(4,5,6,7,2,8,9,10,11,12,1,13,14,4,5,6,7,2,8,9,10,11,12,1,13,14))
' Now detect errors in the plastic meshes.
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(Indices),1)))
hal.read_image(Image,hal.加("plastic_mesh/plastic_mesh_",hal.文本格式化(hal.取元素(Indices,J),"02")))
hal.zoom_image_factor(Image,ImageZoomed,0.5,0.5,"constant")
hal.get_image_size(ImageZoomed,Width,Height)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
gen_texture_image(hal.克隆对象(ImageZoomed),ImageTexture)
hal.reduce_domain(ImageTexture,Rectangle,ImageTextureReduced)
'     Classify samples belonging to the trained class with the GMM.
hal.classify_image_class_gmm(ImageTextureReduced,Correct,GMMHandle,0.001)
'     Subtract them from the ROI to obtain the texture errors.
hal.difference(Rectangle,Correct,Errors)
'     Postprocess the returned raw errors to remove insignificant parts of the
'     detected errors.
hal.opening_circle(Errors,ErrorsOpening,3.5)
hal.closing_circle(ErrorsOpening,ErrorsClosing,10.5)
hal.connection(ErrorsClosing,ErrorsConnected)
hal.select_shape(ErrorsConnected,FinalErrors,"area","and",300,1000000)
hal.count_obj(FinalErrors,NumErrors)
hal.dev_display(ImageZoomed)
.判断开始 (hal.大于(NumErrors,0))
hal.dev_set_color("yellow")
hal.dev_display(Rectangle)
hal.dev_set_color("red")
hal.dev_display(FinalErrors)
.默认
hal.dev_set_color("green")
hal.dev_display(Rectangle)
.判断结束

hal.disp_message(WindowHandle,"Detect Errors in a Mesh","window",12,12,"black","true")
.判断开始 (hal.大于(NumErrors,0))
hal.disp_message(WindowHandle,"Mesh not OK","window",45,12,"white","red")
.默认
hal.disp_message(WindowHandle,"Mesh OK","window",45,12,"white","forest green")
.判断结束

.判断开始 (hal.小于(J,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.wait_seconds(2)
hal.clear_class_gmm(GMMHandle)
return()

.子程序 gen_texture_image
.参数 Image, obj
.参数 ImageTexture, obj, 参考
.局部变量 ImageEE, 视觉对象
.局部变量 ImageEL, 视觉对象
.局部变量 ImageES, 视觉对象
.局部变量 ImageLE, 视觉对象
.局部变量 ImageLaws, 视觉对象
.局部变量 ImageSE, 视觉对象

' The texture image is a five-channel image that contains the result of applying
' five different Laws filters, which basically correspond to first and second
' derivatives, and smoothing them sufficiently.
hal.texture_laws(Image,ImageEL,"el",5,5)
hal.texture_laws(Image,ImageLE,"le",5,5)
hal.texture_laws(Image,ImageES,"es",1,5)
hal.texture_laws(Image,ImageSE,"se",1,5)
hal.texture_laws(Image,ImageEE,"ee",2,5)
hal.compose5(ImageEL,ImageLE,ImageES,ImageSE,ImageEE,ImageLaws)
hal.smooth_image(ImageLaws,ImageTexture,"gauss",5)
return()

.子程序 p_do_optical_flow_bicycle
.局部变量 Alpha, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 CCenterNew, 视觉元组
.局部变量 Col, 视觉对象
.局部变量 ConnectedRegions, 视觉对象
.局部变量 ConvexHullregion, 视觉对象
.局部变量 Deviation, 视觉元组
.局部变量 Deviation1, 视觉元组
.局部变量 EmptyRegion, 视觉元组
.局部变量 GrayImage1ROI, 视觉对象
.局部变量 I, 视觉元组
.局部变量 ImHeight, 视觉元组
.局部变量 ImWidth, 视觉元组
.局部变量 Image1, 视觉对象
.局部变量 Image1ROI, 视觉对象
.局部变量 Image2, 视觉对象
.局部变量 Image2ROI, 视觉对象
.局部变量 LengthImage, 视觉对象
.局部变量 Max, 视觉元组
.局部变量 MeanCol, 视觉元组
.局部变量 MeanL, 视觉元组
.局部变量 MeanLength, 视觉元组
.局部变量 MeanRow, 视觉元组
.局部变量 Min, 视觉元组
.局部变量 NoObjectResult, 视觉元组
.局部变量 RCenterNew, 视觉元组
.局部变量 ROI, 视觉对象
.局部变量 Range, 视觉元组
.局部变量 RegionMovement, 视觉对象
.局部变量 RegionMovementInROI, 视觉对象
.局部变量 RegionROI, 视觉对象
.局部变量 Row, 视觉对象
.局部变量 StoreEmpty, 视觉元组
.局部变量 VectorField, 视觉对象
.局部变量 VectorReduced, 视觉对象
.局部变量 WindowHandle, 视觉元组

' 
' This example demonstrates the use of the optical flow for
' the detection of moving objects in an image sequence.
' The region of interest is analyzed to detect moving objects.
' If a moving object is detected, the exit gate is opened automatically.
' 
hal.dev_update_off()
hal.get_system("no_object_result",NoObjectResult)
hal.get_system("empty_region_result",EmptyRegion)
hal.get_system("store_empty_region",StoreEmpty)
hal.set_system("no_object_result","true")
hal.set_system("empty_region_result","true")
hal.set_system("store_empty_region","true")
' 
' Generate ROI
hal.gen_contour_polygon_xld(ROI,hal.创建元组(0,0,283,348,479,479),hal.创建元组(0,379,379,434,639,0))
hal.gen_region_contour_xld(ROI,RegionROI,"filled")
' 
' Initialize output window
hal.read_image(Image1,"bicycle/bicycle_01")
hal.get_image_size(Image1,ImWidth,ImHeight)
hal.dev_close_window()
hal.dev_open_window(0,0,ImWidth,ImHeight,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(hal.除(ImHeight,2),1),hal.减(hal.除(ImWidth,2),1))
p_set_font(hal.克隆元组(WindowHandle))
' 
hal.dev_set_draw("margin")
' Prepare first image for calculation of optical flow
hal.reduce_domain(Image1,RegionROI,GrayImage1ROI)
hal.zoom_region(RegionROI,RegionROI,0.5,0.5)
hal.zoom_image_factor(Image1,Image1,0.5,0.5,"constant")
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 27))
hal.read_image(Image2,hal.加("bicycle/bicycle_",hal.文本格式化(I,".2")))
'     
'     Zoom images for calculation of optical flow
hal.zoom_image_factor(Image2,Image2,0.5,0.5,"constant")
hal.reduce_domain(Image2,RegionROI,Image2ROI)
hal.reduce_domain(Image1,RegionROI,Image1ROI)
'     
hal.optical_flow_mg(Image1ROI,Image2ROI,VectorField,"fdrig",0.8,1,10,5,hal.创建元组("default_parameters","warp_zoom_factor"),hal.创建元组("fast",0.8))
hal.vector_field_length(VectorField,LengthImage,"squared_length")
'     
'     Segment regions with moving objects in the defined ROI
hal.min_max_gray(RegionROI,LengthImage,0.1,Min,Max,Range)
.判断开始 (hal.小于(Max,2))
I ＝ hal.加 (I, 1)
到循环尾 ()
.判断结束

hal.threshold(LengthImage,RegionMovement,2,Max)
hal.connection(RegionMovement,ConnectedRegions)
'     Select largest moving region
hal.select_shape_std(ConnectedRegions,RegionMovement,"max_area",70)
hal.area_center(RegionMovement,Area,RCenterNew,CCenterNew)
.判断开始 (hal.大于(Area,0))
hal.shape_trans(RegionMovement,ConvexHullregion,"convex")
hal.intersection(RegionROI,ConvexHullregion,RegionMovementInROI)
hal.reduce_domain(VectorField,ConvexHullregion,VectorReduced)
hal.vector_field_to_real(VectorReduced,Row,Col)
'         
'         Estimate the movement direction and the speed
hal.intensity(RegionMovementInROI,Row,MeanRow,Deviation)
hal.intensity(RegionMovementInROI,Col,MeanCol,Deviation1)
hal.赋值(MeanLength,hal.sqrt(hal.加(hal.乘(MeanRow,MeanRow),hal.乘(MeanCol,MeanCol))))
hal.赋值(Alpha,hal.atan(hal.除(MeanRow,MeanCol)))
'         
'         Display results
hal.dev_display(Image2)
'         Display region of interest
hal.dev_set_line_width(3)
hal.dev_set_color("green")
hal.dev_display(RegionROI)
hal.disp_message(WindowHandle,"Estimate moving direction and speed","window",-1,-1,"black","true")
hal.dev_set_line_width(1)
hal.dev_set_color("yellow")
hal.dev_display(VectorReduced)
'         Display region of moving object in the region of interest
hal.dev_set_line_width(3)
hal.dev_set_color("magenta")
hal.dev_display(RegionMovementInROI)
hal.disp_arrow(WindowHandle,RCenterNew,CCenterNew,hal.加(RCenterNew,hal.乘(MeanLength,hal.sin(Alpha))),hal.加(CCenterNew,hal.乘(MeanLength,hal.cos(Alpha))),1)
.默认
hal.dev_display(Image2)
hal.赋值(MeanL,0)
hal.disp_message(WindowHandle,"Estimate moving direction and speed","window",-1,-1,"black","true")
.判断结束

'     
hal.copy_obj(Image2,Image1,1,1)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(2)
hal.set_system("no_object_result",NoObjectResult)
hal.set_system("empty_region_result",EmptyRegion)
hal.set_system("store_empty_region",StoreEmpty)
return()

.子程序 p_do_variation_model_illumination
.局部变量 Area, 视觉元组
.局部变量 BackgroundGVModel, 视觉元组
.局部变量 ColumnModel, 视觉元组
.局部变量 ForegroundGVModel, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 HomMat2DIdentity, 视觉元组
.局部变量 HomMat2DTranslate, 视觉元组
.局部变量 I, 视觉元组
.局部变量 ImageReduced, 视觉对象
.局部变量 J, 视觉元组
.局部变量 ModelContours, 视觉对象
.局部变量 ModelContoursAffinTrans, 视觉对象
.局部变量 ModelID, 视觉元组
.局部变量 ModelImage, 视觉对象
.局部变量 RegionBackground, 视觉对象
.局部变量 RegionForeground, 视觉对象
.局部变量 RegionROI, 视觉对象
.局部变量 RowModel, 视觉元组
.局部变量 VarImage, 视觉对象
.局部变量 VariationID, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 rImage, 视觉对象

' 
' This example demonstrates the print inspection using
' a variation model. The variation model is trained
' using a single model image. Before applying the print inspection,
' the images are scaled to the same gray value range like the model.
' 
hal.dev_update_off()
' 
' Read model image and init visualization
hal.read_image(ModelImage,"cap_illumination/cap_illumination_01")
hal.get_image_size(ModelImage,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,hal.除(Width,2),hal.除(Height,2),"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
' Segment model region
hal.dev_set_window(WindowHandle)
hal.dev_display(ModelImage)
hal.disp_message(WindowHandle,"Generate model...","window",12,12,"black","true")
get_model_region(hal.克隆对象(ModelImage),RegionROI,ImageReduced)
hal.area_center(RegionROI,Area,RowModel,ColumnModel)
' 
' Create model for shape-based-matching
hal.create_scaled_shape_model(ImageReduced,"auto",0,hal.rad(360),"auto",0.8,1.2,"auto","auto","use_polarity","auto","auto",ModelID)
hal.get_shape_model_contours(ModelContours,ModelID,1)
' Transform model contours from the original position for visualization
hal.hom_mat2d_identity(HomMat2DIdentity)
hal.hom_mat2d_translate(HomMat2DIdentity,RowModel,ColumnModel,HomMat2DTranslate)
hal.affine_trans_contour_xld(ModelContours,ModelContoursAffinTrans,HomMat2DTranslate)
' 
' Create variation model for print inspection
hal.create_variation_model(Width,Height,"byte","direct",VariationID)
' Generate variation image
hal.sobel_amp(ModelImage,VarImage,"sum_abs",5)
hal.prepare_direct_variation_model(ModelImage,VarImage,VariationID,hal.创建元组(20,25),hal.创建元组(1.6,1.6))
' 
' Get gray value range of the variation model
get_grayval_range(hal.克隆对象(ModelImage),hal.克隆对象(RegionROI),RegionForeground,RegionBackground,BackgroundGVModel,ForegroundGVModel)
' 
hal.wait_seconds(1)
' 
' Perform print inspection
hal.赋值(J,1)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 30))
hal.read_image(rImage,hal.加("cap_illumination/cap_illumination_",hal.文本格式化(J,".2")))
inspect_cap(hal.克隆对象(rImage),hal.克隆对象(RegionROI),hal.克隆元组(WindowHandle),hal.克隆元组(ModelID),hal.克隆元组(VariationID),hal.克隆元组(RowModel),hal.克隆元组(ColumnModel),hal.克隆元组(BackgroundGVModel),hal.克隆元组(ForegroundGVModel))
.判断开始 (hal.小于(I,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

hal.赋值(J,hal.加(J,1))
.判断开始 (hal.大于(J,9))
hal.赋值(J,1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
hal.wait_seconds(2)
hal.clear_shape_model(ModelID)
hal.clear_variation_model(VariationID)
return()

.子程序 get_grayval_range
.参数 Image, obj
.参数 RegionROI, obj
.参数 RegionForeground, obj, 参考
.参数 RegionBackground, obj, 参考
.参数 BackgroundGVal, tuple, 参考
.参数 ForegroundGVal, tuple, 参考
.局部变量 DeviationBG, 视觉元组
.局部变量 DeviationFG, 视觉元组
.局部变量 ImageReduced, 视觉对象
.局部变量 UsedThreshold, 视觉元组

hal.reduce_domain(Image,RegionROI,ImageReduced)
hal.binary_threshold(ImageReduced,RegionBackground,"max_separability","dark",UsedThreshold)
hal.difference(RegionROI,RegionBackground,RegionForeground)
hal.intensity(RegionForeground,Image,ForegroundGVal,DeviationFG)
hal.intensity(RegionBackground,Image,BackgroundGVal,DeviationBG)
return()

.子程序 get_model_region
.参数 rImage, obj
.参数 RegionROI, obj, 参考
.参数 ImageReduced, obj, 参考
.局部变量 BrightRegion, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 LabelRectangle, 视觉对象
.局部变量 LabelRegion, 视觉对象
.局部变量 Radius, 视觉元组
.局部变量 Region, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionIntersection, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 UsedThreshold, 视觉元组

' 
' Segment label on the cap
hal.binary_threshold(rImage,BrightRegion,"max_separability","light",UsedThreshold)
hal.dilation_circle(BrightRegion,RegionDilation,1.5)
hal.connection(RegionDilation,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",100,99999)
hal.union1(SelectedRegions,LabelRegion)
hal.smallest_circle(LabelRegion,Row,Column,Radius)
hal.smallest_rectangle1(LabelRegion,Row1,Column1,Row2,Column2)
' 
' Define model region
hal.gen_circle(Region,Row,Column,Radius)
hal.gen_rectangle1(LabelRectangle,Row1,Column1,Row2,Column2)
hal.intersection(Region,LabelRectangle,RegionIntersection)
hal.dilation_circle(RegionIntersection,RegionROI,5.5)
hal.reduce_domain(rImage,RegionROI,ImageReduced)
return()

.子程序 inspect_cap
.参数 rImage, obj
.参数 RegionROI, obj
.参数 WindowHandle, tuple
.参数 ModelID, tuple
.参数 VariationID, tuple
.参数 RowModel, tuple
.参数 ColumnModel, tuple
.参数 BackgroundGVModel, tuple
.参数 ForegroundGVModel, tuple
.局部变量 Add, 视觉元组
.局部变量 Angle, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 BackgroundImage, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ColumnEllipse, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 DefectRegionEnlarged, 视觉对象
.局部变量 DefectRegions, 视觉对象
.局部变量 DefectRegionsClosing, 视觉对象
.局部变量 DefectRegionsTrans, 视觉对象
.局部变量 Ellipse, 视觉对象
.局部变量 EndSeconds, 视觉元组
.局部变量 ForegroundImage, 视觉元组
.局部变量 HomMat2DContour, 视觉元组
.局部变量 HomMat2DImage, 视觉元组
.局部变量 HomMat2DInvert, 视觉元组
.局部变量 I, 视觉元组
.局部变量 ImageAffinTrans, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImageScaled, 视觉对象
.局部变量 ModelContours, 视觉对象
.局部变量 ModelContoursTrans, 视觉对象
.局部变量 Mult, 视觉元组
.局部变量 NumberRegionDiff, 视觉元组
.局部变量 Phi, 视觉元组
.局部变量 Ra, 视觉元组
.局部变量 Rb, 视觉元组
.局部变量 RegionBackgroundImage, 视觉对象
.局部变量 RegionClosing, 视觉对象
.局部变量 RegionDiff, 视觉对象
.局部变量 RegionDiffSelected, 视觉对象
.局部变量 RegionForegroundImage, 视觉对象
.局部变量 RegionOpening, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 RowEllipse, 视觉元组
.局部变量 Scale, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 StartSeconds, 视觉元组
.局部变量 TimeObjSearch, 视觉元组
.局部变量 TimePrintInspect, 视觉元组

' 
' Find shape model in the input image
hal.count_seconds(StartSeconds)
hal.find_scaled_shape_model(rImage,ModelID,0,hal.rad(360),0.98,1.02,0.4,1,1,"least_squares_high",hal.创建元组(5,3),0.9,Row,Column,Angle,Scale,Score)
hal.count_seconds(EndSeconds)
hal.赋值(TimeObjSearch,hal.减(EndSeconds,StartSeconds))
' 
hal.get_shape_model_contours(ModelContours,ModelID,1)
' 
.判断开始 (hal.大于(hal.取元素总数(Row),0))
'     
'     Align the model region and the found label region
hal.vector_angle_to_rigid(hal.取元素(Row,0),hal.取元素(Column,0),Angle,hal.取元素(RowModel,0),hal.取元素(ColumnModel,0),0,HomMat2DImage)
hal.affine_trans_image(rImage,ImageAffinTrans,HomMat2DImage,"constant","false")
get_grayval_range(hal.克隆对象(ImageAffinTrans),hal.克隆对象(RegionROI),RegionForegroundImage,RegionBackgroundImage,BackgroundImage,ForegroundImage)
'     
'     Scale image to the model's gray value range
hal.赋值(Mult,hal.除(hal.减(ForegroundGVModel,BackgroundGVModel),hal.减(ForegroundImage,BackgroundImage)))
hal.赋值(Add,hal.减(ForegroundGVModel,hal.乘(Mult,ForegroundImage)))
'     Transform the contours of the models for the visualization
hal.vector_angle_to_rigid(0,0,0,hal.取元素(Row,0),hal.取元素(Column,0),Angle,HomMat2DContour)
hal.affine_trans_contour_xld(ModelContours,ModelContoursTrans,HomMat2DContour)
hal.reduce_domain(ImageAffinTrans,RegionROI,ImageReduced)
hal.scale_image(ImageReduced,ImageScaled,Mult,Add)
'     
'     Print Inspection
hal.count_seconds(StartSeconds)
hal.compare_ext_variation_model(ImageScaled,RegionDiff,VariationID,"light_dark")
hal.count_seconds(EndSeconds)
'     Analyze bright and dark defect regions
hal.dev_display(rImage)
hal.count_obj(RegionDiff,NumberRegionDiff)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, NumberRegionDiff))
hal.select_obj(RegionDiff,RegionDiffSelected,I)
hal.opening_circle(RegionDiffSelected,RegionOpening,2.5)
hal.connection(RegionOpening,ConnectedRegions)
hal.select_shape(ConnectedRegions,DefectRegions,"height","and",20,99999)
'         
'         Transform regions to the original position in the input image
hal.hom_mat2d_invert(HomMat2DImage,HomMat2DInvert)
hal.affine_trans_region(DefectRegions,DefectRegionsTrans,HomMat2DInvert,"nearest_neighbor")
hal.closing_circle(DefectRegionsTrans,DefectRegionsClosing,1.5)
'         
'         Display bright and dark defects using different colors
hal.dev_set_line_width(2)
hal.dev_set_draw("margin")
.判断开始 (hal.等于(I,1))
hal.dev_set_color("red")
.默认
hal.dev_set_color("orange")
.判断结束

hal.dev_display(DefectRegionsClosing)
'         
'         Emphasize defect regions
hal.dev_set_color("magenta")
hal.dev_set_draw("margin")
hal.union1(DefectRegionsClosing,RegionUnion)
hal.closing_circle(RegionUnion,RegionClosing,10)
hal.connection(RegionClosing,DefectRegionEnlarged)
hal.elliptic_axis(DefectRegionEnlarged,Ra,Rb,Phi)
.判断开始 (hal.是否为真(hal.取元素总数(Phi)))
hal.area_center(DefectRegionEnlarged,Area,RowEllipse,ColumnEllipse)
hal.gen_ellipse(Ellipse,RowEllipse,ColumnEllipse,Phi,hal.乘(Ra,2),hal.乘(Rb,2))
hal.dev_display(Ellipse)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.dev_set_line_width(1)
hal.dev_set_color("green")
hal.dev_display(ModelContoursTrans)
'     
hal.赋值(TimePrintInspect,hal.减(EndSeconds,StartSeconds))
hal.disp_message(WindowHandle,hal.加(hal.加("Inspection Time: ",hal.文本格式化(hal.乘(hal.加(TimeObjSearch,TimePrintInspect),到小数(1000.0)),".04"))," ms"),"window",12,12,"black","true")
.默认
hal.disp_message(WindowHandle,"No shape model found!","window",12,12,"black","true")
.判断结束

' 
return()

.子程序 p_do_3d_matching_clamps
.局部变量 CamParam, 视觉元组
.局部变量 CovPose, 视觉元组
.局部变量 CovPoseI, 视觉元组
.局部变量 Error, 视觉元组
.局部变量 ErrorVar, 视觉元组
.局部变量 HEXAMPLES, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 ImHeight, 视觉元组
.局部变量 ImWidth, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageNo, 视觉元组
.局部变量 ModelContours, 视觉对象
.局部变量 Pose, 视觉元组
.局部变量 PoseI, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 ScoreI, 视觉元组
.局部变量 Seconds1, 视觉元组
.局部变量 Seconds2, 视觉元组
.局部变量 ShapeModel3DFile, 视觉元组
.局部变量 ShapeModel3DID, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' This example program shows how to use HALCON's 3D Matching
' to find the 3D pose of clamps that exhibit a 6 degree of freedom
' motion.
' 
' 
' Set the camera parameters (can be obtained by using camera calibration)
hal.赋值(CamParam,hal.创建元组(0.01221,-2791,7.3958e-6,7.4e-6,308.21,245.92,640,480))
' 
hal.赋值(Width,hal.取元素(CamParam,6))
hal.赋值(Height,hal.取元素(CamParam,7))
hal.dev_close_window()
hal.dev_open_window(0,0,Width,Height,"black",WindowHandle)
hal.dev_update_off()
p_set_font(hal.克隆元组(WindowHandle))
' 
' 
hal.read_image(Image,hal.加("clamp_sloped/clamp_sloped_",hal.文本格式化(1,"02")))
hal.get_image_size(Image,ImWidth,ImHeight)
hal.dev_set_part(0,0,hal.减(ImHeight,1),hal.减(ImWidth,1))
hal.dev_display(Image)
' 
' Load the precomputed 3D shape model if present
hal.get_system("example_dir",HEXAMPLES)
hal.赋值(ShapeModel3DFile,hal.加(HEXAMPLES,"/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3"))
hal.disp_message(WindowHandle,"Loading 3D shape model...","window",10,10,"black","true")
' 
' 
hal.dev_set_check("~give_error")
hal.dev_error_var(ErrorVar,1)
hal.read_shape_model_3d(ShapeModel3DFile,ShapeModel3DID)
hal.赋值(Error,ErrorVar)
hal.dev_set_check("give_error")
.判断开始 (hal.不等于(Error,#视觉_错误代码_无错误))
hal.dev_display(Image)
hal.set_display_font(WindowHandle,12,"mono","true","false")
hal.disp_message(WindowHandle,hal.创建元组("Please run the HDevelop program",ShapeModel3DFile,"to create the 3D shape model!"),"window",5,5,"black","true")
hal.wait_seconds(2)
return()
.判断结束

' 
hal.dev_set_line_width(2)
' 
' Find instances of a 3D shape model in some run-time images
hal.赋值 (ImageNo, 1)
.判断循环首 (hal.小于等于 (ImageNo, 35))
hal.read_image(Image,hal.加("clamp_sloped/clamp_sloped_",hal.文本格式化(ImageNo,"02")))
hal.count_seconds(Seconds1)
'     Find up to two instances of the 3D shape model
hal.find_shape_model_3d(Image,ShapeModel3DID,0.7,0.9,5,hal.创建元组("num_matches","pose_refinement"),hal.创建元组(2,"least_squares_very_high"),Pose,CovPose,Score)
hal.count_seconds(Seconds2)
hal.赋值(Time,hal.减(Seconds2,Seconds1))
hal.赋值(Time,hal.减(Seconds2,Seconds1))
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.加(hal.加(hal.加(hal.取元素总数(Score)," Match(es) found in "),hal.文本格式化(Time,"4.3f"))," s"),"window",12,12,"black","true")
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(Score),1)))
hal.赋值(PoseI,hal.取元素范围(Pose,hal.乘(I,7),hal.加(hal.乘(I,7),6)))
hal.赋值(CovPoseI,hal.取元素范围(CovPose,hal.乘(I,6),hal.加(hal.乘(I,6),5)))
hal.赋值(ScoreI,hal.取元素(Score,I))
'         Visualize the found matches in the image by projecting the
'         3D shape model with the pose of the match
hal.project_shape_model_3d(ModelContours,ShapeModel3DID,CamParam,PoseI,"true",0.523599)
hal.dev_set_color("forest green")
hal.dev_display(ModelContours)
'         - projecting the coordinate system of the 3D object model
hal.dev_set_colored(3)
hal.disp_3d_coord_system(WindowHandle,CamParam,PoseI,0.015)
'         Display the parameters of the found pose
hal.dev_set_color("magenta")
display_match_pose(hal.克隆元组(ShapeModel3DID),hal.克隆元组(PoseI),hal.克隆元组(WindowHandle))
I ＝ hal.加 (I, 1)
.判断循环尾 ()
'     
.判断开始 (hal.小于(ImageNo,9))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(2)
.判断结束

ImageNo ＝ hal.加 (ImageNo, 1)
.判断循环尾 ()
' 
' Free the 3D shape model if it is not longer needed
hal.clear_shape_model_3d(ShapeModel3DID)
' 
hal.wait_seconds(4)
return()

.子程序 display_match_pose
.参数 ShapeModel3DID, tuple
.参数 Pose, tuple
.参数 WindowHandle, tuple
.局部变量 CamParam, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 HomMat3D, 视觉元组
.局部变量 ReferencePoint, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 X, 视觉元组
.局部变量 Y, 视觉元组
.局部变量 Z, 视觉元组

' 
' 
hal.get_shape_model_3d_params(ShapeModel3DID,"reference_point",ReferencePoint)
hal.get_shape_model_3d_params(ShapeModel3DID,"cam_param",CamParam)
' 
' Project the reference point
hal.pose_to_hom_mat3d(Pose,HomMat3D)
hal.affine_trans_point_3d(HomMat3D,hal.取元素(ReferencePoint,0),hal.取元素(ReferencePoint,1),hal.取元素(ReferencePoint,2),X,Y,Z)
hal.project_3d_point(X,Y,Z,CamParam,Row,Column)
' 
' Display the pose at the projected reference point
hal.set_tposition(WindowHandle,Row,hal.减(Column,10))
hal.write_string(WindowHandle,"Pose:")
hal.set_tposition(WindowHandle,hal.加(Row,15),Column)
hal.write_string(WindowHandle,hal.加(hal.加("X: ",hal.文本格式化(hal.乘(1000,hal.取元素(Pose,0)),"4.1f"))," mm"))
hal.set_tposition(WindowHandle,hal.加(Row,30),Column)
hal.write_string(WindowHandle,hal.加(hal.加("Y: ",hal.文本格式化(hal.乘(1000,hal.取元素(Pose,1)),"4.1f"))," mm"))
hal.set_tposition(WindowHandle,hal.加(Row,45),Column)
hal.write_string(WindowHandle,hal.加(hal.加("Z: ",hal.文本格式化(hal.乘(1000,hal.取元素(Pose,2)),"4.1f"))," mm"))
hal.set_tposition(WindowHandle,hal.加(Row,60),Column)
hal.write_string(WindowHandle,hal.加(hal.加("Alpha: ",hal.文本格式化(hal.取元素(Pose,3),"4.1f")),"°"))
hal.set_tposition(WindowHandle,hal.加(Row,75),Column)
hal.write_string(WindowHandle,hal.加(hal.加("Beta: ",hal.文本格式化(hal.取元素(Pose,4),"4.1f")),"°"))
hal.set_tposition(WindowHandle,hal.加(Row,90),Column)
hal.write_string(WindowHandle,hal.加(hal.加("Gamma: ",hal.文本格式化(hal.取元素(Pose,5),"4.1f")),"°"))
return()

.子程序 p_do_blister_mixed
.局部变量 Area, 视觉元组
.局部变量 Area1, 视觉元组
.局部变量 Centers, 视觉元组
.局部变量 Chambers, 视觉对象
.局部变量 ChambersRemaining, 视觉对象
.局部变量 ChambersUnion, 视觉对象
.局部变量 ClassRegions, 视觉对象
.局部变量 Classes, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 ColumnRef, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 CountFinalClass, 视觉元组
.局部变量 Deviation, 视觉元组
.局部变量 FileIndex, 视觉元组
.局部变量 FinalClasses, 视觉对象
.局部变量 GMMHandle, 视觉元组
.局部变量 HomMat2D, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageAffinTrans, 视觉对象
.局部变量 ImageB, 视觉对象
.局部变量 ImageG, 视觉对象
.局部变量 ImageR, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 IndexList, 视觉元组
.局部变量 Iter, 视觉元组
.局部变量 LeftOvers, 视觉对象
.局部变量 Mean, 视觉元组
.局部变量 MissingPills, 视觉对象
.局部变量 NumClasses, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 Phi, 视觉元组
.局部变量 PhiRef, 视觉元组
.局部变量 PillTypeCount, 视觉元组
.局部变量 PillsOfOneType, 视觉对象
.局部变量 Region, 视觉对象
.局部变量 RegionDifference, 视觉对象
.局部变量 RegionTrans, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 RowRef, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 Size, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WrongNumberOfPills, 视觉对象
.局部变量 WrongPills, 视觉对象

hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,hal.乘(750,0.854),hal.乘(478,0.854),"black",WindowHandle)
hal.dev_set_part(-10,-15,hal.减(478,11),hal.减(750,16))
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
' 
' 
hal.read_image(Image,"blister/blister_mixed_reference")
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Test mixed blister for correct composition","window",-1,-1,"black","true")
hal.disp_message(WindowHandle,"... train gmm classifier on pill types   ","window",38,12,"black","true")
' 
' First, we extract the content of the blister and pass
' this information on to the gmm classifier
extract_pill_types(hal.克隆对象(Image),Chambers,ChambersUnion,Classes,PhiRef,RowRef,ColumnRef,PillTypeCount)
hal.赋值(NumClasses,hal.取元素总数(PillTypeCount))
hal.create_class_gmm(3,3,hal.创建元组(1,5),"spherical","normalization",10,42,GMMHandle)
hal.add_samples_image_class_gmm(Image,Classes,GMMHandle,0)
hal.train_class_gmm(GMMHandle,100,0.001,"training",0.0001,Centers,Iter)
hal.wait_seconds(2)
' 
' 
' Then, the subsequent blisters are checked for the
' correct pill combination
hal.赋值(IndexList,hal.创建元组(1,2,3,4,5,1,6,7,8,9,10,11,12,3,6,9,12,2,4,8,10,1,5,7,11,1,2,3,4,5,6,7,8,9,10,1))
hal.赋值 (FileIndex, 0)
.判断循环首 (hal.小于等于 (FileIndex, hal.减(hal.取元素总数(IndexList),1)))
'     
'     Align image
hal.read_image(Image,hal.加("blister/blister_mixed_",hal.文本格式化(hal.取元素(IndexList,FileIndex),"02")))
hal.threshold(Image,Region,90,255)
hal.connection(Region,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",5000,9999999)
hal.shape_trans(SelectedRegions,RegionTrans,"convex")
hal.orientation_region(RegionTrans,Phi)
.判断开始 (hal.大于(hal.abs(Phi),hal.rad(90)))
hal.赋值(Phi,hal.加(hal.rad(180),Phi))
.判断结束

hal.area_center(RegionTrans,Area1,Row,Column)
hal.vector_angle_to_rigid(Row,Column,Phi,RowRef,ColumnRef,PhiRef,HomMat2D)
hal.affine_trans_image(Image,ImageAffinTrans,HomMat2D,"constant","false")
hal.reduce_domain(ImageAffinTrans,ChambersUnion,ImageReduced)
hal.decompose3(ImageAffinTrans,ImageR,ImageG,ImageB)
'     
'     Classify pill type for each chamber
hal.classify_image_class_gmm(ImageReduced,ClassRegions,GMMHandle,0.005)
'     
hal.count_obj(ClassRegions,Number)
hal.gen_empty_obj(FinalClasses)
hal.connection(Chambers,ChambersRemaining)
hal.赋值 (Index, Number)
.判断循环首 (hal.大于等于 (Index, 1))
hal.select_obj(ClassRegions,Region,Index)
hal.intersection(ChambersRemaining,Region,Region)
hal.select_shape(Region,PillsOfOneType,hal.创建元组("area","width"),"and",hal.创建元组(200,40),hal.创建元组(3000,68))
hal.difference(ChambersUnion,PillsOfOneType,RegionDifference)
hal.connection(RegionDifference,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",0,7868)
hal.shape_trans(SelectedRegions,SelectedRegions,"convex")
hal.union1(SelectedRegions,SelectedRegions)
hal.difference(ChambersRemaining,SelectedRegions,ChambersRemaining)
hal.concat_obj(SelectedRegions,FinalClasses,FinalClasses)
Index ＝ hal.加 (Index, -1)
.判断循环尾 ()
'     
'     
'     Check for correct pill combination
hal.gen_empty_obj(MissingPills)
hal.gen_empty_obj(WrongPills)
hal.gen_empty_obj(WrongNumberOfPills)
hal.difference(ChambersUnion,FinalClasses,LeftOvers)
hal.area_center(LeftOvers,Area,Row1,Column1)
.判断开始 (hal.大于(Area,0))
hal.connection(LeftOvers,LeftOvers)
hal.count_obj(LeftOvers,Number)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, Number))
hal.select_obj(LeftOvers,ObjectSelected,Index)
hal.intensity(ObjectSelected,ImageB,Mean,Deviation)
.判断开始 (hal.大于(Deviation,40))
hal.concat_obj(WrongPills,ObjectSelected,WrongPills)
.默认
hal.concat_obj(MissingPills,ObjectSelected,MissingPills)
.判断结束

Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
.判断结束

'     
'     Compute histogram
hal.赋值(CountFinalClass,hal.创建元组())
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, NumClasses))
hal.select_obj(FinalClasses,ObjectSelected,Index)
hal.connection(ObjectSelected,ObjectSelected)
hal.count_obj(ObjectSelected,Size)
hal.赋值(CountFinalClass,hal.创建元组(CountFinalClass,Size))
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
'     
hal.set_system("flush_graphic","false")
display_results(hal.克隆对象(ImageAffinTrans),hal.克隆对象(LeftOvers),hal.克隆对象(FinalClasses),hal.克隆对象(WrongPills),hal.克隆元组(CountFinalClass),hal.克隆元组(PillTypeCount),hal.克隆元组(WindowHandle))
hal.set_system("flush_graphic","true")
hal.disp_line(WindowHandle,-101,-101,-99,-99)
'     Display classification results and output allover statistic
.判断开始 (hal.小于(FileIndex,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

FileIndex ＝ hal.加 (FileIndex, 1)
.判断循环尾 ()
hal.clear_class_gmm(GMMHandle)
' 
hal.wait_seconds(2)
return()

.子程序 extract_pill_types
.参数 Image, obj
.参数 Chambers, obj, 参考
.参数 ChambersUnion, obj, 参考
.参数 Classes, obj, 参考
.参数 PhiRef, tuple, 参考
.参数 RowRef, tuple, 参考
.参数 ColumnRef, tuple, 参考
.参数 PillTypeCount, tuple, 参考
.局部变量 Area, 视觉元组
.局部变量 Blister, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 I, 视觉元组
.局部变量 ImageB, 视觉对象
.局部变量 ImageG, 视觉对象
.局部变量 ImageInvert, 视觉对象
.局部变量 ImageR, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 J, 视觉元组
.局部变量 Pattern, 视觉对象
.局部变量 PillType1, 视觉对象
.局部变量 PillType2, 视觉对象
.局部变量 PillType3, 视觉对象
.局部变量 Rectangle, 视觉对象
.局部变量 Region, 视觉对象
.局部变量 RegionHysteresis2, 视觉对象
.局部变量 RegionHysteresis3, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 SelectedRegions, 视觉对象

hal.threshold(Image,Region,90,255)
hal.connection(Region,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",5000,999999)
hal.shape_trans(SelectedRegions,Blister,"convex")
hal.gen_empty_region(Chambers)
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, 4))
hal.赋值(Row,hal.加(107,hal.乘(I,70)))
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, 2))
hal.赋值(Column,hal.加(177,hal.乘(J,150)))
hal.gen_rectangle2(Rectangle,Row,Column,0,64,30)
hal.concat_obj(Chambers,Rectangle,Chambers)
J ＝ hal.加 (J, 1)
.判断循环尾 ()
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.difference(Blister,Chambers,Pattern)
hal.union1(Chambers,ChambersUnion)
hal.orientation_region(Blister,PhiRef)
hal.赋值(PhiRef,hal.加(hal.rad(180),PhiRef))
hal.area_center(Blister,Area,RowRef,ColumnRef)
' 
' 
' +++ extract pattern for classification +++
hal.select_shape(Chambers,PillType1,"row","and",1,145)
hal.union1(PillType1,PillType1)
hal.select_shape(Chambers,PillType2,"row","and",145,270)
hal.union1(PillType2,PillType2)
hal.select_shape(Chambers,PillType3,"row","and",270,390)
hal.union1(PillType3,PillType3)
' 
' 
' extract color space of yellow pills
hal.reduce_domain(Image,PillType1,ImageReduced)
hal.decompose3(ImageReduced,ImageR,ImageG,ImageB)
hal.threshold(ImageB,Region,60,95)
' 
' extract color space of red pills
hal.reduce_domain(Image,PillType2,ImageReduced)
hal.decompose3(ImageReduced,ImageR,ImageG,ImageB)
hal.invert_image(ImageB,ImageInvert)
hal.hysteresis_threshold(ImageInvert,RegionHysteresis2,190,200,5)
' 
' extract color space of green pills
hal.reduce_domain(Image,PillType3,ImageReduced)
hal.decompose3(ImageReduced,ImageR,ImageG,ImageB)
hal.invert_image(ImageB,ImageInvert)
hal.hysteresis_threshold(ImageInvert,RegionHysteresis3,180,200,10)
' 
hal.intersection(Region,PillType1,PillType1)
hal.intersection(RegionHysteresis2,PillType2,PillType2)
hal.赋值(PillTypeCount,hal.创建元组(3,6,6))
hal.intersection(RegionHysteresis3,PillType3,PillType3)
hal.concat_obj(PillType1,PillType2,Classes)
hal.concat_obj(Classes,PillType3,Classes)
return()

.子程序 display_results
.参数 ImageAffinTrans, obj
.参数 LeftOvers, obj
.参数 FinalClasses, obj
.参数 WrongPills, obj
.参数 CountFinalClass, tuple
.参数 PillTypeCount, tuple
.参数 WindowHandle, tuple
.局部变量 Colors, 视觉元组
.局部变量 Errors, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 NumWrong, 视觉元组
.局部变量 Numbers, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 PillType, 视觉元组
.局部变量 RedLeftOvers, 视觉对象
.局部变量 ThereWereErrors, 视觉元组
.局部变量 false, 视觉元组

hal.赋值(ThereWereErrors,false)
hal.dev_display(ImageAffinTrans)
hal.dev_set_draw("margin")
hal.dev_set_line_width(4)
hal.dev_set_color("red")
hal.dilation_circle(LeftOvers,RedLeftOvers,2.5)
hal.dev_display(RedLeftOvers)
' 
hal.dev_set_line_width(3)
hal.select_obj(FinalClasses,ObjectSelected,1)
hal.dev_set_color("goldenrod")
hal.dev_display(ObjectSelected)
hal.select_obj(FinalClasses,ObjectSelected,3)
hal.dev_set_color("medium forest green")
hal.dev_display(ObjectSelected)
hal.select_obj(FinalClasses,ObjectSelected,2)
hal.dev_set_color("firebrick")
hal.dev_display(ObjectSelected)
' 
hal.赋值(PillType,hal.文本格式化(hal.创建元组(""+#引号+"yellow"+#引号+"",""+#引号+"red"+#引号+"",""+#引号+"green"+#引号+""),"-8"))
hal.赋值(Numbers,hal.加(hal.加(hal.加("# Pill type ",PillType),": "),CountFinalClass))
hal.赋值(Message,hal.加(hal.加("# Pill type ",PillType),": "))
hal.赋值(Errors,hal.文本格式化(hal.元组不等于元素(CountFinalClass,PillTypeCount),"1"))
hal.赋值(Colors,hal.regexp_replace(Errors,"0","black"))
hal.赋值(Colors,hal.regexp_replace(Colors,"1","red"))
' 
hal.disp_message(WindowHandle,Numbers,"window",10,10,Colors,"true")
' 
hal.count_obj(WrongPills,NumWrong)
.判断开始 (hal.大于(NumWrong,0))
hal.disp_message(WindowHandle,hal.加("# Wrong pill type   : ",NumWrong),"window",hal.加(10,60),10,"red","true")
.判断结束

.判断开始 (hal.不等于(hal.查找元素(Errors,"1"),-1))
hal.disp_message(WindowHandle,"Not OK","window",10,400,"red","true")
.默认
hal.disp_message(WindowHandle,"OK","window",10,400,"forest green","true")
.判断结束

return()

.子程序 p_do_ecc200_finder_pattern_tolerance
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageFiles, 视觉元组
.局部变量 ImageFilesTrain, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 IndexList, 视觉元组
.局部变量 Path, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 Seconds1, 视觉元组
.局部变量 Seconds2, 视觉元组
.局部变量 SymbolXLDs, 视觉对象
.局部变量 Time, 视觉元组
.局部变量 WindowHandle, 视觉元组

hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(576,1),hal.减(768,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_set_draw("margin")
hal.dev_set_line_width(4)
' 
' 
' 
hal.赋值(Path,"datacode/ecc200/")
hal.赋值(ImageFilesTrain,hal.加(Path,"ecc200_damaged_finder_pattern_training_"))
hal.赋值(ImageFiles,hal.加(Path,"ecc200_damaged_finder_pattern_"))
hal.read_image(Image,hal.加(ImageFilesTrain,"01"))
hal.set_system("clock_mode","performance_counter")
' 
' Create a new ECC 200 data code model
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Decode datacode symbols with"+#换行符+"heavily disturbed finder pattern","window",-1,-1,"black","true")
hal.create_data_code_2d_model("Data Matrix ECC 200",hal.创建元组(),hal.创建元组(),DataCodeHandle)
hal.wait_seconds(4)
' 
' Perform the training
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, 5))
hal.read_image(Image,hal.加(ImageFilesTrain,hal.文本格式化(Index,".02")))
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.加("Training datacode sample ",Index),"window",-1,-1,"black","true")
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,"train","all",ResultHandles,DecodedDataStrings)
hal.dev_set_color("lime green")
hal.dev_display(SymbolXLDs)
hal.wait_seconds(0.6)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
hal.dev_display(Image)
hal.disp_message(WindowHandle,"Decode datacode symbols","window",-1,-1,"black","true")
hal.wait_seconds(2.5)
' Perform the recognition
hal.赋值(IndexList,hal.创建元组(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,4,8,12,16,3,6,9,15,18,1,2,5,7,10,11,13,14,17,19,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,4,8,12,16,3,6,9,15,18,1,2,5,7,10,11,13,14,17,19))
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(IndexList),1)))
hal.read_image(Image,hal.加(ImageFiles,hal.文本格式化(hal.取元素(IndexList,Index),".02")))
hal.dev_display(Image)
hal.count_seconds(Seconds1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(Seconds2)
hal.赋值(Time,hal.乘(hal.减(Seconds2,Seconds1),到小数(1000.0)))
hal.dev_set_color("lime green")
hal.dev_display(SymbolXLDs)
.判断开始 (hal.大于(hal.取元素总数(DecodedDataStrings),0))
hal.disp_message(WindowHandle,hal.创建元组(hal.加(hal.加("Decoded Symbol in ",hal.文本格式化(Time,".1f"))," ms"),hal.加("Symbol: ",DecodedDataStrings)),"window",-1,-1,"black","true")
.默认
hal.disp_message(WindowHandle,hal.加(hal.加("No Symbol found (in ",hal.文本格式化(Time,".1f"))," ms )"),"window",-1,-1,"black","true")
.判断结束

.判断开始 (hal.小于(Index,5))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
' Clear the data code model
hal.clear_data_code_2d_model(DataCodeHandle)
' 
' 
hal.wait_seconds(2)
return()

.子程序 p_do_bottle_mouth
.局部变量 Circle, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 Connection, 视觉对象
.局部变量 ContoursSplit, 视觉对象
.局部变量 DarkRegion, 视觉对象
.局部变量 Edges, 视觉对象
.局部变量 EndPhi, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageMean, 视觉对象
.局部变量 ImagePolar, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 ImageRotate, 视觉对象
.局部变量 ImageScaleMax, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 IndexList, 视觉元组
.局部变量 Length, 视觉元组
.局部变量 LongestContour, 视觉对象
.局部变量 MinDefectSize, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 PointOrder, 视觉元组
.局部变量 PolarResolution, 视觉元组
.局部变量 Radius, 视觉元组
.局部变量 RegionBorder, 视觉对象
.局部变量 RegionClosing, 视觉对象
.局部变量 RegionClosing1, 视觉对象
.局部变量 RegionDifference, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionErosion, 视觉对象
.局部变量 RegionFillUp, 视觉对象
.局部变量 RegionMirror, 视觉对象
.局部变量 RegionOpening, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 Regions, 视觉对象
.局部变量 Regions1, 视觉对象
.局部变量 RingSize, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 SmoothX, 视觉元组
.局部变量 StartPhi, 视觉元组
.局部变量 StoreEmptyRegion, 视觉元组
.局部变量 ThresholdOffset, 视觉元组
.局部变量 UnionContours, 视觉对象
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandle1, 视觉元组
.局部变量 XYTransRegion, 视觉对象

hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,512,"black",WindowHandle1)
hal.dev_set_part(0,0,hal.减(512,1),hal.减(640,1))
p_set_font(hal.克隆元组(WindowHandle1))
hal.dev_set_draw("margin")
hal.dev_set_line_width(3)
hal.dev_set_color("red")
' 
hal.赋值(SmoothX,501)
hal.赋值(ThresholdOffset,25)
hal.赋值(MinDefectSize,50)
' 
hal.dev_set_window(WindowHandle1)
hal.get_system("store_empty_region",StoreEmptyRegion)
hal.set_system("store_empty_region","false")
hal.read_image(Image,"bottles/bottle_mouth_01")
hal.dev_display(Image)
hal.disp_message(WindowHandle1,"Check bottle mouth for damages","window",-1,-1,"black","true")
hal.wait_seconds(3)
' 
' initialization
hal.赋值(PolarResolution,640)
hal.赋值(RingSize,70)
hal.dev_open_window(0,hal.减(648,128),RingSize,512,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(PolarResolution,1),hal.减(RingSize,1))
' 
' Main loop
' 
' Detect defects in bottle necks
hal.赋值(IndexList,hal.创建元组(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,4,8,12,16,3,6,9,15,2,10,14,1,5,7,11,13,14,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1))
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(IndexList),1)))
hal.read_image(Image,hal.加("bottles/bottle_mouth_",hal.文本格式化(hal.取元素(IndexList,Index),".02")))
'     
'     Part 1: Use basic morphology to detect bottle
hal.auto_threshold(Image,Regions,2)
hal.select_obj(Regions,DarkRegion,1)
hal.opening_circle(DarkRegion,RegionOpening,3.5)
hal.closing_circle(RegionOpening,RegionClosing,25.5)
hal.fill_up(RegionClosing,RegionFillUp)
hal.boundary(RegionFillUp,RegionBorder,"outer")
hal.dilation_circle(RegionBorder,RegionDilation,3.5)
hal.reduce_domain(Image,RegionDilation,ImageReduced)
'     
'     Find the bottle center by fitting a circle to extracted edges
hal.edges_sub_pix(ImageReduced,Edges,"canny",0.5,20,40)
hal.segment_contours_xld(Edges,ContoursSplit,"lines_circles",5,4,2)
hal.union_cocircular_contours_xld(ContoursSplit,UnionContours,0.9,0.5,0.5,200,50,50,"true",1)
hal.length_xld(UnionContours,Length)
hal.select_obj(UnionContours,LongestContour,hal.加(hal.取元素(hal.sort_index(Length),hal.减(hal.取元素总数(Length),1)),1))
hal.fit_circle_contour_xld(LongestContour,"ahuber",-1,0,0,3,2,Row,Column,Radius,StartPhi,EndPhi,PointOrder)
'     
'     Part 2: Transform the ring-shaped bottle neck region to a rectangle
hal.gen_circle(Circle,Row,Column,Radius)
hal.dilation_circle(Circle,RegionDilation,5)
hal.erosion_circle(Circle,RegionErosion,hal.减(RingSize,5))
hal.difference(RegionDilation,RegionErosion,RegionDifference)
hal.reduce_domain(Image,RegionDifference,ImageReduced)
hal.polar_trans_image_ext(ImageReduced,ImagePolar,Row,Column,0,hal.rad(360),hal.减(Radius,RingSize),Radius,PolarResolution,RingSize,"nearest_neighbor")
'     
'     Part 3: Find defects with a dynamic threshold
'     Note the strong smoothing in x-direction in the transformed image.
hal.scale_image_max(ImagePolar,ImageScaleMax)
hal.mean_image(ImageScaleMax,ImageMean,SmoothX,3)
hal.dyn_threshold(ImageScaleMax,ImageMean,Regions1,55,"not_equal")
hal.connection(Regions1,Connection)
hal.select_shape(Connection,SelectedRegions,"height","and",9,99999)
'     ignore noise regions
hal.closing_rectangle1(SelectedRegions,RegionClosing1,10,20)
hal.union1(RegionClosing1,RegionUnion)
'     re-transform defect regions for visualization
hal.polar_trans_region_inv(RegionUnion,XYTransRegion,Row,Column,0,hal.rad(360),hal.减(Radius,RingSize),Radius,PolarResolution,RingSize,1280,1024,"nearest_neighbor")
'     
'     Part 4: Display results
'     display original image with results
hal.dev_set_window(WindowHandle1)
hal.dev_display(Image)
hal.dev_set_color("blue")
hal.dev_display(RegionDifference)
hal.dev_set_color("red")
hal.dev_display(XYTransRegion)
'     display polar transformed inspected region with results
'     The image and resulting region are rotated by 90 degrees
'     only for visualization purposes! (I.e. to fit better on the screen)
'     The rotation is NOT necessary for the detection algorithm.
hal.dev_set_window(WindowHandle)
hal.rotate_image(ImagePolar,ImageRotate,90,"constant")
hal.dev_display(ImageRotate)
hal.count_obj(RegionUnion,Number)
.判断开始 (hal.大于(Number,0))
hal.mirror_region(RegionUnion,RegionMirror,"diagonal",PolarResolution)
hal.mirror_region(RegionMirror,RegionMirror,"row",PolarResolution)
hal.dev_display(RegionMirror)
hal.disp_message(WindowHandle1,"Not OK","window",-1,-1,"red","false")
.默认
hal.disp_message(WindowHandle1,"OK","window",-1,-1,"forest green","false")
.判断结束

.判断开始 (hal.小于(Index,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
hal.dev_set_color("red")
.判断结束

hal.wait_seconds(0.07)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' Reset system parameters
hal.set_system("store_empty_region",StoreEmptyRegion)
' 
' 
hal.wait_seconds(2)
hal.dev_set_window(WindowHandle)
hal.dev_close_window()
return()

.子程序 p_do_cookie_box
.局部变量 CamParam, 视觉元组
.局部变量 Col, 视觉元组
.局部变量 ColTrans, 视觉元组
.局部变量 ColumnsRoi, 视觉元组
.局部变量 Contour, 视觉对象
.局部变量 Cross1, 视觉对象
.局部变量 DescrModelFile, 视觉元组
.局部变量 DescriptorHandle, 视觉元组
.局部变量 Error, 视觉元组
.局部变量 ErrorVar, 视觉元组
.局部变量 HEXAMPLES, 视觉元组
.局部变量 HomMat3D, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 IndexList, 视觉元组
.局部变量 OutputString, 视觉元组
.局部变量 Pose, 视觉元组
.局部变量 Quality, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 RowTrans, 视觉元组
.局部变量 RowsRoi, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 Seconds1, 视觉元组
.局部变量 Seconds2, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WorldX, 视觉元组
.局部变量 WorldY, 视觉元组
.局部变量 XOuterBox, 视觉元组
.局部变量 XTrans, 视觉元组
.局部变量 YOuterBox, 视觉元组
.局部变量 YTrans, 视觉元组
.局部变量 ZTrans, 视觉元组

hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(480,1),hal.减(640,1))
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_set_draw("margin")
' 
' 
hal.read_image(Image,"packaging/cookie_box_01")
hal.dev_display(Image)
' 
hal.get_system("example_dir",HEXAMPLES)
hal.赋值(DescrModelFile,hal.加(HEXAMPLES,"/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm"))
hal.赋值(CamParam,hal.创建元组(0.0155565,-109.42,1.28008e-005,1.28e-005,322.78,240.31,640,480))
' 
hal.disp_message(WindowHandle,"Determine position and orientation"+#换行符+"of cookie box","window",-1,-1,"black","true")
hal.disp_message(WindowHandle,"Loading descriptor-based model...","window",60,-1,"black","true")
hal.dev_set_check("~give_error")
hal.dev_error_var(ErrorVar,1)
hal.read_descriptor_model(DescrModelFile,DescriptorHandle)
hal.赋值(Error,ErrorVar)
hal.dev_set_check("give_error")
.判断开始 (hal.不等于(Error,#视觉_错误代码_无错误))
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.创建元组("Please first run the HDevelop program","/Applications//Object-Recognition-2D/locate_cookie_box.hdev ","to create the descriptor-based model!"),"window",5,5,"black","true")
hal.wait_seconds(2)
hal.dev_close_window()
return()
.判断结束

' 
' reference pose of the object to the camera is computed
hal.赋值(RowsRoi,hal.创建元组(224,224,406,406))
hal.赋值(ColumnsRoi,hal.创建元组(115,540,540,115))
hal.赋值(WorldX,hal.除(hal.创建元组(-189,189,189,-189),到小数(1000.0)))
hal.赋值(WorldY,hal.除(hal.创建元组(-80,-80,80,80),到小数(1000.0)))
hal.vector_to_pose(WorldX,WorldY,hal.创建元组(),RowsRoi,ColumnsRoi,CamParam,"iterative","error",Pose,Quality)
hal.image_points_to_world_plane(CamParam,Pose,RowsRoi,ColumnsRoi,"m",XOuterBox,YOuterBox)
' 
' 
' 
' Main loop:
' search model in image sequence
hal.赋值(IndexList,hal.创建元组(1,2,4,5,6,7,8,9,10,2,4,6,8,10,1,5,7,9,6,8,5,10,1,2,5,7,9,3,6,8,4,5,10,2,1,4,5,6,7,8,9,10,2,4,6,8,1,5,7,9,6,2))
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(IndexList),1)))
hal.赋值(OutputString,hal.创建元组())
hal.read_image(Image,hal.加("packaging/cookie_box_",hal.文本格式化(hal.取元素(IndexList,Index),".02")))
hal.set_system("flush_graphic","false")
hal.dev_display(Image)
'     
'     find model (using default parameters)
hal.count_seconds(Seconds1)
hal.find_calib_descriptor_model(Image,DescriptorHandle,hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),0.25,1,CamParam,"num_points",Pose,Score)
hal.count_seconds(Seconds2)
hal.赋值(Time,hal.减(Seconds2,Seconds1))
'     
'     display results
.判断开始 (hal.大于(hal.取元素总数(Score),0))
hal.get_descriptor_model_points(DescriptorHandle,"search",0,Row,Col)
hal.dev_set_colored(12)
hal.dev_set_line_width(1)
hal.gen_cross_contour_xld(Cross1,Row,Col,6,0.785398)
hal.dev_display(Cross1)
hal.dev_set_line_width(3)
hal.disp_3d_coord_system(WindowHandle,CamParam,Pose,0.07)
'         
hal.pose_to_hom_mat3d(Pose,HomMat3D)
hal.affine_trans_point_3d(HomMat3D,XOuterBox,YOuterBox,hal.创建元组(0,0,0,0),XTrans,YTrans,ZTrans)
hal.project_3d_point(XTrans,YTrans,ZTrans,CamParam,RowTrans,ColTrans)
'         
'         
hal.gen_contour_polygon_xld(Contour,RowTrans,ColTrans)
hal.close_contours_xld(Contour,Contour)
hal.dev_set_color("lime green")
hal.dev_display(Contour)
'         
hal.赋值(OutputString,hal.加(hal.加("Box located in ",hal.文本格式化(hal.乘(Time,1000),".4"))," ms"))
'         determine direction of box
.判断结束

hal.disp_message(WindowHandle,OutputString,"window",10,10,"black","true")
.判断开始 (hal.小于(Index,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.set_system("flush_graphic","true")
hal.disp_line(WindowHandle,-101,-101,-99,-99)
hal.wait_seconds(0.95)
.默认
hal.set_system("flush_graphic","true")
hal.disp_line(WindowHandle,-101,-101,-99,-99)
.判断结束

hal.wait_seconds(0.05)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
' created descriptor model has to be deleted
hal.clear_descriptor_model(DescriptorHandle)
' 
' 
hal.wait_seconds(2)
return()

.子程序 do_check_for_model_files
.参数 CookieModelExists, tuple, 参考
.参数 ClampsModelExists, tuple, 参考
.局部变量 DescrModelFile, 视觉元组
.局部变量 HEXAMPLES, 视觉元组
.局部变量 ShapeModel3DFile, 视觉元组

' 
hal.get_system("example_dir",HEXAMPLES)
' 
hal.赋值(DescrModelFile,hal.加(HEXAMPLES,"/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm"))
hal.file_exists(DescrModelFile,CookieModelExists)
' 
' 
hal.赋值(ShapeModel3DFile,hal.加(HEXAMPLES,"/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3"))
hal.file_exists(ShapeModel3DFile,ClampsModelExists)
' 
return()

.子程序 p_do_track_engine_part
.局部变量 AngleExtent, 视觉元组
.局部变量 AngleExtentTracking, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 CamParam, 视觉元组
.局部变量 Circle, 视觉对象
.局部变量 ColOrig, 视觉元组
.局部变量 ColTrans, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Contours, 视觉对象
.局部变量 ContoursProjTrans, 视觉对象
.局部变量 Exception, 视觉元组
.局部变量 HomMat2DInvert, 视觉元组
.局部变量 HomMat2DOut, 视觉元组
.局部变量 HomMat2DTrack, 视觉元组
.局部变量 HomMat3D, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 Metric, 视觉元组
.局部变量 MinScore, 视觉元组
.局部变量 MinScoreTracking, 视觉元组
.局部变量 ModelID, 视觉元组
.局部变量 NotFound, 视觉元组
.局部变量 NumImages, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 Pose, 视觉元组
.局部变量 PreferenceValue, 视觉元组
.局部变量 Quality, 视觉元组
.局部变量 Region, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 RowOrig, 视觉元组
.局部变量 RowTrans, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 ScaleCOffset, 视觉元组
.局部变量 ScaleROffset, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 TrackingFailed, 视觉元组
.局部变量 TrackingRadius, 视觉元组
.局部变量 TrackingTime, 视觉元组
.局部变量 TransImage, 视觉对象
.局部变量 WindowHandle, 视觉元组

' This example shows how to efficiently perform a tracking task using
' perspective deformable matching. The basic idea is to speed up the
' search by using the pose that was determined in a previous image to
' restrict the search space in the next image. In case that the
' algorithm looses track of the object, the search is applied
' again, but this time in the full search domain.
' 
hal.dev_update_off()
hal.dev_get_preferences("suppress_handled_exceptions_dlg",PreferenceValue)
hal.read_image(Image,"automotive/engine_part_001")
hal.dev_close_window()
hal.dev_open_window_fit_image(Image,0,0,-1,-1,WindowHandle)
hal.dev_set_line_width(3)
hal.set_display_font(WindowHandle,16,"mono","true","false")
hal.dev_display(Image)
' 
' Search parameters
hal.赋值(AngleExtent,90)
hal.赋值(AngleExtentTracking,20)
hal.赋值(MinScore,0.4)
hal.赋值(MinScoreTracking,0.5)
hal.赋值(TrackingRadius,80)
hal.赋值(ScaleROffset,0.1)
hal.赋值(ScaleCOffset,到小数(0.0))
hal.赋值(Metric,"use_polarity")
hal.赋值(CamParam,hal.创建元组(hal.除(到小数(12.0),1000),到小数(0.0),hal.乘(hal.除(4.65,1000000),2),hal.乘(hal.除(4.65,1000000),2),320,256,640,512))
' 
hal.read_region(Region,"automotive/engine_part_model_region")
hal.area_center(Region,Area,Row,Column)
hal.reduce_domain(Image,Region,ImageReduced)
hal.create_planar_uncalib_deformable_model(ImageReduced,"auto",hal.rad(hal.除(-hal.取元组小数(AngleExtent,),到小数(2.0))),hal.rad(AngleExtent),"auto",1,hal.加(1,ScaleROffset),"auto",1,hal.加(1,ScaleCOffset),"auto","none",Metric,"auto","auto",hal.创建元组(),hal.创建元组(),ModelID)
hal.set_deformable_model_origin(ModelID,-hal.取元组小数(Row,),-hal.取元组小数(Column,))
hal.get_deformable_model_contours(Contours,ModelID,1)
hal.dev_display(Image)
hal.dev_set_color("green")
hal.dev_set_draw("margin")
hal.dev_display(Contours)
hal.disp_message(WindowHandle,"Model created","window",12,12,"black","true")
hal.gen_circle(Circle,Row,Column,TrackingRadius)
hal.wait_seconds(3)
' 
hal.赋值(Score,hal.创建元组())
hal.select_obj(Contours,ObjectSelected,1)
hal.get_contour_xld(ObjectSelected,RowOrig,ColOrig)
hal.赋值(NotFound,hal.创建元组())
hal.赋值(TrackingFailed,hal.创建元组())
hal.赋值(NumImages,100)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, NumImages))
hal.wait_seconds(0.05)
hal.赋值(TrackingTime,0)
hal.read_image(Image,hal.加("automotive/engine_part_",hal.文本格式化(Index,"03")))
'     Either it is the first image, and one needs to perform full search,
'     or else the algorithm lost track of the object, and needs to start
'     all over again
hal.set_system("flush_graphic","false")
hal.dev_set_preferences("suppress_handled_exceptions_dlg","true")
.判断开始 (hal.大于(hal.取元素总数(Score),0))
'         Keep track of the object: project the image with the pose that the object had
'         in the previous image. The assumption is that the pose does not change much
'         from image to image (see parameter AngleExtentTracking). Update the pose after
'         successful search
'try
hal.count_seconds(S1)
hal.hom_mat2d_invert(HomMat2DOut,HomMat2DInvert)
hal.projective_trans_image(Image,TransImage,HomMat2DInvert,"bilinear","false","false")
hal.reduce_domain(TransImage,Circle,ImageReduced)
hal.find_planar_uncalib_deformable_model(TransImage,ModelID,hal.rad(hal.除(-hal.取元组小数(AngleExtentTracking,),2)),hal.rad(AngleExtentTracking),1,1,1,1,MinScoreTracking,1,1,0,0.9,hal.创建元组(),hal.创建元组(),HomMat2DTrack,Score)
hal.count_seconds(S2)
hal.dev_set_color("green")
hal.hom_mat2d_compose(HomMat2DOut,HomMat2DTrack,HomMat2DOut)
hal.projective_trans_contour_xld(Contours,ContoursProjTrans,HomMat2DOut)
hal.projective_trans_pixel(HomMat2DOut,hal.创建元组(hal.减(Row,1),hal.减(Row,1),hal.加(Row,1),hal.加(Row,1)),hal.创建元组(hal.减(Column,2),hal.加(Column,1),hal.加(Column,1),hal.减(Column,1)),RowTrans,ColTrans)
hal.vector_to_pose(hal.创建元组(-2,1,1,-1),hal.创建元组(-1,-1,1,1),hal.创建元组(),RowTrans,ColTrans,CamParam,"planar_analytic","error",Pose,Quality)
hal.pose_to_hom_mat3d(Pose,HomMat3D)
*' 不支持的方法：hal.catch(Exception)
hal.赋值(TrackingTime,hal.减(S2,S1))
hal.赋值(TrackingFailed,hal.创建元组(TrackingFailed,Index))
'endtry
.判断结束

.判断开始 (hal.等于(hal.取元素总数(Score),0))
'         Still no object found. Try full search.
'try
hal.count_seconds(S1)
hal.find_planar_uncalib_deformable_model(Image,ModelID,hal.rad(hal.除(-hal.取元组小数(AngleExtent,),到小数(2.0))),hal.rad(AngleExtent),1,hal.加(1,ScaleROffset),1,hal.加(1,ScaleCOffset),MinScore,1,1,0,0.9,hal.创建元组(),hal.创建元组(),HomMat2DOut,Score)
hal.count_seconds(S2)
hal.projective_trans_contour_xld(Contours,ContoursProjTrans,HomMat2DOut)
hal.projective_trans_pixel(HomMat2DOut,hal.创建元组(hal.减(Row,1),hal.减(Row,1),hal.加(Row,1),hal.加(Row,1)),hal.创建元组(hal.减(Column,2),hal.加(Column,1),hal.加(Column,1),hal.减(Column,1)),RowTrans,ColTrans)
hal.vector_to_pose(hal.创建元组(-2,1,1,-1),hal.创建元组(-1,-1,1,1),hal.创建元组(),RowTrans,ColTrans,CamParam,"planar_analytic","error",Pose,Quality)
hal.dev_set_color("green")
*' 不支持的方法：hal.catch(Exception)
hal.set_system("flush_graphic","true")
hal.dev_display(Image)
hal.赋值(NotFound,hal.创建元组(NotFound,Index))
Index ＝ hal.加 (Index, 1)
到循环尾 ()
'endtry
.判断结束

hal.dev_set_preferences("suppress_handled_exceptions_dlg",PreferenceValue)
hal.dev_display(Image)
hal.dev_display(ContoursProjTrans)
hal.disp_message(WindowHandle,hal.加(hal.加("Model found in ",hal.文本格式化(hal.乘(hal.减(hal.加(TrackingTime,S2),S1),1000),".1f"))," ms"),"window",12,12,"black","true")
hal.dev_set_colored(3)
hal.disp_3d_coord_system(WindowHandle,CamParam,Pose,100)
hal.set_system("flush_graphic","true")
hal.set_tposition(WindowHandle,-200,-200)
hal.write_string(WindowHandle,"")
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
hal.clear_deformable_model(ModelID)
hal.wait_seconds(3)
return()

.子程序 p_do_locate_pipe_joints_stereo
.局部变量 CamParam0, 视觉元组
.局部变量 CamParam1, 视觉元组
.局部变量 CamParam2, 视觉元组
.局部变量 CamParam3, 视觉元组
.局部变量 CameraSetupModelID, 视觉元组
.局部变量 DispTime, 视觉元组
.局部变量 Exception, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 HomMat3DObjToWorld, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImagePath, 视觉元组
.局部变量 ImagePrefix, 视觉元组
.局部变量 Images, 视觉对象
.局部变量 Img, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 MatchIndex, 视觉元组
.局部变量 MatchingDiff, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 MinScore, 视觉元组
.局部变量 ModelContours, 视觉对象
.局部变量 NumCameras, 视觉元组
.局部变量 NumImages, 视觉元组
.局部变量 NumMatches, 视觉元组
.局部变量 ObjPoseCam0, 视觉元组
.局部变量 ObjectModel3DIDAffineTrans, 视觉元组
.局部变量 OldImage, 视觉对象
.局部变量 Params, 视觉元组
.局部变量 PipeJointOM3DID, 视觉元组
.局部变量 PipeJointPileOM3DID, 视觉元组
.局部变量 PipeJointSMID, 视觉元组
.局部变量 Pose0, 视觉元组
.局部变量 Pose1, 视觉元组
.局部变量 Pose2, 视觉元组
.局部变量 Pose3, 视觉元组
.局部变量 Pose3DCamToObj, 视觉元组
.局部变量 Pose3DWorldToObj, 视觉元组
.局部变量 Poses, 视觉元组
.局部变量 PreferenceValue, 视觉元组
.局部变量 ReconsTime, 视觉元组
.局部变量 Scores, 视觉元组
.局部变量 Status, 视觉元组
.局部变量 StereoModelID, 视觉元组
.局部变量 SurfaceMatchingResultID, 视觉元组
.局部变量 T0, 视觉元组
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 T3, 视觉元组
.局部变量 T4, 视觉元组
.局部变量 T5, 视觉元组
.局部变量 Values, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WorldPose0, 视觉元组

' Reconstruct the three-dimensional surface of a pile of pipe
' joints by using a multi-view stereo setup with four similar
' cameras and detect the position of each joint by using
' surface-based 3D matching
' 
' 
' *****
' Initializations:
' *****
' 
hal.dev_update_off()
hal.dev_get_preferences("suppress_handled_exceptions_dlg",PreferenceValue)
hal.dev_set_preferences("suppress_handled_exceptions_dlg","true")
hal.赋值(ImagePath,"3d_machine_vision/multi_view/")
hal.赋值(ImagePrefix,"multi_view_pipe_joints")
hal.read_image(Image,hal.加(hal.加(ImagePath,ImagePrefix),"_cam_0_01"))
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,420,"black",WindowHandle)
hal.dev_set_draw("margin")
hal.set_display_font(WindowHandle,16,"mono","true","false")
' 
' *****
' Part 1: Read the parameters of the multi-view stereo setup
' *****
' Read the camera setup model from file and get the parameters
' and the poses of the cameras
'try
hal.read_camera_setup_model("Calibration/Multi-View/four_camera_setup_model.csm",CameraSetupModelID)
*' 不支持的方法：hal.catch(Exception)
.判断开始 (hal.等于(hal.取元素(Exception,0),5200))
init_camera_setup(CameraSetupModelID)
.默认
*' 不支持的方法：hal.throw(Exception)
.判断结束

'endtry
' 
hal.get_camera_setup_param(CameraSetupModelID,"general","num_cameras",NumCameras)
hal.get_camera_setup_param(CameraSetupModelID,0,"pose",Pose0)
hal.get_camera_setup_param(CameraSetupModelID,1,"pose",Pose1)
hal.get_camera_setup_param(CameraSetupModelID,2,"pose",Pose2)
hal.get_camera_setup_param(CameraSetupModelID,3,"pose",Pose3)
hal.get_camera_setup_param(CameraSetupModelID,0,"params",CamParam0)
hal.get_camera_setup_param(CameraSetupModelID,1,"params",CamParam1)
hal.get_camera_setup_param(CameraSetupModelID,2,"params",CamParam2)
hal.get_camera_setup_param(CameraSetupModelID,3,"params",CamParam3)
' 
' Create a multi-view stereo model, initialize it, and clear
' the camera setup, which is no longer required
hal.create_stereo_model(CameraSetupModelID,"surface_pairwise","persistence",1,StereoModelID)
hal.clear_camera_setup_model(CameraSetupModelID)
' -> Subsampling X, Y, Z
hal.set_stereo_model_param(StereoModelID,"sub_sampling_step",3)
hal.set_stereo_model_param(StereoModelID,"binocular_method","ncc")
' -> Interpolation aliasing by binocular image rectification
hal.set_stereo_model_param(StereoModelID,"rectif_interpolation","bilinear")
hal.set_stereo_model_param(StereoModelID,"rectif_sub_sampling",1.2)
' -> Binocular disparity parameters
hal.set_stereo_model_param(StereoModelID,"binocular_num_levels",1)
hal.set_stereo_model_param(StereoModelID,"binocular_mask_width",19)
hal.set_stereo_model_param(StereoModelID,"binocular_mask_height",19)
hal.set_stereo_model_param(StereoModelID,"binocular_texture_thresh",0)
hal.set_stereo_model_param(StereoModelID,"binocular_score_thresh",0.4)
hal.set_stereo_model_param(StereoModelID,"binocular_filter","left_right_check")
hal.set_stereo_model_param(StereoModelID,"binocular_sub_disparity","interpolation")
' -> Define bounding box and camera pairs
hal.set_stereo_model_param(StereoModelID,"bounding_box",hal.创建元组(-0.2,-0.07,-0.075,0.2,0.07,-0.004))
hal.set_stereo_model_image_pairs(StereoModelID,hal.创建元组(0,2),hal.创建元组(1,3))
' 
' *****
' Part 2: Create a surface model of the pipe fittings to be matched
' *****
hal.read_object_model_3d("pipe_joint","m",hal.创建元组(),hal.创建元组(),PipeJointOM3DID,Status)
hal.create_surface_model(PipeJointOM3DID,0.03,hal.创建元组(),hal.创建元组(),PipeJointSMID)
' 
' The next line is required in order to use the option
' 'hidden_surface_removal' in the operator
' project_object_model_3d (see below).
hal.prepare_object_model_3d(PipeJointOM3DID,"shape_based_matching_3d","true",hal.创建元组(),hal.创建元组())
' 
' *****
' Part 3: Reconstruct the surface of the pile of pipe fittings
'         and detect the position of up to MaxNumParts by using
'         surface-based 3D matching
' *****
hal.赋值(NumMatches,3)
hal.赋值(MinScore,.3)
hal.赋值(Params,hal.创建元组("num_matches","pose_ref_scoring_dist_rel"))
hal.赋值(Values,hal.创建元组(NumMatches,0.02))
' 
hal.pose_invert(Pose0,WorldPose0)
' 
hal.赋值(NumImages,5)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, NumImages))
'     
'     Read and display the images
read_multi_view_stereo_images(Images,hal.克隆元组(ImagePath),hal.克隆元组(ImagePrefix),hal.克隆元组(Index),hal.克隆元组(NumCameras))
'     
'     Reconstruct the 3D scene (the pile of pipe fittings)
hal.赋值(Message,"Performing the reconstruction...")
display_multi_view_stereo_images(hal.克隆对象(Images),hal.克隆元组(WindowHandle))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
'     
hal.count_seconds(T0)
hal.reconstruct_surface_stereo(Images,StereoModelID,PipeJointPileOM3DID)
hal.count_seconds(T1)
hal.赋值(ReconsTime,hal.减(T1,T0))
'     
'     Perform surface-based 3D matching
hal.赋值(Message,hal.加(hal.加("Search ",NumMatches)," best parts with surface based matching..."))
hal.disp_message(WindowHandle,Message,"window",36,12,"black","true")
hal.count_seconds(T2)
hal.find_surface_model(PipeJointSMID,PipeJointPileOM3DID,0.03,0.05,MinScore,"false",Params,Values,Poses,Scores,SurfaceMatchingResultID)
hal.count_seconds(T3)
hal.赋值(MatchingDiff,hal.减(T3,T2))
'     
'     Display the results
hal.set_system("flush_graphic","false")
hal.select_obj(Images,Img,1)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
hal.dev_display(Img)
hal.count_seconds(T4)
hal.赋值 (MatchIndex, 0)
.判断循环首 (hal.小于等于 (MatchIndex, hal.减(hal.取元素总数(Scores),1)))
hal.pose_to_hom_mat3d(hal.取元素范围(Poses,hal.乘(MatchIndex,7),hal.加(hal.乘(MatchIndex,7),6)),HomMat3DObjToWorld)
hal.pose_invert(hal.取元素范围(Poses,hal.乘(MatchIndex,7),hal.加(hal.乘(MatchIndex,7),6)),Pose3DWorldToObj)
hal.pose_compose(Pose3DWorldToObj,Pose0,Pose3DCamToObj)
hal.pose_invert(Pose3DCamToObj,ObjPoseCam0)
'         
'         Display the coordinate system of the part
hal.dev_set_colored(3)
hal.dev_set_line_width(3)
hal.disp_3d_coord_system(WindowHandle,CamParam0,ObjPoseCam0,0.03)
'         Display the faces of the part
hal.affine_trans_object_model_3d(PipeJointOM3DID,HomMat3DObjToWorld,ObjectModel3DIDAffineTrans)
hal.project_object_model_3d(ModelContours,ObjectModel3DIDAffineTrans,CamParam0,WorldPose0,hal.创建元组("data","hidden_surface_removal"),hal.创建元组("faces","true"))
hal.dev_set_line_width(2)
hal.dev_set_color("green")
hal.dev_display(ModelContours)
'         
hal.clear_object_model_3d(ObjectModel3DIDAffineTrans)
MatchIndex ＝ hal.加 (MatchIndex, 1)
.判断循环尾 ()
hal.set_system("flush_graphic","true")
hal.count_seconds(T5)
hal.赋值(DispTime,hal.减(T5,T4))
'     
hal.赋值(Message,hal.加(hal.加("Reconstruction: ",hal.文本格式化(ReconsTime,".2f"))," s"))
hal.赋值元组元素(Message,1,hal.加(hal.加(hal.加(hal.加("Found ",hal.取元素总数(Scores))," pipe joint(s) in "),hal.文本格式化(MatchingDiff,".2f"))," s"))
'*     Message[2] := 'Visualization: ' + DispTime$'.1f' + ' s'
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.disp_message(WindowHandle,"Camera 0","window",hal.减(Height,36),12,"white","false")
hal.wait_seconds(2)
'     
'     clear the 3D object model
hal.clear_object_model_3d(PipeJointPileOM3DID)
hal.copy_obj(Images,OldImage,1,1)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
' Clear the stereo model and the surface model
hal.clear_stereo_model(StereoModelID)
hal.clear_surface_model(PipeJointSMID)
hal.clear_object_model_3d(PipeJointOM3DID)
' 
hal.dev_set_preferences("suppress_handled_exceptions_dlg",PreferenceValue)
hal.wait_seconds(3)
return()

.子程序 display_multi_view_stereo_images
.参数 Images, obj
.参数 WindowHandle, tuple
.局部变量 ColIdx, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 Img, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 NumCols, 视觉元组
.局部变量 NumImages, 视觉元组
.局部变量 RowIdx, 视觉元组
.局部变量 TiledImage, 视觉对象
.局部变量 Width, 视觉元组

' Display the images of a multi-view stereo setup
' consisting of four cameras
' 
hal.dev_set_window(WindowHandle)
' 
hal.count_obj(Images,NumImages)
.判断开始 (hal.不等于(NumImages,4))
hal.disp_message(WindowHandle,"Wrong number of images provided!","window",12,12,"black","true")
hal.stop()
.判断结束

' 
hal.赋值(NumCols,2)
hal.select_obj(Images,Img,1)
hal.get_image_size(Img,Width,Height)
hal.tile_images(Images,TiledImage,NumCols,"horizontal")
hal.dev_set_part(0,0,hal.减(hal.乘(2,Height),1),hal.减(hal.乘(2,Width),1))
hal.dev_display(TiledImage)
' 
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(NumImages,1)))
hal.赋值(RowIdx,hal.加(hal.除(Index,NumCols),1))
hal.赋值(ColIdx,hal.求模(Index,NumCols))
hal.disp_message(WindowHandle,hal.加("Camera ",Index),"image",hal.减(hal.乘(RowIdx,Height),72),hal.加(hal.乘(ColIdx,Width),12),"white","false")
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()
' 

.子程序 init_camera_setup
.参数 CameraSetupModelID, tuple, 参考
.局部变量 CamParam0, 视觉元组
.局部变量 CamParam1, 视觉元组
.局部变量 CamParam2, 视觉元组
.局部变量 CamParam3, 视觉元组
.局部变量 Pose0, 视觉元组
.局部变量 Pose1, 视觉元组
.局部变量 Pose2, 视觉元组
.局部变量 Pose3, 视觉元组

' 
' Define the internal and external camera parameters
hal.赋值(CamParam0,hal.创建元组(0.00850373,4008.61,-2.95892e+008,2.37315e+013,0.139749,-0.00367983,5.99965e-006,6e-006,362.715,236.769,752,480))
hal.赋值(CamParam1,hal.创建元组(0.00854019,3445.26,-1.18075e+008,6.40715e+012,-0.0527818,-0.192439,5.99894e-006,6e-006,406.13,254.15,752,480))
hal.赋值(CamParam2,hal.创建元组(0.00852569,3938.44,-2.75967e+008,2.27295e+013,0.231091,0.193667,6.00001e-006,6e-006,367.159,242.477,752,480))
hal.赋值(CamParam3,hal.创建元组(0.00853794,3793.19,-3.49193e+008,3.9611e+013,0.0264028,0.147156,6.00169e-006,6e-006,397.066,224.671,752,480))
' 
hal.赋值(Pose0,hal.创建元组(0.0496073,0.0280127,-0.431281,3.5466,354.117,179.758,0))
hal.赋值(Pose1,hal.创建元组(0.0495484,-0.0297644,-0.429654,355.333,354.014,359.147,0))
hal.赋值(Pose2,hal.创建元组(-0.0411315,-0.0294687,-0.427325,355.519,4.45356,359.876,0))
hal.赋值(Pose3,hal.创建元组(-0.0414501,0.0288074,-0.429167,2.94179,4.59538,179.173,0))
' 
' Create a camera setup model and set its parameters
hal.create_camera_setup_model(4,CameraSetupModelID)
' 
hal.set_camera_setup_cam_param(CameraSetupModelID,0,"area_scan_polynomial",CamParam0,Pose0)
hal.set_camera_setup_cam_param(CameraSetupModelID,1,"area_scan_polynomial",CamParam1,Pose1)
hal.set_camera_setup_cam_param(CameraSetupModelID,2,"area_scan_polynomial",CamParam2,Pose2)
hal.set_camera_setup_cam_param(CameraSetupModelID,3,"area_scan_polynomial",CamParam3,Pose3)
return()

.子程序 read_multi_view_stereo_images
.参数 Images, obj, 参考
.参数 ImagePath, tuple
.参数 ImagePrefix, tuple
.参数 SceneIndex, tuple
.参数 NumCamera, tuple
.局部变量 Img, 视觉对象
.局部变量 Index, 视觉元组

' Read the images of the multi-view stereo setup
' 
hal.read_image(Images,hal.加(hal.加(hal.加(ImagePath,ImagePrefix),"_cam_0_"),hal.文本格式化(SceneIndex,".02")))
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, hal.减(NumCamera,1)))
hal.read_image(Img,hal.加(hal.加(hal.加(hal.加(hal.加(ImagePath,ImagePrefix),"_cam_"),Index),"_"),hal.文本格式化(SceneIndex,".02")))
hal.concat_obj(Images,Img,Images)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()

.子程序 gen_warped_mesh
.参数 VectorField, obj
.参数 WarpedMesh, obj, 参考
.参数 Step, tuple
.局部变量 Column, 视觉元组
.局部变量 ContC, 视觉元组
.局部变量 ContR, 视觉元组
.局部变量 Contour, 视觉对象
.局部变量 DColumn, 视觉对象
.局部变量 DRow, 视觉对象
.局部变量 GrayColumn, 视觉元组
.局部变量 GrayRow, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Width, 视觉元组

' Generate a grid of the deformation from the VectorField
' The step width is given by the parameter Step.
' 
hal.gen_empty_obj(WarpedMesh)
hal.count_obj(VectorField,Number)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, Number))
hal.select_obj(VectorField,ObjectSelected,Index)
hal.vector_field_to_real(ObjectSelected,DRow,DColumn)
hal.get_image_size(VectorField,Width,Height)
'     Horizontal lines
hal.赋值 (ContR, 0.5)
.判断循环首 (hal.小于等于 (ContR, hal.减(hal.取元素(Height,0),1)))
hal.赋值(Column,hal.创建序列(0.5,hal.减(hal.取元素(Width,0),1), 1))
hal.tuple_gen_const(hal.减(hal.取元素(Width,0),1),ContR,Row)
hal.get_grayval_interpolated(DRow,Row,Column,"bilinear",GrayRow)
hal.get_grayval_interpolated(DColumn,Row,Column,"bilinear",GrayColumn)
hal.gen_contour_polygon_xld(Contour,GrayRow,GrayColumn)
hal.concat_obj(WarpedMesh,Contour,WarpedMesh)
ContR ＝ hal.加 (ContR, Step)
.判断循环尾 ()
'     Vertical lines
hal.赋值 (ContC, 0.5)
.判断循环首 (hal.小于等于 (ContC, hal.减(hal.取元素(Width,0),1)))
hal.赋值(Row,hal.创建序列(0.5,hal.减(hal.取元素(Height,0),1), 1))
hal.tuple_gen_const(hal.减(hal.取元素(Height,0),1),ContC,Column)
hal.get_grayval_interpolated(DRow,Row,Column,"bilinear",GrayRow)
hal.get_grayval_interpolated(DColumn,Row,Column,"bilinear",GrayColumn)
hal.gen_contour_polygon_xld(Contour,GrayRow,GrayColumn)
hal.concat_obj(WarpedMesh,Contour,WarpedMesh)
ContC ＝ hal.加 (ContC, Step)
.判断循环尾 ()
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()

.子程序 p_find_cocoa_package_local_deformable
.局部变量 Area, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ContoursAffinTrans, 视觉对象
.局部变量 DeformedContours, 视觉对象
.局部变量 FoundOut, 视觉元组
.局部变量 HomMat2DIdentity, 视觉元组
.局部变量 HomMat2DTranslate, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageRectified, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 J, 视觉元组
.局部变量 ModelContours, 视觉对象
.局部变量 ModelID, 视觉元组
.局部变量 ModelImage, 视觉对象
.局部变量 NumImages, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 Smoothness, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 VectorField, 视觉对象
.局部变量 WarpedMesh, 视觉对象
.局部变量 WindowHandle, 视觉元组

' This example program shows how to use local deformable
' matching to find objects that are deformed.
' 
' Note that to find deformed objects you can
' - apply shape-based matching using the parameter
' 'max_deformation' or
' - apply local deformable matching.
' 
' In this example, the task is solved with local
' deformable matching. You can compare it to the example
' 'find_cocoa_packages_max_deformations.hdev', which
' solves the same task with shape-based matching and the
' parameter 'max_deformation'. Shape-based matching is
' significantly faster, but local deformable matching is
' more robust to different types of deformations.
' For example, the deformations in the example program
' 'find_peanut_chocolate_candies_local_deformable.hdev'
' can not be handled by shape-based matching.
' 
hal.dev_update_off()
hal.read_image(ModelImage,"food/cocoa_package_model")
hal.dev_close_window()
hal.dev_open_window_fit_image(ModelImage,0,0,-1,-1,WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
' 
' Create and display the local deformable model
hal.create_local_deformable_model(ModelImage,"auto",hal.rad(-15),hal.rad(30),"auto",1,1,"auto",1,1,"auto","none","use_polarity",hal.创建元组(40,60),"auto",hal.创建元组(),hal.创建元组(),ModelID)
hal.get_deformable_model_contours(ModelContours,ModelID,1)
hal.area_center(ModelImage,Area,Row,Column)
hal.hom_mat2d_identity(HomMat2DIdentity)
hal.hom_mat2d_translate(HomMat2DIdentity,Row,Column,HomMat2DTranslate)
hal.affine_trans_contour_xld(ModelContours,ContoursAffinTrans,HomMat2DTranslate)
hal.dev_set_line_width(2)
hal.dev_set_color("yellow")
hal.dev_display(ModelImage)
hal.dev_display(ContoursAffinTrans)
hal.disp_message(WindowHandle,"Model image and contours","window",12,12,"black","true")
hal.wait_seconds(3)
' 
hal.赋值(Smoothness,19)
hal.赋值(NumImages,13)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, NumImages))
hal.read_image(Image,hal.加("food/cocoa_packages_",hal.文本格式化(Index,"02")))
hal.dev_resize_window_fit_image(Image,0,0,-1,-1)
hal.dev_display(Image)
'*     disp_message (WindowHandle, 'Search ...', 'window', 12, 12, 'black', 'true')
hal.count_seconds(S1)
'     Find the model in the deformed search image.
'     As result, the rectified image, the respective
'     vector field, and the found contours are queried.
hal.find_local_deformable_model(Image,ImageRectified,VectorField,DeformedContours,ModelID,hal.rad(-14),hal.rad(28),1,1,1,1,0.78,0,0,0,0.45,hal.创建元组("image_rectified","vector_field","deformed_contours"),hal.创建元组("deformation_smoothness","expand_border","subpixel"),hal.创建元组(Smoothness,0,0),Score,Row,Column)
hal.count_seconds(S2)
hal.赋值(Time,hal.减(S2,S1))
'     Visualize the deformation as a mesh generated from
'     the returned vector field
gen_warped_mesh(hal.克隆对象(VectorField),WarpedMesh,hal.创建元组(hal.除(Smoothness,2)))
hal.dev_set_line_width(1)
hal.dev_set_color("yellow")
hal.dev_display(WarpedMesh)
hal.赋值元组元素(FoundOut,hal.取元组整数(Index),hal.取元素总数(Score))
hal.dev_set_line_width(2)
hal.dev_set_color("green")
hal.dev_display(DeformedContours)
hal.disp_message(WindowHandle,hal.加(hal.加(hal.加(hal.取元素总数(Score)," matches found in "),hal.文本格式化(Time,"1.2f"))," s"),"window",12,12,"black","true")
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(Score),1)))
hal.disp_message(WindowHandle,hal.加("Score: ",hal.文本格式化(hal.取元素(Score,J),".2f")),"image",350,hal.减(hal.取元素(Column,J),80),"black","true")
J ＝ hal.加 (J, 1)
.判断循环尾 ()
.判断开始 (hal.小于(Index,5))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(2)
.判断结束

Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
' Clean up
hal.wait_seconds(3)
hal.clear_deformable_model(ModelID)
return()

.子程序 p_do_apply_sample_identifier_wine_bottle
.局部变量 Color, 视觉元组
.局部变量 Errors, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageDirectory, 视觉元组
.局部变量 ImageFileName, 视觉元组
.局部变量 ImageFileNames, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 NumIterations, 视觉元组
.局部变量 NumTests, 视觉元组
.局部变量 ObjectID, 视觉元组
.局部变量 ObjectIDs, 视觉元组
.局部变量 ObjectIdx, 视觉元组
.局部变量 ObjectName, 视觉元组
.局部变量 ObjectNames, 视觉元组
.局部变量 ObjectSampleIdx, 视觉元组
.局部变量 RandomIndices, 视觉元组
.局部变量 Rating, 视觉元组
.局部变量 ResultObjectName, 视觉元组
.局部变量 Runtime, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 SampleIdentifier, 视觉元组
.局部变量 TrainingImageFileNames, 视觉元组
.局部变量 TrainingObjectIDs, 视觉元组
.局部变量 TrainingObjectNames, 视觉元组
.局部变量 WindowHandle, 视觉元组

' This procedure shows how to use the sample-based identification
' to identify different objects.
' First, the sample identifier is created, prepared, trained,
' and written to disk. In later runs, the trained sample
' identifier is read from disk to avoid the time-consuming
' preparation step. In the run-time phase, the trained sample
' identifier is used to identify new images of vegetables.
' 
hal.dev_update_off()
' 
' Get the image file names, the object names and IDs
hal.赋值(ImageDirectory,"food/wine_label")
get_object_images(hal.克隆元组(ImageDirectory),ObjectNames,ObjectIDs,ImageFileNames,TrainingObjectNames,TrainingObjectIDs,TrainingImageFileNames)
' 
hal.dev_close_window()
hal.dev_open_window(0,0,640,512,"black",WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
' Create a new sample identifier. Since we have color images available
' we use the color in addition to the texture information for
' identification.
hal.create_sample_identifier("add_color_info","true",SampleIdentifier)
hal.set_sample_identifier_param(SampleIdentifier,"image_resize_value",0.1)
' Prepare the sample identifier by adding some representive sample
' images that show the different types of objects. For this,
' we simply use the training images.
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(TrainingImageFileNames),1)))
hal.read_image(Image,hal.取元素(TrainingImageFileNames,Index))
hal.dev_display(Image)
hal.disp_message(WindowHandle,hal.创建元组(hal.加("Add a sample of ",hal.取元素(TrainingObjectNames,Index)),"to the sample identifier."),"window",12,12,"black","true")
'     Add the current image as preparation data. Because we know
'     the object ID, we can use it in order to label the preparation
'     data. Thus, we can later reuse it for training and do not need to
'     add additional training data.
hal.add_sample_identifier_preparation_data(Image,SampleIdentifier,hal.取元素(TrainingObjectIDs,Index),hal.创建元组(),hal.创建元组(),ObjectSampleIdx)
'     Optionally add the object name to the sample identifier for
'     convinience reasons.
hal.set_sample_identifier_object_info(SampleIdentifier,hal.取元素(TrainingObjectIDs,Index),"preparation_object_name",hal.取元素(TrainingObjectNames,Index))
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' Now, we can prepare the identifier
hal.dev_clear_window()
hal.赋值(Message,hal.创建元组("Prepare and train the sample identifier","(this might take some seconds)"))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.count_seconds(S1)
hal.prepare_sample_identifier(SampleIdentifier,"true",hal.创建元组(),hal.创建元组())
' Use the preparation data to train the identifier
hal.train_sample_identifier(SampleIdentifier,hal.创建元组(),hal.创建元组())
hal.count_seconds(S2)
hal.赋值(Runtime,hal.减(S2,S1))
hal.赋值(Message,hal.创建元组(Message,hal.加(hal.加("The sample identifier was prepared and trained in ",hal.文本格式化(Runtime,".1")),"s.")))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(1)
' 
' Identify new objects
hal.赋值(Errors,0)
hal.赋值(RandomIndices,hal.sort_index(hal.rand(hal.取元素总数(ImageFileNames))))
' Choose how many images should be tested
hal.赋值(NumTests,50)
' Use the following line to test all images
hal.赋值(NumIterations,hal.求最小值(hal.创建元组(NumTests,hal.取元素总数(RandomIndices))))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, NumIterations))
'     Randomly select a run-time image
hal.赋值(Index,hal.取元素(RandomIndices,hal.减(I,1)))
hal.赋值(ImageFileName,hal.取元素(ImageFileNames,Index))
hal.赋值(ObjectID,hal.取元素(ObjectIDs,Index))
hal.赋值(ObjectName,hal.取元素(ObjectNames,Index))
hal.read_image(Image,ImageFileName)
'     Apply the sample identifier to identify the new objects
hal.apply_sample_identifier(Image,SampleIdentifier,1,0,hal.创建元组(),hal.创建元组(),ObjectIdx,Rating)
'     Get the name of the identified object for visualization purposes
hal.get_sample_identifier_object_info(SampleIdentifier,ObjectIdx,"training_object_name",ResultObjectName)
.判断开始 (hal.不等于(ObjectIdx,ObjectID))
'         Use red color for incorrect identifications
hal.赋值(Color,"red")
hal.赋值(Errors,hal.加(Errors,1))
.默认
hal.赋值(Color,"forest green")
.判断结束

hal.dev_display(Image)
hal.赋值(Message,hal.创建元组(hal.加("Current object: ",ObjectName),hal.加("Identified as:  ",ResultObjectName),hal.加(hal.加(hal.加(hal.加(hal.加(hal.加("Error rate: (",Errors),"/"),I),") = "),hal.文本格式化(hal.除(hal.乘(到小数(100.0),Errors),I),".1f")),"%")))
hal.disp_message(WindowHandle,Message,"window",12,12,hal.创建元组("black",Color,"black"),"true")
'     
.判断开始 (hal.小于(I,8))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
' Clear the sample identifier
hal.clear_sample_identifier(SampleIdentifier)
hal.wait_seconds(3)
return()

.子程序 get_object_images
.参数 Directory, tuple
.参数 ObjectNames, tuple, 参考
.参数 ObjectIDs, tuple, 参考
.参数 ImageFileNames, tuple, 参考
.参数 TrainingObjectNames, tuple, 参考
.参数 TrainingObjectIDs, tuple, 参考
.参数 TrainingImageFileNames, tuple, 参考
.局部变量 I, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 Indices, 视觉元组
.局部变量 Matches, 视觉元组
.局部变量 ObjectID, 视觉元组
.局部变量 ObjectIDsUniq, 视觉元组
.局部变量 UniqObjectNames, 视觉元组

' Get all images in the directory
hal.list_image_files(Directory,"default",hal.创建元组(),ImageFileNames)
hal.赋值(ImageFileNames,hal.sort(ImageFileNames))
hal.tuple_regexp_match(ImageFileNames,".*/(.*)"+字符(92)+"..{3}$",Matches)
hal.tuple_regexp_replace(Matches,"_[0-9]+","",ObjectNames)
hal.tuple_uniq(ObjectNames,UniqObjectNames)
hal.赋值(ObjectIDs,hal.创建元组())
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(ObjectNames),1)))
hal.tuple_find(UniqObjectNames,hal.取元素(ObjectNames,Index),Indices)
hal.赋值(ObjectIDs,hal.创建元组(ObjectIDs,Indices))
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' Extract the training images
hal.赋值(TrainingObjectNames,hal.创建元组())
hal.赋值(TrainingObjectIDs,hal.创建元组())
hal.赋值(TrainingImageFileNames,hal.创建元组())
hal.tuple_uniq(ObjectIDs,ObjectIDsUniq)
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(hal.取元素总数(ObjectIDsUniq),1)))
hal.赋值(ObjectID,hal.取元素(ObjectIDsUniq,Index))
hal.tuple_find(ObjectIDs,ObjectID,Indices)
'     Arbitrarily chose the first image of the same ID
'     as the training image
hal.赋值(I,hal.取元素(Indices,0))
hal.赋值(TrainingObjectNames,hal.创建元组(TrainingObjectNames,hal.取元素(ObjectNames,I)))
hal.赋值(TrainingObjectIDs,hal.创建元组(TrainingObjectIDs,hal.取元素(ObjectIDs,I)))
hal.赋值(TrainingImageFileNames,hal.创建元组(TrainingImageFileNames,hal.取元素(ImageFileNames,I)))
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()

.子程序 p_do_read_braille_photometric_stereo
.局部变量 Albedo, 视觉对象
.局部变量 Braille, 视觉对象
.局部变量 Character, 视觉元组
.局部变量 Code, 视觉元组
.局部变量 CodeTable, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 CurrentDot, 视觉对象
.局部变量 CurrentLetter, 视觉对象
.局部变量 CurrentRectangle, 视觉对象
.局部变量 Dots, 视觉对象
.局部变量 Gradient, 视觉对象
.局部变量 HeightField, 视觉对象
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 Images, 视觉对象
.局部变量 J, 视觉元组
.局部变量 Letters, 视觉对象
.局部变量 Limits, 视觉元组
.局部变量 MaxFirstColumn, 视觉元组
.局部变量 MaxFirstRow, 视觉元组
.局部变量 MaxSecondRow, 视觉元组
.局部变量 MeanCurvature, 视觉对象
.局部变量 Message, 视觉元组
.局部变量 NumDots, 视觉元组
.局部变量 NumLetters, 视觉元组
.局部变量 ObjectSelected, 视觉对象
.局部变量 Partitioned, 视觉对象
.局部变量 RegionClosing, 视觉对象
.局部变量 RegionDilation, 视觉对象
.局部变量 RegionDilation1, 视觉对象
.局部变量 RegionTrans, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 Regions, 视觉对象
.局部变量 ResultType, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 Slants, 视觉元组
.局部变量 Tilts, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 _Area, 视觉元组

' This procedure demonstrates the use of the photometric stereo technique
' for the inspection and reading of braille text on a pharmaceutical
' package. Input are 4 images taken from the pharmaceutical package with
' light coming from different orientations.
' 
' Initialization
hal.dev_update_off()
hal.read_image(Images,hal.加("photometric_stereo/braille_0",hal.创建序列(1,4, 1)))
hal.select_obj(Images,Image,1)
hal.dev_close_window()
hal.dev_open_window(0,0,640,312,"black",WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
hal.dev_set_draw("margin")
hal.dev_set_colored(12)
hal.dev_display(Image)
hal.赋值(Message,"Four different light orientations are used:")
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(3)
' This code table maps between the hexadecimal representation
' of the braille pattern and the corresponding character.
' In this case a german 6-dot code is used.
hal.赋值(CodeTable,hal.创建元组("","a",",","b",".","k",";","l","麓","c","i","f","盲u","m","s","p","","e",":","h","*","o","!","r","CAPS","d","j","g","盲","n","t","q","lcase","au","?","eu","-","u",""+#引号+"","v","Cap","ei","枚","","ie","x","","","","sch","","眉",""+#引号+"","z","()","","<e>","ch","w","","","y","st",""))
' 
' Show input images with different illumination
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 4))
hal.赋值(Message,hal.加(hal.加("Acquire image ",I)," of 4"))
hal.select_obj(Images,ObjectSelected,I)
hal.dev_display(ObjectSelected)
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(0.5)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
' Apply photometric stereo to determine the albedo and compute the mean
' curvature of the surface
hal.赋值(Tilts,hal.创建元组(6.1,到小数(95.0),-176.1,-86.8))
hal.赋值(Slants,hal.创建元组(41.4,42.6,41.7,40.9))
hal.赋值(ResultType,"gradient")
hal.photometric_stereo(Images,HeightField,Gradient,Albedo,Slants,Tilts,ResultType,"poisson",hal.创建元组(),hal.创建元组())
' 
' Calculate the mean curvature of the surface
' using the gradient field as input for the operator
' derivate_vector_field.
hal.derivate_vector_field(Gradient,MeanCurvature,1,"mean_curvature")
' 
' It is easy to segment the dots in the curvature image
hal.dev_display(MeanCurvature)
hal.disp_message(WindowHandle,"The curvature image is used for reading the characters","window",10,10,"black","true")
hal.wait_seconds(4)
' 
' Segment dots
hal.threshold(MeanCurvature,Regions,-0.14,-0.017)
hal.connection(Regions,ConnectedRegions)
hal.dilation_circle(ConnectedRegions,RegionDilation,1.5)
hal.select_shape(RegionDilation,Braille,hal.创建元组("area","roundness"),"and",hal.创建元组(191.82,0.8108),hal.创建元组(360.12,1))
hal.union1(Braille,RegionUnion)
' 
' Group dots to words and characters
hal.closing_rectangle1(Regions,RegionClosing,90,40)
hal.connection(RegionClosing,ConnectedRegions)
hal.shape_trans(ConnectedRegions,RegionTrans,"rectangle1")
hal.select_shape(RegionTrans,SelectedRegions,"height","and",50,90)
hal.dilation_rectangle1(SelectedRegions,RegionDilation1,21,1)
hal.partition_dynamic(RegionDilation1,Partitioned,72,5)
hal.intersection(Partitioned,RegionUnion,Letters)
' 
' Display segmentation result
hal.dev_display(Image)
hal.dev_set_draw("margin")
hal.dev_set_line_width(2)
hal.dev_display(Partitioned)
hal.dev_display(Letters)
hal.disp_message(WindowHandle,"Result","window",10,10,"black","true")
' 
' Decode text letter by letter
hal.set_display_font(WindowHandle,14,"mono","true","false")
hal.count_obj(Letters,NumLetters)
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, NumLetters))
'     
'     Define borders for the six dot sectors inside the rectangle
hal.select_obj(Partitioned,CurrentRectangle,I)
hal.region_features(CurrentRectangle,hal.创建元组("row1","height","column"),Limits)
hal.赋值(MaxFirstRow,hal.加(hal.取元素(Limits,0),hal.除(hal.取元素(Limits,1),到小数(3.0))))
hal.赋值(MaxSecondRow,hal.加(hal.取元素(Limits,0),hal.除(hal.乘(hal.取元素(Limits,1),2),到小数(3.0))))
hal.赋值(MaxFirstColumn,hal.取元素(Limits,2))
'     
'     Decode the letter dot by dot
'     
'     Code values calculated depending
'     on the presence of dots using
'     the following scheme:
'        (1) ( 8)
'        (2) (16)
'        (4) (32)
'     If a dot is present, the corresponding
'     value is added to the Code.
'     This way, 2^6 = 64 different codes are possible.
hal.select_obj(Letters,CurrentLetter,I)
hal.connection(CurrentLetter,Dots)
hal.count_obj(Dots,NumDots)
hal.赋值(Code,0)
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, NumDots))
hal.select_obj(Dots,CurrentDot,J)
hal.area_center(CurrentDot,_Area,Row,Column)
.判断开始 (hal.小于等于(Column,MaxFirstColumn))
.判断开始 (hal.小于等于(Row,MaxFirstRow))
'                 Left upper (1)
hal.赋值(Code,hal.加(Code,1))
.判断 (hal.小于等于(Row,MaxSecondRow))
'                 Left middle (2)
hal.赋值(Code,hal.加(Code,2))
.默认
'                 Left lower (4)
hal.赋值(Code,hal.加(Code,4))
.判断结束

.默认
.判断开始 (hal.小于等于(Row,MaxFirstRow))
'                 Right upper (8)
hal.赋值(Code,hal.加(Code,8))
.判断 (hal.小于等于(Row,MaxSecondRow))
'                 Right middle (16)
hal.赋值(Code,hal.加(Code,16))
.默认
'                 Right lower (32)
hal.赋值(Code,hal.加(Code,32))
.判断结束

.判断结束

J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.赋值元组元素(Character,hal.取元组整数(hal.减(I,1)),hal.取元素(CodeTable,Code))
hal.disp_message(WindowHandle,hal.取元素(CodeTable,Code),"image",hal.加(hal.取元素(Limits,0),hal.取元素(Limits,1)),hal.减(hal.取元素(Limits,2),20),"black","true")
I ＝ hal.加 (I, 1)
.判断循环尾 ()
hal.wait_seconds(5)
return()

.子程序 p_do_inspect_leather_photometric_stereo
.局部变量 Albedo, 视觉对象
.局部变量 Area, 视觉元组
.局部变量 Circle, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 ConnectedRegions1, 视觉对象
.局部变量 ConnectedRegions2, 视觉对象
.局部变量 Curl, 视觉对象
.局部变量 CurlGradient, 视觉对象
.局部变量 Defects, 视觉对象
.局部变量 Gradient, 视觉对象
.局部变量 HeightField, 视觉对象
.局部变量 I, 视觉元组
.局部变量 ImageAbs, 视觉对象
.局部变量 Images, 视觉对象
.局部变量 MeanCurvature, 视觉对象
.局部变量 Message, 视觉元组
.局部变量 NoTextured, 视觉对象
.局部变量 ObjectSelected, 视觉对象
.局部变量 Region, 视觉对象
.局部变量 Region1, 视觉对象
.局部变量 Region2, 视觉对象
.局部变量 RegionClosing, 视觉对象
.局部变量 RegionCount, 视觉对象
.局部变量 RegionCount1, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 RegionUnion1, 视觉对象
.局部变量 ResultType, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SelectedRegions, 视觉对象
.局部变量 SelectedRegions1, 视觉对象
.局部变量 SelectedRegions2, 视觉对象
.局部变量 SelectedRegions3, 视觉对象
.局部变量 Slants, 视觉元组
.局部变量 Tilts, 视觉元组
.局部变量 WindowHandle, 视觉元组

' This procedure demonstrates the use of the photometric stereo technique
' for the inspection of leather samples.
' Input are 4 images taken from different leather sample with light coming
' from different orientations.
' 
' Initialization
hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,480,"black",WindowHandle)
hal.set_display_font(WindowHandle,14,"mono","true","false")
' 
' Part 1
' Show input images with different illumination
hal.read_image(Images,hal.加("photometric_stereo/leather_1_0",hal.创建序列(1,4, 1)))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 4))
hal.赋值(Message,hal.加(hal.加("Sample 1: Acquire image ",I)," of 4"))
hal.select_obj(Images,ObjectSelected,I)
hal.dev_display(ObjectSelected)
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(0.5)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
' Apply photometric stereo to determine the albedo
hal.赋值(Tilts,hal.创建元组(6.1,到小数(95.0),-176.1,-86.8))
hal.赋值(Slants,hal.创建元组(41.4,42.6,41.7,40.9))
hal.赋值(ResultType,hal.创建元组("gradient","albedo"))
hal.photometric_stereo(Images,HeightField,Gradient,Albedo,Slants,Tilts,ResultType,"poisson",hal.创建元组(),hal.创建元组())
' 
' Detect defects
hal.var_threshold(Albedo,Region,15,15,0.2,0.05,"light")
hal.connection(Region,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",10,99999)
hal.union1(SelectedRegions,RegionUnion)
hal.closing_circle(RegionUnion,RegionClosing,3.5)
hal.connection(RegionClosing,Defects)
hal.area_center(Defects,Area,Row,Column)
hal.gen_circle(Circle,Row,Column,hal.gen_tuple_const(hal.取元素总数(Row),hal.加(hal.sqrt(Area),30)))
' Display the defects
hal.dev_display(Albedo)
hal.dev_set_color("red")
hal.dev_set_draw("margin")
hal.dev_set_line_width(4)
hal.dev_display(Circle)
hal.disp_message(WindowHandle,"A defect can be easily detected in the Albedo image","window",12,12,"black","true")
hal.wait_seconds(5)
' 
' Part 2
' Show input images with different illumination
hal.read_image(Images,hal.加("photometric_stereo/leather_2_0",hal.创建序列(1,4, 1)))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 4))
hal.赋值(Message,hal.加(hal.加("Sample 2: Acquire image ",I)," of 4"))
hal.select_obj(Images,ObjectSelected,I)
hal.dev_display(ObjectSelected)
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(0.5)
I ＝ hal.加 (I, 1)
.判断循环尾 ()
' 
' Apply photometric stereo to determine the albedo
hal.photometric_stereo(Images,HeightField,Gradient,Albedo,Slants,Tilts,ResultType,"poisson",hal.创建元组(),hal.创建元组())
hal.threshold(Albedo,Region1,128,255)
' 
' Display the albedo image
hal.dev_display(Albedo)
hal.赋值(Message,"These defects are difficult to detect in the albedo image.")
hal.赋值元组元素(Message,1,"Therefore, we use the gradient information to detect them.")
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(5)
' 
' Detect texture defects using gradient information.
' We are looking for areas with little surface changes.
hal.derivate_vector_field(Gradient,Curl,1,"curl")
hal.derivate_gauss(Curl,CurlGradient,1,"gradient")
' 
' Detect texture defects
hal.threshold(CurlGradient,Region,0,0.01)
hal.rank_region(Region,RegionCount,10,10,30)
hal.connection(RegionCount,ConnectedRegions)
hal.select_shape(ConnectedRegions,SelectedRegions,"area","and",2000,99999)
hal.union1(SelectedRegions,RegionUnion)
hal.rank_region(RegionUnion,RegionCount1,25,25,170)
hal.connection(RegionCount1,NoTextured)
' 
' Display texture defects
hal.dev_display(Albedo)
hal.dev_set_draw("margin")
hal.dev_set_color("red")
hal.dev_set_line_width(3)
hal.dev_display(NoTextured)
hal.disp_message(WindowHandle,"Non-textured areas on leather","window",12,12,"black","true")
hal.wait_seconds(5)
' 
' Detect scratches using curvature information.
' We are looking for areas with high curvature
hal.derivate_vector_field(Gradient,MeanCurvature,1,"mean_curvature")
' 
' Display the mean curvature of the surface
hal.dev_display(MeanCurvature)
hal.赋值(Message,"Mean curvature of the surface")
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
' 
' Detect scratches
hal.abs_image(MeanCurvature,ImageAbs)
hal.threshold(ImageAbs,Region2,0.15,255)
hal.connection(Region2,ConnectedRegions1)
hal.select_shape(ConnectedRegions1,SelectedRegions1,"area","and",10,99999)
hal.union1(SelectedRegions1,RegionUnion1)
hal.closing_circle(RegionUnion1,RegionClosing,1.5)
hal.connection(RegionClosing,ConnectedRegions2)
hal.select_shape(ConnectedRegions2,SelectedRegions2,"max_diameter","and",50,99999)
hal.select_gray(SelectedRegions2,MeanCurvature,SelectedRegions3,"deviation","and",0.2,255)
' 
' Display scratches
hal.dev_display(Albedo)
hal.dev_set_draw("margin")
hal.dev_set_color("red")
hal.dev_set_line_width(3)
hal.dev_display(SelectedRegions3)
hal.disp_message(WindowHandle,"Deep scratch","window",12,12,"black","true")
hal.wait_seconds(5)
return()

.子程序 p_do_compare_surface_sheet_of_light
.局部变量 Clip, 视觉元组
.局部变量 ClipRegion, 视觉元组
.局部变量 Diameter, 视觉元组
.局部变量 DisparityRange, 视觉元组
.局部变量 Grayval, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageModel, 视觉对象
.局部变量 ImageSearch, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 Information, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 Model3D, 视觉元组
.局部变量 Model3DAll, 视觉元组
.局部变量 Model3DSampled, 视觉元组
.局部变量 NotUsed, 视觉元组
.局部变量 NumErrors, 视觉元组
.局部变量 NumProfiles, 视觉元组
.局部变量 NumScenes, 视觉元组
.局部变量 ObjectModel3DConnected, 视觉元组
.局部变量 ObjectModel3DNormals, 视觉元组
.局部变量 ObjectModel3DRigidTrans, 视觉元组
.局部变量 ObjectModel3DSelected, 视觉元组
.局部变量 ObjectModel3DThresholded, 视觉元组
.局部变量 Pose, 视觉元组
.局部变量 PoseDisplay, 视觉元组
.局部变量 PosesInvert, 视觉元组
.局部变量 ProfileWidth, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 ScaleX, 视觉元组
.局部变量 ScaleY, 视觉元组
.局部变量 ScaleZ, 视觉元组
.局部变量 Scene3D, 视觉元组
.局部变量 Scene3DAll, 视觉元组
.局部变量 SceneIndex, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 SheetOfLightModelID, 视觉元组
.局部变量 Status, 视觉元组
.局部变量 SurfaceModelID, 视觉元组
.局部变量 Title, 视觉元组
.局部变量 TriangulatedObjectModel3D, 视觉元组
.局部变量 VisParamNames, 视觉元组
.局部变量 VisParamValues, 视觉元组
.局部变量 WindowHandle, 视觉元组

' This procedure shows the usage of an uncalibrated sheet of
' light setup for surface comparison.
' 
' The inspected metal parts were scanned with an uncalibrated
' setup that returns disparities for each scan line.
' 
' The disparity profiles are added to a sheet_of_light_model
' with the operator set_profile_sheet_of_light.
' Using simple scalings (defined at the start of the program)
' the measurements are transformed into a 3D object model.
' 
' 
' Part 1
' 
' Create a sheet-of-light model to collect the profiles
' and set the scaling factors for the reconstruction.
' Note, that through the scalings, only approximate
' 3d coordinates are obtained (scaling does not
' replace calibration).
' Fortunately, in this case, this is completely sufficient
' for the task, as we only want to compare the parts
' qualitatively.
' 
' Create sheet-of-light model with following parameters
hal.赋值(NumProfiles,441)
hal.赋值(DisparityRange,512)
hal.赋值(ProfileWidth,626)
' In this example, the profiles are not measured by HALCON.
' Instead, they are obtained directly from the sheet-of-light
' sensor. Nevertheless the profile width is defined
' within create_sheet_of_light_model by the width of a rectangle.
hal.get_system("clip_region",ClipRegion)
hal.set_system("clip_region","false")
hal.gen_rectangle1(Rectangle,0,0,hal.减(DisparityRange,1),hal.减(ProfileWidth,1))
hal.set_system("clip_region",ClipRegion)
hal.create_sheet_of_light_model(Rectangle,"calibration","offset_scale",SheetOfLightModelID)
' Set the scaling factors such that the distance
' of neighboring 3D points is approximately the same
' as in the real object.
hal.赋值(ScaleX,2)
hal.赋值(ScaleY,8)
hal.赋值(ScaleZ,1)
hal.赋值(Clip,435)
hal.set_sheet_of_light_param(SheetOfLightModelID,"scale_x",ScaleX)
hal.set_sheet_of_light_param(SheetOfLightModelID,"scale_y",ScaleY)
hal.set_sheet_of_light_param(SheetOfLightModelID,"scale_z",ScaleZ)
' 
' Init display
hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,ProfileWidth,NumProfiles,"black",WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
' 
' Create an image to display the disparities
hal.gen_image_const(Image,"uint2",ProfileWidth,NumProfiles)
' 
' Create the reference object by collecting
' the measured profiles in a sheet-of-light model
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(NumProfiles,1)))
'     Add the next profile to the sheet of light model
hal.read_image(ImageModel,hal.加("sheet_of_light/metal_part_1_disparity_line_",hal.文本格式化(Index,"03d")))
hal.set_profile_sheet_of_light(ImageModel,SheetOfLightModelID,hal.创建元组())
'     Visualize accumulated profiles
hal.get_grayval(ImageModel,hal.gen_tuple_const(ProfileWidth,0),hal.创建序列(0,hal.减(ProfileWidth,1), 1),Grayval)
hal.set_grayval(Image,hal.gen_tuple_const(ProfileWidth,Index),hal.创建序列(0,hal.减(ProfileWidth,1), 1),Grayval)
.判断开始 (hal.等于(hal.求模(Index,10),0))
hal.dev_display(Image)
.判断结束

hal.赋值(Message,"Measure reference object")
hal.赋值元组元素(Message,1,hal.加("Profile #",hal.加(Index,1)))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
hal.赋值(Message,"Prepare the model for distance measurement ...")
hal.disp_message(WindowHandle,Message,"window",60,12,"black","true")
hal.赋值(Status," ... triangulate object ...")
hal.赋值元组元素(Status,1," ... subsample object ...")
hal.赋值元组元素(Status,2," ... create surface model for alignment ...")
' Select the relevant part from the scene
hal.get_sheet_of_light_result_object_model_3d(SheetOfLightModelID,Model3DAll)
hal.select_points_object_model_3d(Model3DAll,"point_coord_z",Clip,800,Model3D)
' Clean up memory
hal.clear_object_model_3d(Model3DAll)
' 
' Prepare reference object for a more robust
' surface comparison.
' 
' To get a more robust result, the reference object is
' subsampled to achieve a better resolution for the
' measurement. The subsampling needs a triangulation
' as a preprocessing step.
' 
' Triangulate the model in a simple way
hal.disp_message(WindowHandle,hal.取元素(Status,0),"window",100,12,"white","false")
hal.surface_normals_object_model_3d(Model3D,"mls","mls_force_inwards","true",ObjectModel3DNormals)
hal.triangulate_object_model_3d(ObjectModel3DNormals,"greedy","greedy_remove_small_surfaces",200,TriangulatedObjectModel3D,Information)
' Clean up memory
hal.clear_object_model_3d(ObjectModel3DNormals)
' Sample the object for distance measurements
hal.disp_message(WindowHandle,hal.创建元组(hal.加(hal.取元素(Status,0)," ready."),hal.取元素(Status,1)),"window",100,12,"white","false")
hal.max_diameter_object_model_3d(TriangulatedObjectModel3D,Diameter)
hal.sample_object_model_3d(TriangulatedObjectModel3D,"fast",hal.乘(Diameter,0.002),hal.创建元组(),hal.创建元组(),Model3DSampled)
hal.disp_message(WindowHandle,hal.创建元组(hal.加(hal.取元素范围(Status,0,1)," ready."),hal.取元素(Status,2)),"window",100,12,"white","false")
' Clean up memory
hal.clear_object_model_3d(Model3D)
' 
' Create a surface model for alignment
hal.create_surface_model(TriangulatedObjectModel3D,0.01,"model_invert_normals","true",SurfaceModelID)
' Display status
hal.赋值(Message,hal.加(Message," ready."))
hal.disp_message(WindowHandle,hal.加(Status," ready."),"window",100,12,"white","false")
' Display reference model
hal.dev_clear_window()
hal.create_pose(1100,1300,35000,140,350,55,"Rp+T","gba","point",PoseDisplay)
hal.赋值(Title,"Reference object (uncalibrated measurement)")
'* Pose := [1467.9,1330.73,33172.7,135.506,309.108,42.7514,0]
hal.disp_object_model_3d_safe(WindowHandle,TriangulatedObjectModel3D,hal.创建元组(),PoseDisplay,hal.创建元组(),hal.创建元组())
hal.disp_message(WindowHandle,Title,"window",12,12,"black","true")
hal.wait_seconds(3)
' 
' Main loop:
' Perform a surface comparison on a number of objects
hal.赋值(NumScenes,1)
hal.赋值 (SceneIndex, 1)
.判断循环首 (hal.小于等于 (SceneIndex, NumScenes))
'     Reset the dispartities in the sheet of light model. All other settings can be reused
hal.reset_sheet_of_light_model(SheetOfLightModelID)
'     Collect and display the disparities from the sensor
hal.gen_image_const(Image,"uint2",ProfileWidth,NumProfiles)
hal.赋值 (Index, 0)
.判断循环首 (hal.小于等于 (Index, hal.减(NumProfiles,1)))
hal.read_image(ImageSearch,hal.加(hal.加(hal.加("sheet_of_light/metal_part_",hal.加(SceneIndex,1)),"_disparity_line_"),hal.文本格式化(Index,"03d")))
hal.get_grayval(ImageSearch,hal.gen_tuple_const(ProfileWidth,0),hal.创建序列(0,hal.减(ProfileWidth,1), 1),Grayval)
hal.set_grayval(Image,hal.gen_tuple_const(ProfileWidth,Index),hal.创建序列(0,hal.减(ProfileWidth,1), 1),Grayval)
.判断开始 (hal.等于(hal.求模(Index,10),0))
hal.dev_display(Image)
.判断结束

hal.赋值(Message,hal.加("Measure sample #",SceneIndex))
hal.赋值元组元素(Message,1,hal.加("Profile #",hal.加(Index,1)))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
'         Add the next profile to the sheet-of-light model
'         The offset is considered constant (= ScaleY)
hal.set_profile_sheet_of_light(ImageSearch,SheetOfLightModelID,hal.创建元组())
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
'     Select the relevant part from the scene
hal.get_sheet_of_light_result_object_model_3d(SheetOfLightModelID,Scene3DAll)
hal.select_points_object_model_3d(Scene3DAll,"point_coord_z",Clip,800,Scene3D)
'     Clean up memory
hal.clear_object_model_3d(Scene3DAll)
'     Match the two objects
hal.disp_message(WindowHandle,"Match model and scene ...","window",60,12,"black","true")
hal.find_surface_model(SurfaceModelID,Scene3D,0.02,0.2,0,"false",hal.创建元组(),hal.创建元组(),Pose,Score,NotUsed)
hal.pose_invert(Pose,PosesInvert)
'     Transform the scene to match the reference object
hal.rigid_trans_object_model_3d(Scene3D,PosesInvert,ObjectModel3DRigidTrans)
'     Measure the distances between the scene and the model
hal.distance_object_model_3d(ObjectModel3DRigidTrans,Model3DSampled,hal.创建元组(),到小数(0.0),hal.创建元组(),hal.创建元组())
'     Select points with a high distance
hal.select_points_object_model_3d(ObjectModel3DRigidTrans,"&amp;distance",hal.乘(ScaleY,1.5),1000,ObjectModel3DThresholded)
'     Calculate connected components, the distance threshold should
'     be greater than the distance between two scan lines (> ScaleY)
hal.connection_object_model_3d(ObjectModel3DThresholded,"distance_3d",hal.加(ScaleY,5),ObjectModel3DConnected)
'     Keep the large components, discard small ones as noise
hal.select_object_model_3d(ObjectModel3DConnected,"num_points","and",200,1000000,ObjectModel3DSelected)
'     Show the errorneous regions
hal.赋值(NumErrors,hal.取元素总数(ObjectModel3DSelected))
hal.赋值(VisParamNames,hal.创建元组("point_size",hal.加("point_size_",hal.加(NumErrors,1)),"color",hal.加("color_",NumErrors),hal.加("color_",hal.加(NumErrors,1)),hal.加("alpha_",NumErrors)))
hal.赋值(VisParamValues,hal.创建元组(到小数(5.0),到小数(2.0),"red","white","green",0.8))
hal.赋值元组元素(Title,0,hal.加("Sample #",SceneIndex))
hal.赋值元组元素(Title,1,hal.加(hal.加("Found ",NumErrors)," error(s)"))
hal.disp_object_model_3d_safe(WindowHandle,hal.创建元组(ObjectModel3DSelected,TriangulatedObjectModel3D,ObjectModel3DRigidTrans),hal.创建元组(),PoseDisplay,VisParamNames,VisParamValues)
hal.disp_message(WindowHandle,Title,"window",12,12,"black","true")
hal.wait_seconds(3)
'     Clean up memory
hal.clear_object_model_3d(hal.创建元组(Scene3D,ObjectModel3DConnected,ObjectModel3DSelected,ObjectModel3DRigidTrans))
SceneIndex ＝ hal.加 (SceneIndex, 1)
.判断循环尾 ()
' Clean up memory
hal.clear_object_model_3d(hal.创建元组(Model3DSampled,TriangulatedObjectModel3D))
hal.clear_sheet_of_light_model(SheetOfLightModelID)
hal.clear_surface_model(SurfaceModelID)
return()

.子程序 p_do_aztec
.局部变量 Ascent, 视觉元组
.局部变量 CandNum, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Contrast, 视觉元组
.局部变量 Cross, 视觉对象
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 DecodingError, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 GenParamNames, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageFiles, 视觉元组
.局部变量 ImageIndex, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 MessageHeight, 视觉元组
.局部变量 MessageWidth, 视觉元组
.局部变量 Mirrored, 视觉元组
.局部变量 ModuleHeight, 视觉元组
.局部变量 ModuleWidth, 视觉元组
.局部变量 Passes, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 ResultNum, 视觉元组
.局部变量 ResultObjectNames, 视觉元组
.局部变量 ResultParamNames, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SL, 视觉元组
.局部变量 SelectedImageFiles, 视觉元组
.局部变量 SymbolCols, 视觉元组
.局部变量 SymbolRows, 视觉元组
.局部变量 SymbolXLD, 视觉对象
.局部变量 SymbolXLDs, 视觉对象
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 TColumn, 视觉元组
.局部变量 TRow, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 UndecNum, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' *****************************************************************************
' Example program for demonstrating the 2d data code operators
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (Aztec code).
' The model is adapted according to the searched symbols.
' The symbol size, the module size and an estimation concerning the gap between
' two modules are set.
' For normal dark-on-light symbols the improvement of the run time,
' that can be achieved by adapting the model is not very high -
' if the symbol is found, however, at big images,
' or if the symbol is not readable, the time saving may be significant.
' Furthermore, for some symbols it may be necessary to set some
' model parameters to be able to read the symbols at all.
' 
hal.dev_update_off()
hal.list_image_files("datacode/aztec","default",hal.创建元组(),ImageFiles)
hal.赋值(SelectedImageFiles,hal.regexp_select(ImageFiles,"(smartphone)|(ticket)|(ticket_machine)"))
hal.read_image(Image,hal.取元素(SelectedImageFiles,0))
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,640,512,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' 
hal.create_data_code_2d_model("Aztec Code",hal.创建元组(),hal.创建元组(),DataCodeHandle)
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("module_size_min","module_size_max"),hal.创建元组(3,11))
hal.set_data_code_2d_param(DataCodeHandle,"module_gap","no")
hal.set_data_code_2d_param(DataCodeHandle,"polarity","any")
hal.set_data_code_2d_param(DataCodeHandle,"mirrored","no")
hal.set_data_code_2d_param(DataCodeHandle,"contrast_min",20)
hal.set_data_code_2d_param(DataCodeHandle,"symbol_size_min",19)
hal.set_data_code_2d_param(DataCodeHandle,"symbol_size_max",143)
hal.set_data_code_2d_param(DataCodeHandle,"small_modules_robustness","high")
hal.set_data_code_2d_param(DataCodeHandle,"finder_pattern_tolerance","high")
' 
' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.
' 
hal.query_data_code_2d_params(DataCodeHandle,"get_model_params",GenParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_params",ResultParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_objects",ResultObjectNames)
' 
' Within a loop:
' + read the next image
' + try to recognize the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process
' 
hal.赋值 (ImageIndex, 0)
.判断循环首 (hal.小于等于 (ImageIndex, hal.减(hal.取元素总数(SelectedImageFiles),1)))
'     
'     Read the next image
'     
hal.read_image(Image,hal.取元素(SelectedImageFiles,ImageIndex))
'     
'     Look for the 2d data code symbols and measure the run time
'     of find_data_code_2d
'     
hal.count_seconds(T1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(T2)
hal.赋值(Time,hal.乘(1000,hal.减(T2,T1)))
'     
'     Get some interesting information about the search in general
'     
hal.get_data_code_2d_results(DataCodeHandle,"general","result_num",ResultNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","candidate_num",CandNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","pass_num",Passes)
hal.get_data_code_2d_results(DataCodeHandle,"general","undecoded_num",UndecNum)
hal.get_data_code_2d_results(DataCodeHandle,"general",hal.创建元组("search_level","min_search_level","max_search_level"),SL)
hal.赋值(Message,hal.加(hal.加("Aztec code found and decoded in ",hal.文本格式化(Time,".1f")),"ms"))
'     
'     Get some interesting information about all successfully detected symbols
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_rows",SymbolRows)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_cols",SymbolCols)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_height",ModuleHeight)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_width",ModuleWidth)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mirrored",Mirrored)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","contrast",Contrast)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","decoding_error",DecodingError)
'     
'     Display some of the general information (runtime, number of found symbols and passes).
'     
hal.dev_display(Image)
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.dev_set_color("green")
hal.dev_set_line_width(4)
hal.dev_display(SymbolXLDs)
'     
'     For all symbols display the encoded data string and some
'     info about the symbol and the reading process
'     
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(ResultHandles),1)))
hal.select_obj(SymbolXLDs,SymbolXLD,hal.加(I,1))
hal.get_contour_xld(SymbolXLD,Row,Column)
hal.赋值(Message,hal.取元素(DecodedDataStrings,I))
hal.get_string_extents(WindowHandle,hal.加(Message," "),Ascent,Descent,MessageWidth,MessageHeight)
hal.gen_cross_contour_xld(Cross,Row,Column,6,0.785398)
hal.赋值(TRow,hal.求最大值(Row))
hal.赋值(TColumn,hal.求最大值(hal.创建元组(0,hal.减(hal.mean(Column),hal.除(MessageWidth,2)))))
.判断开始 (hal.等于(TColumn,0))
hal.赋值元组元素(Message,1,"...")
.判断结束

hal.disp_message(WindowHandle,Message,"image",hal.减(TRow,1),hal.减(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.减(TRow,1),hal.加(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.加(TRow,1),hal.减(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.加(TRow,1),hal.加(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",TRow,TColumn,"green","false")
hal.赋值(Message,"Decoding info:")
hal.赋值元组元素(Message,1,hal.加(hal.加(hal.加("Symbols:     ",hal.取元素(SymbolRows,I))," x "),hal.取元素(SymbolCols,I)))
hal.赋值元组元素(Message,2,hal.加(hal.加(hal.加("Module size: ",hal.文本格式化(hal.取元素(ModuleHeight,I),".1f"))," x "),hal.文本格式化(hal.取元素(ModuleWidth,I),".1f")))
hal.赋值元组元素(Message,3,hal.加("Mirrored:    ",hal.取元素(Mirrored,I)))
hal.赋值元组元素(Message,4,hal.加("Contrast:    ",hal.文本格式化(hal.取元素(Contrast,I),".1f")))
hal.赋值元组元素(Message,5,hal.加("Decode-err:  ",hal.取元素(DecodingError,I)))
hal.disp_message(WindowHandle,Message,"window",41,13,"black","false")
hal.disp_message(WindowHandle,Message,"window",39,11,"black","false")
hal.disp_message(WindowHandle,Message,"window",41,11,"black","false")
hal.disp_message(WindowHandle,Message,"window",39,13,"black","false")
hal.disp_message(WindowHandle,Message,"window",40,12,"orange","false")
I ＝ hal.加 (I, 1)
.判断循环尾 ()
.判断开始 (hal.小于(ImageIndex,2))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

ImageIndex ＝ hal.加 (ImageIndex, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
' Cleanup: close the 2d data code model
' 
hal.clear_data_code_2d_model(DataCodeHandle)
return()

.子程序 p_do_microqr
.局部变量 Ascent, 视觉元组
.局部变量 CandNum, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Contrast, 视觉元组
.局部变量 Cross, 视觉对象
.局部变量 DataCodeHandle, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 DecodingError, 视觉元组
.局部变量 Descent, 视觉元组
.局部变量 GenParamNames, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageFiles, 视觉元组
.局部变量 ImageIndex, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 MessageHeight, 视觉元组
.局部变量 MessageWidth, 视觉元组
.局部变量 Mirrored, 视觉元组
.局部变量 ModuleHeight, 视觉元组
.局部变量 ModuleWidth, 视觉元组
.局部变量 Passes, 视觉元组
.局部变量 ResultHandles, 视觉元组
.局部变量 ResultNum, 视觉元组
.局部变量 ResultObjectNames, 视觉元组
.局部变量 ResultParamNames, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 SL, 视觉元组
.局部变量 SelectedImageFiles, 视觉元组
.局部变量 SymbolCols, 视觉元组
.局部变量 SymbolRows, 视觉元组
.局部变量 SymbolXLD, 视觉对象
.局部变量 SymbolXLDs, 视觉对象
.局部变量 T1, 视觉元组
.局部变量 T2, 视觉元组
.局部变量 TColumn, 视觉元组
.局部变量 TRow, 视觉元组
.局部变量 Time, 视觉元组
.局部变量 UndecNum, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

' 
' *****************************************************************************
' Example program for demonstrating the 2d data code operators
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (Micro QR code).
' The model is adapted according to the searched symbols.
' The symbol size, the module size and an estimation concerning the gap between
' two modules are set.
' For normal dark-on-light symbols the improvement of the run time,
' that can be achieved by adapting the model is not very high -
' if the symbol is found, however, at big images,
' or if the symbol is not readable, the time saving may be significant.
' Furthermore, for some symbols it may be necessary to set some
' model parameters to be able to read the symbols at all.
' 
hal.dev_update_off()
hal.list_image_files("datacode/micro_qr","default",hal.创建元组(),ImageFiles)
hal.赋值(SelectedImageFiles,hal.regexp_select(ImageFiles,"(cell_phone)|(board)"))
hal.read_image(Image,hal.取元素(SelectedImageFiles,0))
hal.get_image_size(Image,Width,Height)
hal.dev_close_window()
hal.dev_open_window(0,0,Width,Height,"black",WindowHandle)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
p_set_font(hal.克隆元组(WindowHandle))
' 
' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' 
hal.create_data_code_2d_model("Micro QR Code",hal.创建元组(),hal.创建元组(),DataCodeHandle)
hal.set_data_code_2d_param(DataCodeHandle,hal.创建元组("module_size_min","module_size_max"),hal.创建元组(3,8))
hal.set_data_code_2d_param(DataCodeHandle,"module_gap","no")
hal.set_data_code_2d_param(DataCodeHandle,"polarity","any")
hal.set_data_code_2d_param(DataCodeHandle,"mirrored","no")
hal.set_data_code_2d_param(DataCodeHandle,"contrast_min",20)
hal.set_data_code_2d_param(DataCodeHandle,"symbol_size_min",13)
hal.set_data_code_2d_param(DataCodeHandle,"symbol_size_max",15)
' 
' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.
' 
hal.query_data_code_2d_params(DataCodeHandle,"get_model_params",GenParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_params",ResultParamNames)
hal.query_data_code_2d_params(DataCodeHandle,"get_result_objects",ResultObjectNames)
' 
' Within a loop:
' + read the next image
' + try to recognize the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process
' 
hal.赋值 (ImageIndex, 0)
.判断循环首 (hal.小于等于 (ImageIndex, hal.减(hal.取元素总数(SelectedImageFiles),2)))
'     
'     Read the next image
'     
hal.read_image(Image,hal.取元素(SelectedImageFiles,ImageIndex))
'     
'     Look for the 2d data code symbols and measure the run time
'     of find_data_code_2d
'     
hal.count_seconds(T1)
hal.find_data_code_2d(Image,SymbolXLDs,DataCodeHandle,hal.创建元组(),hal.创建元组(),ResultHandles,DecodedDataStrings)
hal.count_seconds(T2)
hal.赋值(Time,hal.乘(1000,hal.减(T2,T1)))
'     
'     Get some interesting information about the search in general
'     
hal.get_data_code_2d_results(DataCodeHandle,"general","result_num",ResultNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","candidate_num",CandNum)
hal.get_data_code_2d_results(DataCodeHandle,"general","pass_num",Passes)
hal.get_data_code_2d_results(DataCodeHandle,"general","undecoded_num",UndecNum)
hal.get_data_code_2d_results(DataCodeHandle,"general",hal.创建元组("search_level","min_search_level","max_search_level"),SL)
hal.赋值(Message,hal.加(hal.加("Micro QR code found"+#换行符+"and decoded in ",hal.文本格式化(Time,".1f")),"ms"))
'     
'     Get some interesting information about all successfully detected symbols
'     
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_rows",SymbolRows)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","symbol_cols",SymbolCols)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_height",ModuleHeight)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","module_width",ModuleWidth)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","mirrored",Mirrored)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","contrast",Contrast)
hal.get_data_code_2d_results(DataCodeHandle,"all_results","decoding_error",DecodingError)
'     
'     Display some of the general information (runtime, number of found symbols and passes).
'     
hal.dev_display(Image)
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.dev_set_color("green")
hal.dev_set_line_width(4)
hal.dev_display(SymbolXLDs)
'     
'     For all symbols display the encoded data string and some
'     info about the symbol and the reading process
'     
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(ResultHandles),1)))
hal.select_obj(SymbolXLDs,SymbolXLD,hal.加(I,1))
hal.get_contour_xld(SymbolXLD,Row,Column)
hal.赋值(Message,hal.取元素(DecodedDataStrings,I))
hal.get_string_extents(WindowHandle,hal.加(Message," "),Ascent,Descent,MessageWidth,MessageHeight)
hal.gen_cross_contour_xld(Cross,Row,Column,6,0.785398)
hal.赋值(TRow,hal.求最大值(Row))
hal.赋值(TColumn,hal.求最大值(hal.创建元组(0,hal.减(hal.mean(Column),hal.除(MessageWidth,2)))))
.判断开始 (hal.等于(TColumn,0))
hal.赋值元组元素(Message,1,"...")
.判断结束

hal.disp_message(WindowHandle,Message,"image",hal.减(TRow,1),hal.减(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.减(TRow,1),hal.加(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.加(TRow,1),hal.减(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",hal.加(TRow,1),hal.加(TColumn,1),"black","false")
hal.disp_message(WindowHandle,Message,"image",TRow,TColumn,"green","false")
hal.赋值(Message,"Decoding info:")
hal.赋值元组元素(Message,1,hal.加(hal.加(hal.加("Symbols:     ",hal.取元素(SymbolRows,I))," x "),hal.取元素(SymbolCols,I)))
hal.赋值元组元素(Message,2,hal.加(hal.加(hal.加("Module size: ",hal.文本格式化(hal.取元素(ModuleHeight,I),".1f"))," x "),hal.文本格式化(hal.取元素(ModuleWidth,I),".1f")))
hal.赋值元组元素(Message,3,hal.加("Mirrored:    ",hal.取元素(Mirrored,I)))
hal.赋值元组元素(Message,4,hal.加("Contrast:    ",hal.文本格式化(hal.取元素(Contrast,I),".1f")))
hal.赋值元组元素(Message,5,hal.加("Decode-err:  ",hal.取元素(DecodingError,I)))
hal.disp_message(WindowHandle,Message,"window",61,13,"black","false")
hal.disp_message(WindowHandle,Message,"window",59,11,"black","false")
hal.disp_message(WindowHandle,Message,"window",61,11,"black","false")
hal.disp_message(WindowHandle,Message,"window",59,13,"black","false")
hal.disp_message(WindowHandle,Message,"window",60,12,"orange","false")
I ＝ hal.加 (I, 1)
.判断循环尾 ()
.判断开始 (hal.小于(ImageIndex,2))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(3)
.判断结束

ImageIndex ＝ hal.加 (ImageIndex, 1)
.判断循环尾 ()
hal.wait_seconds(2)
' 
' Cleanup: close the 2d data code model
' 
hal.clear_data_code_2d_model(DataCodeHandle)
return()

.子程序 close_parallels
.参数 ParallelContours1, obj
.参数 ParallelContours2, obj
.参数 Contour, obj, 参考
.局部变量 ClosedContour, 视觉对象
.局部变量 Col1, 视觉元组
.局部变量 Col2, 视觉元组
.局部变量 Index, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 Parallel1, 视觉对象
.局部变量 Parallel2, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组

hal.count_obj(ParallelContours1,Number)
hal.gen_empty_obj(Contour)
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, Number))
hal.select_obj(ParallelContours1,Parallel1,Index)
hal.select_obj(ParallelContours2,Parallel2,Index)
hal.get_contour_xld(Parallel1,Row1,Col1)
hal.get_contour_xld(Parallel2,Row2,Col2)
hal.gen_contour_polygon_xld(ClosedContour,hal.创建元组(Row1,hal.inverse(Row2),hal.取元素(Row1,0)),hal.创建元组(Col1,hal.inverse(Col2),hal.取元素(Col1,0)))
hal.concat_obj(Contour,ClosedContour,Contour)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
return()

.子程序 align_bead
.参数 Image, obj
.参数 ImageAligned, obj, 参考
.参数 ModelID, tuple
.参数 RowT, tuple
.参数 ColumnT, tuple
.局部变量 HomMat2D1, 视觉元组
.局部变量 HomMat2DInvert, 视觉元组
.局部变量 HomMat2DTranslate, 视觉元组
.局部变量 Score, 视觉元组

' Align the test image with the reference image using
' planar deformable matching
hal.find_planar_uncalib_deformable_model(Image,ModelID,-0.39,0.78,1,1,1,1,0.5,1,1,0,0.9,hal.创建元组(),hal.创建元组(),HomMat2D1,Score)
hal.hom_mat2d_invert(HomMat2D1,HomMat2DInvert)
hal.hom_mat2d_translate(HomMat2DInvert,RowT,ColumnT,HomMat2DTranslate)
hal.projective_trans_image(Image,ImageAligned,HomMat2DTranslate,"bilinear","false","false")
return()

.子程序 gen_display_segments
.参数 TooThinSegments, obj
.参数 LeftContour, obj
.参数 RightContour, obj
.参数 ContoursIntersection, obj, 参考
.局部变量 Contour, 视觉对象
.局部变量 Contour1, 视觉对象
.局部变量 ParallelContours1, 视觉对象
.局部变量 ParallelContours2, 视觉对象

' Construct contours used to visualize the error segments
' returned by the bead inspection
hal.gen_parallel_contour_xld(TooThinSegments,ParallelContours1,"regression_normal",50)
hal.gen_parallel_contour_xld(TooThinSegments,ParallelContours2,"regression_normal",-50)
close_parallels(hal.克隆对象(ParallelContours1),hal.克隆对象(ParallelContours2),Contour)
close_parallels(hal.克隆对象(LeftContour),hal.克隆对象(RightContour),Contour1)
hal.intersection_closed_contours_xld(Contour,Contour1,ContoursIntersection)
return()

.子程序 prepare_alignment
.参数 RegionPart, obj, 参考
.参数 RowT, tuple, 参考
.参数 ColumnT, tuple, 参考
.参数 ModelID, tuple, 参考
.局部变量 AreaCR, 视觉元组
.局部变量 AreaT, 视觉元组
.局部变量 Col, 视觉元组
.局部变量 Col1, 视觉元组
.局部变量 ColumnCR, 视觉元组
.局部变量 ConnectedRegions, 视觉对象
.局部变量 Covariance, 视觉元组
.局部变量 H, 视觉元组
.局部变量 HomMat2D, 视觉元组
.局部变量 ImageReduced, 视觉对象
.局部变量 ImageRef, 视觉对象
.局部变量 ImageRefTrans, 视觉对象
.局部变量 ObjectSelected, 视觉对象
.局部变量 Region, 视觉对象
.局部变量 RegionFillUp, 视觉对象
.局部变量 RegionOpening, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 RowCR, 视觉元组
.局部变量 UsedThreshold, 视觉元组
.局部变量 W, 视觉元组

' Set image coordinates of four points used to determine
' a projective transformation to rectify the reference
' image
hal.赋值(Row,hal.创建元组(658.232,291.923,314.817,691.533))
hal.赋值(Col,hal.创建元组(330.071,316.617,971.032,947.008))
' Set respective point coordinates to which the above
' defined points will be rectified
hal.赋值(W,5.4)
hal.赋值(H,3.4)
hal.赋值(Row1,hal.加(300,hal.乘(hal.创建元组(H,0,0,H),到小数(120.0))))
hal.赋值(Col1,hal.加(300,hal.乘(hal.创建元组(0,0,W,W),到小数(120.0))))
hal.vector_to_proj_hom_mat2d(Row,Col,Row1,Col1,"normalized_dlt",hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),HomMat2D,Covariance)
' 
' Read the reference image (image withou adhesive bead)
hal.read_image(ImageRef,"bead/adhesive_bead_ref")
' 
' Rectify the reference image
hal.projective_trans_image(ImageRef,ImageRefTrans,HomMat2D,"bilinear","false","false")
' 
' Determine a region that contains the planar
' part on which the adhesive bead will be applied.
' This planar part will also be used to align the
' test images with the reference image.
hal.binary_threshold(ImageRefTrans,Region,"smooth_histo","light",UsedThreshold)
hal.opening_circle(Region,RegionOpening,5.5)
hal.connection(RegionOpening,ConnectedRegions)
hal.area_center(ConnectedRegions,AreaCR,RowCR,ColumnCR)
hal.select_obj(ConnectedRegions,ObjectSelected,hal.加(hal.取元素(hal.sort_index(-hal.取元组小数(AreaCR,)),0),1))
hal.fill_up(ObjectSelected,RegionFillUp)
hal.dilation_circle(RegionFillUp,RegionPart,5.5)
hal.reduce_domain(ImageRefTrans,RegionPart,ImageReduced)
hal.area_center(RegionPart,AreaT,RowT,ColumnT)
hal.create_planar_uncalib_deformable_model(ImageReduced,"auto",-0.39,0.79,"auto",1,1,"auto",1,1,"auto","none","use_polarity","auto","auto",hal.创建元组(),hal.创建元组(),ModelID)
return()

.子程序 p_do_bead_inspection
.局部变量 Area, 视觉元组
.局部变量 BeadInspectionModel, 视觉元组
.局部变量 Class, 视觉元组
.局部变量 ClassIndex, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 ColumnT, 视觉元组
.局部变量 ContourRef, 视觉对象
.局部变量 E, 视觉元组
.局部变量 ErrorClasses, 视觉元组
.局部变量 ErrorIndices, 视觉元组
.局部变量 ErrorParts, 视觉对象
.局部变量 ErrorSegment, 视觉对象
.局部变量 ErrorType, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageAligned, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 J, 视觉元组
.局部变量 LeftContour, 视觉对象
.局部变量 Message, 视觉元组
.局部变量 ModelID, 视觉元组
.局部变量 ModelSide1, 视觉对象
.局部变量 ModelSide2, 视觉对象
.局部变量 ModelSides, 视觉对象
.局部变量 NumImages, 视觉元组
.局部变量 PartColumn1, 视觉元组
.局部变量 PartColumn2, 视觉元组
.局部变量 PartRow1, 视觉元组
.局部变量 PartRow2, 视觉元组
.局部变量 Polarity, 视觉元组
.局部变量 PositionTolerance, 视觉元组
.局部变量 PositionToleranceSide1, 视觉对象
.局部变量 PositionToleranceSide2, 视觉对象
.局部变量 PositionToleranceSides, 视觉对象
.局部变量 RegionPart, 视觉对象
.局部变量 RightContour, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 RowT, 视觉元组
.局部变量 SelectedSegments, 视觉对象
.局部变量 TargetWidth, 视觉元组
.局部变量 TextOffset, 视觉元组
.局部变量 Threshold, 视觉元组
.局部变量 WidthTolerance, 视觉元组
.局部变量 WindowHandle, 视觉元组

' This example shows how to use bead inspection to verify
' adhesive beads. Bead inspection can be used to detect the
' following errors:
'  - segments where adhesive is missing
'  - segments with too much or too little adhesive
'  - segments where adhesive is too far from its destined
'    position
' 
' apply_bead_inspection_model requires that the images to inspect
' are already aligned with the reference contour. In this example,
' the alignment is based on planar deformable matching.
' 
hal.dev_update_off()
' 
' Create the planar deformable model to align images with the
' reference contour
prepare_alignment(RegionPart,RowT,ColumnT,ModelID)
hal.smallest_rectangle1(RegionPart,PartRow1,PartColumn1,PartRow2,PartColumn2)
' 
' Define the reference path of the adhesive beads. This path could
' also be generated by drawing it on a reference image with, e.g.,
' draw_nurbs.
hal.gen_contour_nurbs_xld(ContourRef,hal.创建元组(701.767,626.953,538.867,443.54,390.447,360.28,354.247,363.9,400.1,458.02,509.907,588.34,659.533,696.94),hal.创建元组(319.24,336.133,367.507,431.46,489.38,546.093,646.247,722.267,776.567,826.04,869.48,912.92,934.64,929.813),"auto",hal.创建元组(15,15,15,15,15,15,15,15,15,15,15,15,15,15),3,1,5)
' 
' Create a new bead inspection model with the following parameters
hal.赋值(TargetWidth,14)
hal.赋值(WidthTolerance,7)
hal.赋值(PositionTolerance,30)
hal.赋值(Polarity,"dark")
hal.赋值(Threshold,30)
hal.create_bead_inspection_model(ContourRef,TargetWidth,WidthTolerance,PositionTolerance,Polarity,"threshold",Threshold,BeadInspectionModel)
' 
' Show a correct adhesive bead together with the reference contour
hal.read_image(Image,"bead/adhesive_bead_01")
align_bead(hal.克隆对象(Image),ImageAligned,hal.克隆元组(ModelID),hal.克隆元组(RowT),hal.克隆元组(ColumnT))
' 
' Create two parallel contours to give an impression of how
' thick a correct adhesive bead should be
hal.gen_parallel_contour_xld(ContourRef,ModelSide1,"regression_normal",hal.乘(TargetWidth,0.5))
hal.gen_parallel_contour_xld(ContourRef,ModelSide2,"regression_normal",hal.乘(-hal.取元组小数(TargetWidth,),0.5))
hal.concat_obj(ModelSide1,ModelSide2,ModelSides)
' 
' Create two parallel contours to give an impression of where
' a correct adhesive bead should be located
hal.gen_parallel_contour_xld(ContourRef,PositionToleranceSide1,"regression_normal",PositionTolerance)
hal.gen_parallel_contour_xld(ContourRef,PositionToleranceSide2,"regression_normal",-hal.取元组小数(PositionTolerance,))
hal.concat_obj(PositionToleranceSide1,PositionToleranceSide2,PositionToleranceSides)
hal.dev_close_window()
hal.dev_open_window_fit_size(0,0,hal.加(hal.减(PartColumn2,PartColumn1),1),hal.加(hal.减(PartRow2,PartRow1),41),640,-1,WindowHandle)
p_set_font(hal.克隆元组(WindowHandle))
hal.dev_set_part(hal.减(PartRow1,20),PartColumn1,hal.加(PartRow2,20),PartColumn2)
hal.dev_display(ImageAligned)
hal.dev_set_line_width(2)
hal.dev_set_color("green")
hal.dev_display(ContourRef)
hal.dev_set_line_width(1)
hal.dev_display(ModelSides)
hal.dev_set_color("yellow")
hal.dev_display(PositionToleranceSides)
hal.赋值(Message,"Correct adhesive bead and the reference contour. The")
hal.赋值元组元素(Message,1,"yellow contours indicate the range of position tolerance.")
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.wait_seconds(3)
' 
' Now, perform the inspection task
hal.赋值(TextOffset,20)
hal.赋值(NumImages,7)
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 3))
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, NumImages))
hal.read_image(Image,hal.加("bead/adhesive_bead_",hal.文本格式化(Index,"02")))
'         
'         Align the input image with the reference image
align_bead(hal.克隆对象(Image),ImageAligned,hal.克隆元组(ModelID),hal.克隆元组(RowT),hal.克隆元组(ColumnT))
'         
'         Apply the bead inspection model to the aligned image
hal.apply_bead_inspection_model(ImageAligned,LeftContour,RightContour,ErrorSegment,BeadInspectionModel,ErrorType)
'         
'         Display the segmented adhesive bead with its error segments
hal.dev_display(ImageAligned)
hal.dev_set_line_width(1)
hal.dev_set_color("white")
hal.dev_display(ContourRef)
hal.dev_display(ModelSides)
hal.dev_display(PositionToleranceSides)
hal.dev_set_line_width(2)
hal.dev_set_color("green")
hal.dev_display(LeftContour)
hal.dev_display(RightContour)
hal.dev_set_color("red")
hal.dev_display(ErrorSegment)
.判断开始 (hal.等于(hal.取元素总数(ErrorType),0))
'             No errors detected
hal.赋值(Message,"Adhesive bead is OK")
hal.disp_message(WindowHandle,Message,"window",12,12,"white","forest green")
.默认
'             Display errors by error class
hal.赋值元组元素(Message,0,"Adhesive bead is not OK:")
'             
hal.赋值(ErrorClasses,hal.创建元组("no bead","too thin","too thick","incorrect position"))
hal.赋值 (ClassIndex, 0)
.判断循环首 (hal.小于等于 (ClassIndex, hal.减(hal.取元素总数(ErrorClasses),1)))
hal.赋值(Class,hal.取元素(ErrorClasses,ClassIndex))
hal.赋值(ErrorIndices,hal.查找元素(ErrorType,Class))
.判断开始 (hal.不等于(ErrorIndices,-1))
hal.select_obj(ErrorSegment,SelectedSegments,hal.加(ErrorIndices,1))
hal.dev_set_color("red")
hal.dev_set_line_width(3)
.判断开始 (hal.不等于(Class,"no bead"))
gen_display_segments(hal.克隆对象(SelectedSegments),hal.克隆对象(LeftContour),hal.克隆对象(RightContour),ErrorParts)
hal.dev_display(ErrorParts)
.默认
hal.dev_display(SelectedSegments)
.判断结束

hal.area_center_points_xld(SelectedSegments,Area,Row,Column)
hal.赋值 (E, 0)
.判断循环首 (hal.小于等于 (E, hal.减(hal.取元素总数(ErrorIndices),1)))
hal.disp_message(WindowHandle,hal.加(hal.取元素(ErrorIndices,E),1),"image",hal.取元素(Row,E),hal.减(hal.取元素(Column,E),TextOffset),"white","red")
hal.赋值(TextOffset,hal.减(20,TextOffset))
E ＝ hal.加 (E, 1)
.判断循环尾 ()
.判断结束

ClassIndex ＝ hal.加 (ClassIndex, 1)
.判断循环尾 ()
hal.disp_message(WindowHandle,Message,"window",12,12,"white","red")
hal.disp_message(WindowHandle,hal.加(hal.加(hal.创建序列(1,hal.取元素总数(ErrorType), 1),": "),ErrorType),"image",500,500,"red","false")
.判断结束

.判断开始 (hal.等于(J,1))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1.5)
.判断结束

Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
J ＝ hal.加 (J, 1)
.判断循环尾 ()
' 
' Release all allocated memory
hal.clear_bead_inspection_model(BeadInspectionModel)
hal.clear_deformable_model(ModelID)
return()

.子程序 show_setup
.参数 ImagePart, obj
.参数 WindowHandle, tuple
.参数 Tilt, tuple
.局部变量 CP, 视觉元组
.局部变量 Camera, 视觉对象
.局部变量 CameraTilt, 视觉对象
.局部变量 Column, 视觉元组
.局部变量 ColumnNew, 视觉元组
.局部变量 Covariance, 视觉元组
.局部变量 HomMat2D, 视觉元组
.局部变量 ImagePlane, 视觉对象
.局部变量 L, 视觉元组
.局部变量 LL, 视觉元组
.局部变量 LP, 视觉元组
.局部变量 Lens, 视觉对象
.局部变量 Lens1, 视觉对象
.局部变量 LensPlane, 视觉对象
.局部变量 OP, 视觉元组
.局部变量 ObjectPlane, 视觉对象
.局部变量 Obstacle, 视觉对象
.局部变量 OpticalAxis, 视觉对象
.局部变量 Phi1, 视觉元组
.局部变量 Phi2, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 RowNew, 视觉元组
.局部变量 S, 视觉元组
.局部变量 ScheimpflugAxis, 视觉对象
.局部变量 TransImage, 视觉对象
.局部变量 WindowHeight, 视觉元组
.局部变量 WindowWidth, 视觉元组

' 
' Generate image of the scene
hal.dev_set_window(WindowHandle)
hal.dev_clear_window()
'* get_window_extents (WindowHandle, WRow, WColumn, WindowWidth, WindowHeight)
hal.赋值(WindowWidth,500)
hal.赋值(WindowHeight,400)
hal.dev_set_part(0,0,399,499)
hal.赋值(S,hal.创建元组(340,10))
hal.赋值(LP,hal.创建元组(170,210))
hal.赋值(OP,hal.创建元组(hal.取元素(S,0),410))
hal.赋值(L,240)
hal.赋值(Phi1,hal.rad(135))
hal.赋值(Phi2,hal.rad(155))
hal.赋值(CP,hal.创建元组(hal.加(hal.取元素(S,0),hal.乘(L,hal.cos(Phi2))),hal.加(hal.取元素(S,1),hal.乘(L,hal.sin(Phi2)))))
hal.gen_rectangle1(Obstacle,0,258,173,hal.减(WindowWidth,1))
hal.gen_contour_polygon_xld(LensPlane,hal.创建元组(hal.取元素(S,0),hal.取元素(LP,0)),hal.创建元组(hal.取元素(S,1),hal.取元素(LP,1)))
hal.gen_contour_polygon_xld(ImagePlane,hal.创建元组(hal.取元素(S,0),hal.取元素(CP,0)),hal.创建元组(hal.取元素(S,1),hal.取元素(CP,1)))
hal.gen_contour_polygon_xld(ObjectPlane,hal.创建元组(hal.取元素(S,0),hal.取元素(S,0)),hal.创建元组(0,hal.减(WindowWidth,1)))
hal.gen_circle(ScheimpflugAxis,hal.取元素(S,0),hal.取元素(S,1),4.5)
hal.赋值(LL,30)
hal.gen_region_polygon_filled(Lens,hal.减(hal.创建元组(hal.取元素(LP,0),hal.加(hal.取元素(LP,0),LL),hal.取元素(LP,0),hal.取元素(LP,0)),7),hal.减(hal.创建元组(hal.取元素(LP,1),hal.取元素(LP,1),hal.加(hal.取元素(LP,1),LL),hal.取元素(LP,1)),7))
hal.gen_contour_polygon_xld(Lens1,hal.减(hal.创建元组(hal.取元素(LP,0),hal.加(hal.取元素(LP,0),LL),hal.取元素(LP,0),hal.取元素(LP,0)),7),hal.减(hal.创建元组(hal.取元素(LP,1),hal.取元素(LP,1),hal.加(hal.取元素(LP,1),LL),hal.取元素(LP,1)),7))
hal.gen_rectangle2(CameraTilt,hal.加(hal.取元素(CP,0),15),hal.加(hal.取元素(CP,1),45),Phi2,50,30)
hal.gen_rectangle2(Camera,hal.减(hal.取元素(LP,0),40),hal.减(hal.取元素(LP,1),40),Phi1,45,30)
hal.gen_contour_polygon_xld(OpticalAxis,hal.创建元组(hal.取元素(LP,0),hal.加(hal.取元素(LP,0),hal.乘(L,hal.cos(hal.减(Phi1,hal.rad(90)))))),hal.创建元组(hal.取元素(LP,1),hal.加(hal.取元素(LP,1),hal.乘(L,hal.sin(hal.减(Phi1,hal.rad(90)))))))
' 
hal.赋值(Row,hal.减(hal.创建元组(134,134,1000,1000),134))
hal.赋值(Column,hal.减(hal.创建元组(6,1280,6,1280),6))
hal.赋值(RowNew,hal.创建元组(hal.减(hal.取元素(OP,0),20),hal.减(hal.取元素(OP,0),20),hal.加(hal.取元素(OP,0),20),hal.加(hal.取元素(OP,0),20)))
hal.赋值(ColumnNew,hal.创建元组(hal.减(hal.取元素(OP,1),45),hal.加(hal.取元素(OP,1),55),hal.减(hal.取元素(OP,1),90),hal.加(hal.取元素(OP,1),35)))
hal.vector_to_proj_hom_mat2d(Row,Column,RowNew,ColumnNew,"normalized_dlt",hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),hal.创建元组(),HomMat2D,Covariance)
hal.projective_trans_image_size(ImagePart,TransImage,HomMat2D,"bilinear",500,400,"false")
' 
hal.dev_clear_window()
hal.dev_set_line_width(3)
hal.dev_set_color("gray")
hal.dev_set_draw("fill")
' 
.判断开始 (hal.是否为真(Tilt))
hal.dev_display(CameraTilt)
hal.dev_set_color("forest green")
hal.dev_display(LensPlane)
hal.dev_display(ImagePlane)
hal.dev_display(ScheimpflugAxis)
hal.dev_display(ObjectPlane)
hal.disp_message(hal.取元素(WindowHandle,0),"object plane","image",hal.取元素(S,0),hal.加(hal.取元素(S,1),100),"forest green","false")
hal.disp_message(hal.取元素(WindowHandle,0),"S","image",hal.取元素(S,0),hal.取元素(S,1),"forest green","false")
hal.disp_message(hal.取元素(WindowHandle,0),"image plane","image",hal.减(hal.除(hal.加(hal.取元素(S,0),hal.取元素(CP,0)),2),180),hal.减(hal.除(hal.加(hal.取元素(S,1),hal.取元素(CP,1)),2),40),"forest green","false")
hal.disp_message(hal.取元素(WindowHandle,0),"lens plane","image",hal.除(hal.加(hal.取元素(S,0),hal.取元素(LP,0)),2),hal.除(hal.加(hal.取元素(S,1),hal.取元素(LP,1)),2),"forest green","false")
.默认
hal.dev_display(Camera)
hal.dev_set_color("black")
hal.dev_display(ObjectPlane)
'     
.判断结束

hal.dev_display(TransImage)
hal.dev_display(OpticalAxis)
hal.dev_set_color("gray")
hal.dev_display(Obstacle)
hal.dev_display(Lens)
hal.disp_message(hal.取元素(WindowHandle,0),"optical axis","image",hal.减(hal.除(hal.加(hal.取元素(LP,0),hal.取元素(OP,0)),2),20),hal.除(hal.加(hal.取元素(LP,1),hal.取元素(OP,1)),2),"black","false")
hal.disp_message(hal.取元素(WindowHandle,0),"lens","image",hal.加(hal.取元素(LP,0),25),hal.减(hal.取元素(LP,1),30),"black","false")
hal.disp_message(hal.取元素(WindowHandle,0),"obstacle","image",60,300,"black","false")
hal.disp_message(hal.取元素(WindowHandle,0),"camera","image",hal.取元素(CP,0),hal.取元素(CP,1),"black","false")
return()

.子程序 open_two_windows_setup
.参数 Width, tuple
.参数 Height, tuple
.参数 Scale, tuple
.参数 WindowHandles, tuple, 参考
.局部变量 Column, 视觉元组
.局部变量 Height1, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 Width1, 视觉元组
.局部变量 WindowHandle1, 视觉元组
.局部变量 WindowHandle2, 视觉元组

' This procedure opens two windows in order to display
' the images and results for this example
' 
hal.dev_open_window_fit_size(0,0,Width,Height,640,-1,WindowHandle2)
hal.dev_set_draw("margin")
hal.dev_set_line_width(1)
hal.dev_set_color("green")
hal.set_display_font(WindowHandle2,14,"mono","true","false")
' 
hal.get_window_extents(WindowHandle2,Row,Column,Width1,Height1)
hal.dev_open_window(hal.减(Height1,200),0,250,200,"white",WindowHandle1)
hal.dev_set_part(0,0,399,499)
hal.dev_set_draw("margin")
hal.dev_set_line_width(1)
hal.dev_set_color("green")
hal.set_display_font(WindowHandle1,14,"mono","true","false")
' 
hal.赋值(WindowHandles,hal.创建元组(WindowHandle1,WindowHandle2))

.子程序 p_do_calibrate_cameras_telecentric_tilt
.局部变量 AmplitudeFirst, 视觉元组
.局部变量 AmplitudeSecond, 视觉元组
.局部变量 CalibDataID, 视觉元组
.局部变量 Caltab, 视觉对象
.局部变量 CamParam, 视觉元组
.局部变量 Circles, 视觉对象
.局部变量 Col, 视觉元组
.局部变量 ColumnCoord, 视觉元组
.局部变量 ColumnEdgeFirst, 视觉元组
.局部变量 ColumnEdgeSecond, 视觉元组
.局部变量 Cross, 视觉对象
.局部变量 DescrFile, 视觉元组
.局部变量 DeviationDistance, 视觉元组
.局部变量 Distance, 视觉元组
.局部变量 Error, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageBlurred, 视觉对象
.局部变量 ImageMeasurementPlane, 视觉对象
.局部变量 ImagePart, 视觉对象
.局部变量 ImageSharp, 视觉对象
.局部变量 Index, 视觉元组
.局部变量 Indices, 视觉元组
.局部变量 InterDistance, 视觉元组
.局部变量 IntraDistance, 视觉元组
.局部变量 MeanDistance, 视觉元组
.局部变量 MeasureHandle, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 ParLabels, 视觉元组
.局部变量 Poses, 视觉元组
.局部变量 ROIBlurredL, 视觉对象
.局部变量 ROIBlurredR, 视觉对象
.局部变量 Rectangle, 视觉对象
.局部变量 Rot, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 RowCoor, 视觉元组
.局部变量 RowEdgeFirst, 视觉元组
.局部变量 RowEdgeSecond, 视觉元组
.局部变量 StartCamParam, 视觉元组
.局部变量 Sx, 视觉元组
.局部变量 Sy, 视觉元组
.局部变量 Tilt, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandles, 视觉元组
.局部变量 X1, 视觉元组
.局部变量 Y1, 视觉元组

' 
' This example demonstrates the benefit of a tilt lens
' and calibrates a camera with a telecentric tilt lens.
' Some peculiarities for telecentric tilt lenses are
' pointed out.
' 
' Prepare windows
hal.dev_update_off()
hal.dev_close_window()
hal.read_image(ImageBlurred,"caliper/caliper_no_tilt")
hal.get_image_size(ImageBlurred,Width,Height)
open_two_windows_setup(hal.克隆元组(Width),hal.克隆元组(Height),hal.创建元组(1),WindowHandles)
' 
' When the optical axis is not perpendicular to the
' measurement plane, the volume of the depth of focus
' is not parallel to the measurement plane.
' As a consequence of this camera setup, a part of an object
' lying in the measurement plane appears blurred in the image.
hal.dev_set_window(hal.取元素(WindowHandles,0))
hal.read_image(ImageBlurred,"caliper/caliper_no_tilt")
hal.get_image_size(ImageBlurred,Width,Height)
hal.crop_rectangle1(ImageBlurred,ImagePart,134,134,1000,1000)
' Generate image of the scene
hal.赋值(Message,"If the optical axis is not perpendicular to the measurement plane,")
hal.dev_set_window(hal.取元素(WindowHandles,1))
hal.gen_rectangle1(ROIBlurredL,231,844,897,1276)
hal.gen_rectangle1(ROIBlurredR,231,7,897,170)
hal.dev_display(ImageBlurred)
hal.dev_set_color("red")
hal.dev_set_line_width(2)
hal.dev_display(ROIBlurredR)
hal.dev_display(ROIBlurredL)
hal.赋值元组元素(Message,1,"parts of the object in the measurement plane are blurred in the image.")
hal.disp_message(hal.取元素(WindowHandles,1),Message,"window",12,12,"black","true")
show_setup(hal.克隆对象(ImagePart),hal.创建元组(hal.取元素(WindowHandles,0)),hal.创建元组(0))
hal.dev_set_window(hal.取元素(WindowHandles,0))
hal.wait_seconds(3)
' 
' If the camera is equipped with a tilt lens,
' the lens can be tilted so that the whole measurement
' plane is in focus.
hal.read_image(ImageSharp,"caliper/caliper_with_tilt")
hal.dev_set_window(hal.取元素(WindowHandles,1))
hal.dev_display(ImageSharp)
hal.赋值(Message,"If the camera is equipped with a tilt lens, the lens can be tilted")
hal.赋值元组元素(Message,1,"so that the entire measurement plane is in focus.")
hal.disp_message(hal.取元素(WindowHandles,1),Message,"window",12,12,"black","true")
show_setup(hal.克隆对象(ImagePart),hal.创建元组(hal.取元素(WindowHandles,0)),hal.创建元组(1))
'* disp_continue_message (WindowHandles[1], 'black', 'true')
hal.wait_seconds(3)
' 
' Calibration of a camera with telecentric tilt lens
hal.dev_set_window(hal.取元素(WindowHandles,0))
hal.dev_close_window()
hal.赋值(Message,"Calibrate camera with a telecentric tilt lens")
hal.dev_set_window(hal.取元素(WindowHandles,1))
hal.dev_set_color("green")
' Specify initial camera parameter.
' The tilt angle defines the angle by which the
' lens is tilted.
hal.赋值(Tilt,8.5)
' The rotation angle defines the orientation of
' the axis around which the tilt is performed.
' It is the angle between the x-axis of
' the sensor and the tilt axis of the lens.
hal.赋值(Rot,270)
' Define size of a pixel in world coordinates
hal.赋值(Sx,1.54e-5)
hal.赋值(Sy,Sx)
hal.赋值(StartCamParam,hal.创建元组(0,到小数(0.0),Tilt,Rot,Sx,Sy,hal.除(Width,2),hal.除(Height,2),Width,Height))
hal.赋值(DescrFile,"calplate_40mm.cpd")
' 
' Create the calibration data model
hal.create_calib_data("calibration_object",1,1,CalibDataID)
hal.set_calib_data_cam_param(CalibDataID,0,"area_scan_telecentric_tilt_division",StartCamParam)
hal.set_calib_data_calib_object(CalibDataID,0,DescrFile)
' 
' Input calibration data into the calibration model
hal.赋值 (Index, 1)
.判断循环首 (hal.小于等于 (Index, 8))
hal.read_image(Image,hal.加("stereo/telecentric_tilt/cam_0_calib_plate_",hal.文本格式化(Index,"02")))
hal.find_calib_object(Image,CalibDataID,0,0,Index,"sigma",2.5)
hal.get_calib_data_observ_contours(Caltab,CalibDataID,"caltab",0,0,Index)
hal.get_calib_data_observ_contours(Circles,CalibDataID,"marks",0,0,Index)
'     Visualize calibration object found in the current image
hal.dev_display(Image)
hal.dev_display(Caltab)
hal.dev_display(Circles)
hal.disp_message(hal.取元素(WindowHandles,1),Message,"window",12,12,"black","true")
hal.wait_seconds(0.1)
Index ＝ hal.加 (Index, 1)
.判断循环尾 ()
' 
' Calibrate the cameras
hal.calibrate_cameras(CalibDataID,Error)
' Inspect the calibration results
hal.get_calib_data(CalibDataID,"camera",0,"params",CamParam)
' Get the names of the camera parameters for this model
hal.get_calib_data(CalibDataID,"camera",0,"params_labels",ParLabels)
hal.赋值(Message,"Measure the mean distance of the pitch lines")
hal.赋值元组元素(Message,1,"of a caliper with high accuracy.")
hal.dev_set_line_width(2)
' 
' Extract measurement plane using the optimized
' camera parameters
hal.read_image(ImageMeasurementPlane,"caliper/caliper_measurement_plane")
hal.find_calib_object(ImageMeasurementPlane,CalibDataID,0,0,0,"sigma",0.5)
hal.get_calib_data_observ_points(CalibDataID,0,0,0,RowCoor,ColumnCoord,Indices,Poses)
' 
' Note that for telecentric cameras the distance z
' to the camera does not have an effect on the appearance of
' the calibration plate in the image. Therefore cannot be
' determined. Another consequence is that the pose of the
' measurement plane does not need to be compensated
' for the plate thickness.
' 
' Measure the mean distance between the pitch lines
hal.gen_measure_rectangle2(670,640,hal.rad(0),635,31,Width,Height,"bilinear",MeasureHandle)
hal.gen_rectangle2(Rectangle,670,640,hal.rad(0),635,31)
' 
' Determine the image positions of the pitch lines
hal.measure_pairs(ImageSharp,MeasureHandle,2,50,"all","all",RowEdgeFirst,ColumnEdgeFirst,AmplitudeFirst,RowEdgeSecond,ColumnEdgeSecond,AmplitudeSecond,IntraDistance,InterDistance)
hal.赋值(Row,hal.除(hal.加(RowEdgeFirst,RowEdgeSecond),到小数(2.0)))
hal.赋值(Col,hal.除(hal.加(ColumnEdgeFirst,ColumnEdgeSecond),到小数(2.0)))
hal.gen_cross_contour_xld(Cross,Row,Col,20,0.785398)
hal.dev_display(ImageSharp)
hal.dev_display(Cross)
' 
' Determine the positions of the pitch lines in camera coordinates
hal.image_points_to_world_plane(CamParam,Poses,Row,Col,"mm",X1,Y1)
hal.distance_pp(hal.取元素范围(X1,0,2),hal.取元素范围(Y1,0,2),hal.取元素范围(X1,1,3),hal.取元素范围(Y1,1,3),Distance)
' 
' Compute the mean and the deviation of the distances.
hal.赋值(MeanDistance,hal.mean(Distance))
hal.赋值(DeviationDistance,hal.deviation(Distance))
hal.disp_message(hal.取元素(WindowHandles,1),hal.创建元组(Message,hal.加(hal.加("Mean distance: ",hal.文本格式化(MeanDistance,".3f"))," mm"),hal.加(hal.加(hal.文本格式化("Deviation:","-15"),hal.文本格式化(DeviationDistance,".3f"))," mm")),"window",12,12,"black","true")
hal.wait_seconds(5)
hal.close_measure(MeasureHandle)
' 
' Delete calibration data model
hal.clear_calib_data(CalibDataID)
return()

.子程序 display_side
.参数 WindowHandleDisp, tuple
.参数 SideString, tuple
.参数 Finished, tuple
.局部变量 Alpha, 视觉元组
.局部变量 Color, 视觉元组
.局部变量 DisplayAlpha, 视觉元组
.局部变量 DisplayColor, 视觉元组
.局部变量 DisplayLines, 视觉元组
.局部变量 DisplayOptions, 视觉元组
.局部变量 DisplayValues, 视觉元组
.局部变量 OM3DBack, 视觉元组
.局部变量 OM3DBottom, 视觉元组
.局部变量 OM3DCorners, 视觉元组
.局部变量 OM3DFront, 视觉元组
.局部变量 OM3DLeft, 视觉元组
.局部变量 OM3DLines, 视觉元组
.局部变量 OM3DRight, 视觉元组
.局部变量 OM3DTop, 视觉元组
.局部变量 Pose, 视觉元组
.局部变量 Side, 视觉元组
.局部变量 SideStringCapital, 视觉元组
.局部变量 X, 视觉元组
.局部变量 Y, 视觉元组
.局部变量 Z, 视觉元组

' This procedure displayes a regular cube with the Side (Input control parameter)
' highlighted. If Finished is true, then the corresponding is highlighted
' in green, otherwise in red. The cube consists of 6 single planar object
' model 3D.
hal.赋值(Pose,hal.创建元组(-0.595188,-0.424915,120,8.36578,10.6173,358.628,0))
hal.赋值(Alpha,0.2)
' 
hal.赋值(Color,"red")
' 
hal.赋值(DisplayColor,hal.创建元组(Color,Color,Color,Color,Color,Color,"yellow"))
hal.赋值(DisplayAlpha,hal.创建元组(Alpha,Alpha,Alpha,Alpha,Alpha,Alpha,到小数(1.0)))
hal.赋值(DisplayLines,hal.创建元组("1.0 1.0 1.0","0.0 0.0 0.0","0.5 0.5 0.5 0.0","true","black",到小数(6.0)))
' 
hal.赋值(Side,hal.查找元素(hal.创建元组("front","left","back","right","bottom","top"),SideString))
hal.赋值(SideStringCapital,hal.创建元组("Front","Left","Back","Right","Bottom","Top"))
' 
.判断开始 (hal.是否为真(Finished))
hal.赋值元组元素(DisplayColor,hal.取元组整数(Side),"green")
.判断结束

' 
hal.赋值元组元素(DisplayAlpha,hal.取元组整数(Side),到小数(1.0))
' 
hal.赋值(DisplayValues,hal.创建元组(DisplayColor,DisplayAlpha,DisplayLines))
' 
' Generate cube points
hal.赋值(X,hal.创建元组(0,0,1,1,0,0,1,1))
hal.赋值(Y,hal.创建元组(0,1,1,0,0,1,0,1))
hal.赋值(Z,hal.创建元组(0,0,0,0,1,1,1,1))
' 
' Generate the side planes of the cube
hal.gen_plane_object_model_3d(hal.创建元组(0,0,0,0,0,0,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DFront)
hal.gen_plane_object_model_3d(hal.创建元组(0,0,1,0,0,0,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DBack)
hal.gen_plane_object_model_3d(hal.创建元组(0,0,0,0,-90,0,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DLeft)
hal.gen_plane_object_model_3d(hal.创建元组(0,1,0,90,0,0,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DBottom)
hal.gen_plane_object_model_3d(hal.创建元组(1,0,0,0,-90,0,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DRight)
hal.gen_plane_object_model_3d(hal.创建元组(1,0,0,90,0,90,0),hal.取元素范围(X,0,3),hal.取元素范围(Y,0,3),OM3DTop)
' 
' To optimize the display for different systems
.判断开始 (hal.不等于(Side,0))
hal.gen_empty_object_model_3d(OM3DFront)
.判断结束

.判断开始 (hal.不等于(Side,3))
hal.gen_empty_object_model_3d(OM3DRight)
.判断结束

' 
' Generate 3D model of the corners and their connecting lines
hal.gen_object_model_3d_from_points(X,Y,Z,OM3DCorners)
hal.set_object_model_3d_attrib(OM3DCorners,"lines",hal.创建元组(),hal.创建元组(2,0,1,2,1,2,2,2,3,2,3,0,2,0,4,2,4,5,2,5,1,2,6,3,2,7,2,2,4,5,2,5,7,2,7,6,2,6,4),OM3DLines)
' 
' Display object models 3D
hal.赋值(DisplayOptions,hal.创建元组("color_0","color_1","color_2","color_3","color_4","color_5","color_6","alpha_0","alpha_1","alpha_2","alpha_3","alpha_4","alpha_5","alpha_6","light_ambient","light_diffuse","light_position","disp_lines","line_color","point_size"))
hal.disp_object_model_3d(WindowHandleDisp,hal.创建元组(OM3DFront,OM3DLeft,OM3DBack,OM3DRight,OM3DBottom,OM3DTop,OM3DCorners,OM3DLines),hal.创建元组(),Pose,DisplayOptions,DisplayValues)
' 
hal.clear_object_model_3d(OM3DFront)
hal.clear_object_model_3d(OM3DBack)
hal.clear_object_model_3d(OM3DLeft)
hal.clear_object_model_3d(OM3DBottom)
hal.clear_object_model_3d(OM3DRight)
hal.clear_object_model_3d(OM3DTop)
hal.clear_object_model_3d(OM3DCorners)
hal.clear_object_model_3d(OM3DLines)
' 
hal.disp_message(WindowHandleDisp,hal.取元素(SideStringCapital,Side),"window",12,12,"black","true")
return()

.子程序 p_do_find_text_expiration_date
.局部变量 BoxIdx, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Date, 视觉对象
.局部变量 DateIdx, 视觉元组
.局部变量 Dates, 视觉元组
.局部变量 Finished, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageIdx, 视觉元组
.局部变量 ImageString, 视觉元组
.局部变量 J, 视觉元组
.局部变量 NumLines, 视觉元组
.局部变量 Order, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 TextLines, 视觉对象
.局部变量 TextModel, 视觉元组
.局部变量 TextResult, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 WindowHandleBox, 视觉元组

' This example shows how find_text can be used to find and read
' expiration dates from medication packages. In general, the
' expiration dates of medication packages from different manufacteurs
' are located on different sides of the package. The following example
' reads the text of each side of different medication packages
' and searches for an expiry date. As soon as an expiration date is
' found, the next package is processed.
' 
hal.dev_update_off()
hal.dev_close_window()
' Initialize window handle
hal.dev_open_window_fit_size(0,0,960,768,640,600,WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
' 
' Create the text model using the pre-trained 'Industrial_Rej' font
hal.create_text_model_reader("auto","Industrial_Rej",TextModel)
' 
' Determine the order with which to search for the expiration date
' in the medical packages:
hal.赋值(Order,hal.创建元组("front","left","back","right","bottom","top"))
' 
' Initialize window handle to help display the package side
hal.get_window_extents(WindowHandle,Row,Column,Width,Height)
hal.dev_open_window(hal.减(Height,150),0,150,150,"black",WindowHandleBox)
hal.set_display_font(WindowHandleBox,16,"mono","true","false")
hal.赋值 (J, 1)
.判断循环首 (hal.小于等于 (J, 1))
hal.赋值 (BoxIdx, 0)
.判断循环首 (hal.小于等于 (BoxIdx, 2))
'         Search for the date on each side of the medicine package
hal.赋值(Dates,"")
hal.赋值(Finished,0)
hal.赋值 (ImageIdx, 0)
.判断循环首 (hal.小于等于 (ImageIdx, 5))
hal.赋值(ImageString,hal.加(hal.加(hal.加("ocr/medication_package_",hal.文本格式化(hal.加(BoxIdx,1),"0.2d")),"_"),hal.取元素(Order,ImageIdx)))
hal.read_image(Image,ImageString)
'             
hal.find_text(Image,TextModel,TextResult)
'             
'             Read all text lines from TextResult
hal.get_text_object(TextLines,TextResult,"all_lines")
hal.get_text_result(TextResult,"num_lines",NumLines)
'             
'             Read the text lines one after the other and check for dates
select_expiry_date(Date,hal.克隆元组(NumLines),hal.克隆元组(TextResult),hal.克隆元组(Dates),hal.克隆元组(ImageIdx),DateIdx,Dates)
hal.clear_text_result(TextResult)
'             
'             Display results
hal.dev_set_window(WindowHandle)
hal.dev_set_colored(12)
hal.dev_display(Image)
hal.dev_display(TextLines)
'             
'             Show what is happening step by step
disp_steps(hal.克隆对象(Date),hal.克隆元组(BoxIdx),hal.克隆元组(WindowHandle),hal.克隆元组(Dates),Finished)
'             
'             Display cube current side
display_side(hal.克隆元组(WindowHandleBox),hal.创建元组(hal.取元素(Order,ImageIdx)),hal.克隆元组(Finished))
'             
'             For the first iteration, show what is happening in each step
.判断开始 (hal.且(hal.等于(BoxIdx,0),hal.等于(J,1)))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

.判断开始 (hal.是否为真(Finished))
跳出循环 ()
.判断结束

ImageIdx ＝ hal.加 (ImageIdx, 1)
.判断循环尾 ()
hal.wait_seconds(1)
BoxIdx ＝ hal.加 (BoxIdx, 1)
.判断循环尾 ()
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.dev_set_window(WindowHandleBox)
hal.dev_close_window()
hal.clear_text_model(TextModel)
return()

.子程序 p_do_find_barcode
.局部变量 Area, 视觉元组
.局部变量 BarCodeHandle, 视觉元组
.局部变量 BarCodeResults, 视觉元组
.局部变量 CodabarFiles, 视觉元组
.局部变量 Code128Files, 视觉元组
.局部变量 Code39Files, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 DecodedDataStrings, 视觉元组
.局部变量 EAN13Addon5Files, 视觉元组
.局部变量 EAN13Files, 视觉元组
.局部变量 EAN8Files, 视觉元组
.局部变量 GS1CompositeFiles, 视觉元组
.局部变量 GS1ExpandedFiles, 视觉元组
.局部变量 GS1ExpandedStackedFiles, 视觉元组
.局部变量 GS1LimitedFiles, 视觉元组
.局部变量 GS1OmnidirFiles, 视觉元组
.局部变量 GS1StackedFiles, 视觉元组
.局部变量 GS1StackedOmnidirFiles, 视觉元组
.局部变量 GS1TruncatedFiles, 视觉元组
.局部变量 GS1_128Files, 视觉元组
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageFiles, 视觉元组
.局部变量 IndustrialFiles, 视觉元组
.局部变量 InterleavedFiles, 视觉元组
.局部变量 J, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 MixedFiles, 视觉元组
.局部变量 Row, 视觉元组
.局部变量 S1, 视觉元组
.局部变量 S2, 视觉元组
.局部变量 ShuffledIndices, 视觉元组
.局部变量 String, 视觉元组
.局部变量 SymbolRegions, 视觉对象
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组

hal.dev_update_off()
hal.dev_close_window()
hal.dev_open_window(0,0,640,512,"black",WindowHandle)
hal.set_display_font(WindowHandle,16,"mono","true","false")
hal.赋值(IndustrialFiles,hal.加("25industrial/25industrial0",hal.创建序列(1,4, 1)))
hal.赋值(InterleavedFiles,hal.加("25interleaved/25interleaved",hal.创建元组(hal.文本格式化(hal.创建序列(1,16, 1),"02"),hal.加("_exposure_0",hal.创建序列(1,5, 1)),"_zeiss1")))
hal.赋值(CodabarFiles,hal.加("codabar/codabar0",hal.创建序列(1,6, 1)))
hal.赋值(Code128Files,"code128/code12801")
hal.赋值(Code39Files,hal.加("code39/code390",hal.创建序列(2,4, 1)))
hal.赋值(EAN13Files,hal.加("ean13/",hal.创建元组(hal.加("ean13",hal.创建元组(hal.文本格式化(hal.创建序列(1,12, 1),"02"),"_label",hal.加("_to_preprocess_0",hal.创建序列(2,3, 1)))),hal.加("tea_box_",hal.文本格式化(hal.创建序列(1,8, 1),"02")))))
hal.赋值(EAN13Addon5Files,"ean13addon5/ean13addon501")
hal.赋值(EAN8Files,"ean8/ean801")
hal.赋值(MixedFiles,hal.加("mixed/barcode_mixed_",hal.创建元组(hal.文本格式化(hal.创建序列(1,2, 1),"02"),"quiet_zone")))
hal.赋值(GS1_128Files,hal.加(hal.加("gs1_128/gs1_128_","generated_0"),hal.创建序列(1,3, 1)))
hal.赋值(GS1CompositeFiles,"gs1databar_composite/gs1databar_limited_composite_01")
hal.赋值(GS1ExpandedFiles,hal.加("gs1databar_expanded/gs1databar_expanded_calibration_",hal.创建元组("01","aperture_focus","init_position")))
hal.赋值(GS1ExpandedStackedFiles,hal.加("gs1databar_expanded_stacked/gs1databar_expanded_stacked_0",hal.创建序列(1,2, 1)))
hal.赋值(GS1LimitedFiles,"gs1databar_limited/gs1databar_limited_no_deform")
hal.赋值(GS1OmnidirFiles,hal.加("gs1databar_omnidir/gs1databar_omnidir_0",hal.创建序列(1,2, 1)))
hal.赋值(GS1StackedFiles,"gs1databar_stacked/gs1databar_stacked_01")
hal.赋值(GS1StackedOmnidirFiles,hal.加("gs1databar_stacked_omnidir/gs1databar_stacked_omnidir_0",hal.创建序列(1,2, 1)))
hal.赋值(GS1TruncatedFiles,"gs1databar_truncated/gs1databar_truncated_02")
hal.赋值(ImageFiles,hal.加("barcode/",hal.创建元组(IndustrialFiles,InterleavedFiles,CodabarFiles,Code128Files,Code39Files,EAN13Files,MixedFiles)))
hal.赋值(ImageFiles,hal.创建元组(ImageFiles,hal.加("barcode/",hal.创建元组(EAN8Files,GS1_128Files,GS1CompositeFiles,GS1ExpandedFiles,GS1ExpandedStackedFiles))))
hal.赋值(ImageFiles,hal.创建元组(ImageFiles,hal.加("barcode/",hal.创建元组(GS1LimitedFiles,GS1OmnidirFiles,GS1StackedFiles,GS1StackedOmnidirFiles,GS1TruncatedFiles))))
hal.赋值(ShuffledIndices,hal.sort_index(hal.rand(hal.取元素总数(ImageFiles))))
hal.create_bar_code_model("min_identical_scanlines",2,BarCodeHandle)
hal.赋值 (I, 0)
.判断循环首 (hal.小于等于 (I, hal.减(hal.取元素总数(ImageFiles),1)))
hal.read_image(Image,hal.取元素(ImageFiles,hal.取元素(ShuffledIndices,I)))
hal.get_image_size(Image,Width,Height)
.判断开始 (hal.小于(Width,Height))
hal.rotate_image(Image,Image,90,"constant")
.判断结束

hal.count_seconds(S1)
hal.find_bar_code(Image,SymbolRegions,BarCodeHandle,"auto",DecodedDataStrings)
hal.count_seconds(S2)
hal.dev_resize_window_fit_image(Image,0,0,hal.创建元组(640,640),-1)
hal.dev_display(Image)
hal.dev_set_draw("margin")
hal.dev_set_color("green")
hal.dev_set_line_width(3)
hal.dev_display(SymbolRegions)
hal.area_center(SymbolRegions,Area,Row,Column)
hal.get_bar_code_result(BarCodeHandle,"all","decoded_types",BarCodeResults)
hal.赋值(Message,hal.加(hal.加(hal.加(hal.加("Found ",hal.取元素总数(Row))," code(s) in "),hal.文本格式化(hal.乘(hal.减(S2,S1),1000),"0.2"))," ms"))
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(Row),1)))
hal.赋值(String,hal.加(hal.加(hal.取元素(BarCodeResults,J),": "),hal.取元素(DecodedDataStrings,J)))
hal.disp_message(WindowHandle,String,"image",hal.取元素(Row,J),hal.减(hal.取元素(Column,J),50),"black","true")
J ＝ hal.加 (J, 1)
.判断循环尾 ()
.判断开始 (hal.小于(I,6))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
return()

.子程序 project_xy_to_image
.参数 XC1, tuple
.参数 YC1, tuple
.参数 MeasurementPlaneAdjusted, tuple
.参数 CameraParam, tuple
.参数 Row1, tuple, 参考
.参数 Column1, tuple, 参考
.局部变量 HomMat3D, 视觉元组
.局部变量 Qx, 视觉元组
.局部变量 Qy, 视觉元组
.局部变量 Qz, 视觉元组

hal.pose_to_hom_mat3d(MeasurementPlaneAdjusted,HomMat3D)
hal.affine_trans_point_3d(HomMat3D,XC1,YC1,hal.乘(0,XC1),Qx,Qy,Qz)
hal.project_3d_point(Qx,Qy,Qz,CameraParam,Row1,Column1)
return()

.子程序 p_do_metrology_model
.局部变量 AdjustThickness, 视觉元组
.局部变量 AngleAlign, 视觉元组
.局部变量 Area, 视觉元组
.局部变量 BorderShapeModel, 视觉元组
.局部变量 CalibPlateThickness, 视觉元组
.局部变量 CameraParam, 视觉元组
.局部变量 CircleIndices1, 视觉元组
.局部变量 CircleIndices2, 视觉元组
.局部变量 CircleParam, 视觉元组
.局部变量 CircleParam1, 视觉元组
.局部变量 CircleParam2, 视觉元组
.局部变量 Column, 视觉元组
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 ColumnAlign, 视觉元组
.局部变量 ColumnModel, 视觉元组
.局部变量 ColumnR, 视觉元组
.局部变量 Contour, 视觉对象
.局部变量 CurrentImage, 视觉对象
.局部变量 EmptyObject, 视觉对象
.局部变量 Height, 视觉元组
.局部变量 I, 视觉元组
.局部变量 Image, 视觉对象
.局部变量 ImageReduced, 视觉对象
.局部变量 Index3, 视觉元组
.局部变量 J, 视觉元组
.局部变量 Length1R, 视觉元组
.局部变量 Length2R, 视觉元组
.局部变量 Line1, 视觉元组
.局部变量 Line2, 视觉元组
.局部变量 LineIndices, 视觉元组
.局部变量 Loop, 视觉元组
.局部变量 MeasureContour, 视觉对象
.局部变量 MeasurementPlane, 视觉元组
.局部变量 MeasurementPlaneAdjusted, 视觉元组
.局部变量 Message, 视觉元组
.局部变量 MetrologyHandle, 视觉元组
.局部变量 ModelContour, 视觉对象
.局部变量 ModelRegion, 视觉对象
.局部变量 ParamLine1, 视觉元组
.局部变量 ParamLine2, 视觉元组
.局部变量 PartHeight, 视觉元组
.局部变量 RadiusC1, 视觉元组
.局部变量 RadiusC2, 视觉元组
.局部变量 RectIndices, 视觉元组
.局部变量 RectangleParam, 视觉元组
.局部变量 Region, 视觉对象
.局部变量 ResultContours, 视觉对象
.局部变量 Row, 视觉元组
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组
.局部变量 RowAlign, 视觉元组
.局部变量 RowModel, 视觉元组
.局部变量 RowR, 视觉元组
.局部变量 Score, 视觉元组
.局部变量 ShapeModelContours, 视觉对象
.局部变量 ShapeModelID, 视觉元组
.局部变量 UsedColumn, 视觉元组
.局部变量 UsedEdges, 视觉对象
.局部变量 UsedRow, 视觉元组
.局部变量 Width, 视觉元组
.局部变量 WindowHandle, 视觉元组
.局部变量 XC1, 视觉元组
.局部变量 XC2, 视觉元组
.局部变量 XRectangle, 视觉元组
.局部变量 YC1, 视觉元组
.局部变量 YC2, 视觉元组
.局部变量 YRectangle, 视觉元组

' This program shows how the metrology model can be used to
' obtain calibrated measurements for various geometric forms
' lying in a plane. The parameters of the geometric forms are
' derived from a model image.
' 
' To find the objects to be measured in a new image,
' shape-based matching is used.
' 
' The results of a measurement are returned as contours
' and as adjusted parameters of the given geometric objects
' 
' 
' Initialize visualization
hal.dev_update_off()
hal.dev_close_window()
hal.dev_set_draw("margin")
hal.gen_empty_obj(EmptyObject)
hal.read_image(Image,"metal-parts/circle_plate_01")
hal.get_image_size(Image,Width,Height)
hal.dev_open_window_fit_image(Image,0,0,640,-1,WindowHandle)
p_set_font(hal.克隆元组(WindowHandle))
' 
' Part I:
' 
' Initialize metrology model
' 
' Define camera parameter
hal.赋值(CameraParam,hal.创建元组(0.0128649,-661.434,5.30004e-006,5.3e-006,620.043,497.402,Width,Height))
' The pose of the measurement plane was derived by placing a
' calibration plate in the plane of the object to be measured
' and by determining its pose
hal.赋值(MeasurementPlane,hal.创建元组(0.00940956,-0.00481017,0.29128,0.478648,359.65,0.785,0))
' Adjust the pose of the measurement plane
' for the height of the part and the height of the calibration plate
' 
' Thickness of the calibration plate
hal.赋值(CalibPlateThickness,0.006)
' Thickness of the object to be measured
hal.赋值(PartHeight,0.005)
hal.赋值(AdjustThickness,hal.减(CalibPlateThickness,PartHeight))
hal.set_origin_pose(MeasurementPlane,0,0,AdjustThickness,MeasurementPlaneAdjusted)
' 
' Create the metrology model and prepare it for
' calibrated measurements
hal.create_metrology_model(MetrologyHandle)
' Set the image size in advance to speed up the
' first call of apply_metrology_model.
hal.set_metrology_model_image_size(MetrologyHandle,Width,Height)
' Set the camera parameters
hal.set_metrology_model_param(MetrologyHandle,"camera_param",CameraParam)
' Set the plane in which the measured object lies
hal.set_metrology_model_param(MetrologyHandle,"plane_pose",MeasurementPlaneAdjusted)
' 
' Add the objects to be measured to the metrology model
' 
' Add several full circles
hal.赋值(CircleParam,hal.创建元组(354,274,53))
hal.赋值(CircleParam,hal.创建元组(CircleParam,350,519,53))
hal.赋值(CircleParam,hal.创建元组(CircleParam,345,764,52))
hal.赋值(CircleParam,hal.创建元组(CircleParam,596,523,53))
hal.add_metrology_object_generic(MetrologyHandle,"circle",CircleParam,20,5,1,30,hal.创建元组(),hal.创建元组(),CircleIndices1)
' 
' Add two partial circles
hal.赋值(CircleParam1,hal.创建元组(583,1010,79))
hal.赋值(CircleParam2,hal.创建元组(336,1005,77))
hal.add_metrology_object_generic(MetrologyHandle,"circle",CircleParam1,20,5,1,30,hal.创建元组("start_phi","end_phi"),hal.创建元组(0,hal.rad(185)),CircleIndices2)
hal.add_metrology_object_generic(MetrologyHandle,"circle",CircleParam2,20,5,1,30,hal.创建元组("start_phi","end_phi"),hal.创建元组(hal.rad(45),hal.rad(185)),Index3)
hal.赋值(CircleIndices2,hal.创建元组(CircleIndices2,Index3))
' 
' Add a retangle
hal.赋值(RectangleParam,hal.创建元组(599,279,hal.rad(90),62,51))
hal.add_metrology_object_generic(MetrologyHandle,"rectangle2",RectangleParam,20,5,1,30,hal.创建元组(),hal.创建元组(),RectIndices)
' Add two lines
hal.赋值(Line1,hal.创建元组(143,1122,709,1132))
hal.赋值(Line2,hal.创建元组(151,153,136,1115))
hal.add_metrology_object_generic(MetrologyHandle,"line",hal.创建元组(Line1,Line2),20,5,1,30,hal.创建元组(),hal.创建元组(),LineIndices)
' Inspect the shapes that have been added to the metrology model
hal.get_metrology_object_model_contour(ModelContour,MetrologyHandle,"all",1.5)
hal.get_metrology_object_measures(MeasureContour,MetrologyHandle,"all","all",Row,Column)
' 
' Part 2:
' 
' Prepare the alignment
' 
' 
' Create the shape model for the alignment
' of the metrology model in images where the
' object occurs in positions and orientations different
' from the ones in the image used for creating the model
hal.get_system("border_shape_models",BorderShapeModel)
hal.set_system("border_shape_models","true")
hal.threshold(Image,Region,0,50)
hal.dilation_rectangle1(Region,ModelRegion,5,5)
hal.reduce_domain(Image,ModelRegion,ImageReduced)
hal.create_shape_model(ImageReduced,6,0,hal.rad(360),"auto","auto","use_polarity","auto",20,ShapeModelID)
' The origin of the shape model is the center of the
' input region used in create_shape_model
hal.area_center(ModelRegion,Area,RowModel,ColumnModel)
hal.get_shape_model_contours(ShapeModelContours,ShapeModelID,1)
' 
' Change the reference system in which the metrology model is
' defined to correspond to the one used by the shape model.
' This is necessary to be able to directly use the results of
' find_shape_model to align the metrology model
hal.set_metrology_model_param(MetrologyHandle,"reference_system",hal.创建元组(RowModel,ColumnModel,0))
hal.get_metrology_object_model_contour(ModelContour,MetrologyHandle,"all",1.5)
hal.dev_set_part(0,0,hal.减(Height,1),hal.减(Width,1))
' 
' Online phase
hal.赋值 (Loop, 1)
.判断循环首 (hal.小于等于 (Loop, 3))
hal.赋值 (I, 1)
.判断循环首 (hal.小于等于 (I, 5))
hal.read_image(CurrentImage,hal.加("metal-parts/circle_plate_",hal.文本格式化(I,"02d")))
hal.dev_display(CurrentImage)
'         
'         
'         Measure the position and orientation of the object in the
'         current image using the shape model
hal.find_shape_model(CurrentImage,ShapeModelID,0,hal.rad(360),0.5,1,0,"least_squares",5,0.9,RowAlign,ColumnAlign,AngleAlign,Score)
hal.dev_set_line_width(1)
hal.dev_display_shape_matching_results(ShapeModelID,"white",RowAlign,ColumnAlign,AngleAlign,1,1,0)
'         
'         Use the computed position and orientation to
'         align the metrology model with its current occurrence
hal.align_metrology_model(MetrologyHandle,RowAlign,ColumnAlign,AngleAlign)
'         
'         Perform the measurement for all metrology objects in one call
hal.apply_metrology_model(CurrentImage,MetrologyHandle)
'         Get measure regions for visualization
hal.get_metrology_object_measures(Contour,MetrologyHandle,"all","all",Row,Column)
'         Get the edge points that were actually used to fit the
'         geometric forms
hal.get_metrology_object_result(MetrologyHandle,"all","all","used_edges","row",UsedRow)
hal.get_metrology_object_result(MetrologyHandle,"all","all","used_edges","column",UsedColumn)
hal.gen_cross_contour_xld(UsedEdges,UsedRow,UsedColumn,10,hal.rad(45))
'         
'         Access the results of the measurement
'         Since camera parameters were set, all results are given in
'         metric coordinates relative to the coordinate system
'         defined by the measurement plane
'         
'         Get a visualization of the measured geometric forms
hal.get_metrology_object_result_contour(ResultContours,MetrologyHandle,"all","all",1.5)
'         Extract the radius of the smaller circles
hal.get_metrology_object_result(MetrologyHandle,CircleIndices1,"all","result_type","radius",RadiusC1)
'         Extract the radius of the larger incomplete circles
hal.get_metrology_object_result(MetrologyHandle,CircleIndices2,"all","result_type","radius",RadiusC2)
'         Extract the lengths of the rectangle sides
hal.get_metrology_object_result(MetrologyHandle,RectIndices,"all","result_type","length1",Length1R)
hal.get_metrology_object_result(MetrologyHandle,RectIndices,"all","result_type","length2",Length2R)
'         Get the start and end point of each measured line
hal.get_metrology_object_result(MetrologyHandle,hal.取元素(LineIndices,0),"all","result_type","all_param",ParamLine1)
hal.get_metrology_object_result(MetrologyHandle,hal.取元素(LineIndices,1),"all","result_type","all_param",ParamLine2)
'         Display the results
hal.dev_set_line_width(1)
hal.dev_set_color("light gray")
hal.dev_display(Contour)
hal.dev_set_color("green")
hal.dev_set_line_width(2)
hal.dev_display(ResultContours)
hal.dev_set_line_width(1)
hal.dev_set_color("white")
hal.dev_display(UsedEdges)
'         
'         Display the radii for each circle at the circle centers
'         Obtain the metric coordinates of the circle centers
hal.get_metrology_object_result(MetrologyHandle,CircleIndices1,"all","result_type","x",XC1)
hal.get_metrology_object_result(MetrologyHandle,CircleIndices1,"all","result_type","y",YC1)
'         Project the metric coordinates of the circle centers
'         into the image to get the image coordinates of the
'         circle centers
project_xy_to_image(hal.克隆元组(XC1),hal.克隆元组(YC1),hal.克隆元组(MeasurementPlaneAdjusted),hal.克隆元组(CameraParam),Row1,Column1)
hal.get_metrology_object_result(MetrologyHandle,CircleIndices2,"all","result_type","x",XC2)
hal.get_metrology_object_result(MetrologyHandle,CircleIndices2,"all","result_type","y",YC2)
project_xy_to_image(hal.克隆元组(XC2),hal.克隆元组(YC2),hal.克隆元组(MeasurementPlaneAdjusted),hal.克隆元组(CameraParam),Row2,Column2)
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(RadiusC1),1)))
hal.disp_message(WindowHandle,hal.加("r=",hal.文本格式化(hal.乘(hal.取元素(RadiusC1,J),1000),".2f")),"image",hal.取元素(Row1,J),hal.减(hal.取元素(Column1,J),80),"black","true")
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.赋值 (J, 0)
.判断循环首 (hal.小于等于 (J, hal.减(hal.取元素总数(RadiusC2),1)))
hal.disp_message(WindowHandle,hal.加("r=",hal.文本格式化(hal.乘(hal.取元素(RadiusC2,J),1000),".2f")),"image",hal.取元素(Row2,J),hal.减(hal.取元素(Column2,J),80),"black","true")
J ＝ hal.加 (J, 1)
.判断循环尾 ()
hal.get_metrology_object_result(MetrologyHandle,RectIndices,"all","result_type","x",XRectangle)
hal.get_metrology_object_result(MetrologyHandle,RectIndices,"all","result_type","y",YRectangle)
project_xy_to_image(hal.克隆元组(XRectangle),hal.克隆元组(YRectangle),hal.克隆元组(MeasurementPlaneAdjusted),hal.克隆元组(CameraParam),RowR,ColumnR)
hal.赋值(Area,hal.乘(hal.乘(hal.乘(hal.乘(Length1R,Length2R),4),1000),1000))
hal.disp_message(WindowHandle,hal.加("area=",hal.文本格式化(Area,".2f")),"image",RowR,hal.减(ColumnR,120),"black","true")
hal.赋值(Message,"Measured metric results (r in mm, area in mm^2)")
'         
hal.disp_message(WindowHandle,Message,"window",12,12,"black","true")
.判断开始 (hal.等于(Loop,1))
p_disp_pause_sign(hal.克隆元组(WindowHandle),hal.创建元组(2))
hal.wait_seconds(1)
.判断结束

I ＝ hal.加 (I, 1)
.判断循环尾 ()
Loop ＝ hal.加 (Loop, 1)
.判断循环尾 ()
' Clean up memory
hal.clear_metrology_model(MetrologyHandle)
hal.clear_shape_model(ShapeModelID)
hal.set_system("border_shape_models",BorderShapeModel)
return()

.子程序 disp_steps
.参数 DateLine, obj
.参数 BoxIdx, tuple
.参数 WindowHandle, tuple
.参数 Dates, tuple
.参数 Finished, tuple, 参考
.局部变量 Column1, 视觉元组
.局部变量 Column2, 视觉元组
.局部变量 Number, 视觉元组
.局部变量 Rectangle, 视觉对象
.局部变量 RegionUnion, 视觉对象
.局部变量 Row1, 视觉元组
.局部变量 Row2, 视觉元组

' This procedure helps display the current text segmentation results.
hal.count_obj(DateLine,Number)
.判断开始 (hal.等于(Number,0))
hal.disp_message(WindowHandle,"No Date found","window",12,12,"red","true")
hal.赋值(Finished,0)
.默认
hal.union1(DateLine,RegionUnion)
hal.smallest_rectangle1(RegionUnion,Row1,Column1,Row2,Column2)
hal.gen_rectangle1(Rectangle,hal.减(Row1,10),hal.减(Column1,10),hal.加(Row2,10),hal.加(Column2,10))
hal.dev_set_window(WindowHandle)
hal.dev_set_line_width(5)
hal.dev_set_color("green")
hal.dev_set_draw("margin")
hal.dev_display(Rectangle)
hal.disp_message(WindowHandle,hal.加("Date found: ",Dates),"window",12,12,"black","true")
hal.dev_set_color("black")
hal.赋值(Finished,1)
.判断结束

hal.dev_set_window(WindowHandle)
hal.dev_set_line_width(1)
hal.dev_set_colored(12)
hal.dev_set_draw("fill")
return()

.子程序 select_expiry_date
.参数 Date, obj, 参考
.参数 NumLines, tuple
.参数 TextResult, tuple
.参数 Dates, tuple
.参数 ImageIdx, tuple
.参数 DateIdx, tuple, 参考
.参数 DatesOut, tuple, 参考
.局部变量 Characters, 视觉元组
.局部变量 Length, 视觉元组
.局部变量 LineIdx, 视觉元组
.局部变量 Match, 视觉元组
.局部变量 Pos, 视觉元组
.局部变量 SelectedDigits, 视觉元组
.局部变量 TextLine, 视觉对象
.局部变量 TextLineChars, 视觉元组

' This procedure searches for date-like structures in the found text.
' Dates of the form MM/YYYY are extracted. Different forms of expiry
' dates could also be set. As an alternative, text_line_structures and
' the corresponding text_line_separators could also be set.
hal.赋值(DatesOut,Dates)
hal.gen_empty_obj(Date)
hal.赋值 (LineIdx, 0)
.判断循环首 (hal.小于等于 (LineIdx, hal.减(NumLines,1)))
'     Read text line jdx
hal.get_text_result(TextResult,hal.创建元组("class_line",LineIdx),Characters)
'     The similarity of 0's and O's leads to the fact, that they are
'     occasionaliy misclassified. Ergo, we convert all O's to 0's,
'     just to be sure
hal.tuple_regexp_replace(Characters,"O","0",TextLineChars)
hal.tuple_sum(TextLineChars,SelectedDigits)
'     The dates on the medical packages have the form MM/YYYY
hal.tuple_regexp_match(SelectedDigits,""+字符(92)+"d"+字符(92)+"d/"+字符(92)+"d"+字符(92)+"d"+字符(92)+"d"+字符(92)+"d",Match)
'     Do we have a match?
hal.tuple_strlen(Match,Length)
.判断开始 (hal.等于(Length,7))
hal.赋值(DatesOut,hal.加(DatesOut,Match))
hal.赋值(DateIdx,ImageIdx)
'         Get the corresponding text line from TextResultID
hal.get_text_object(TextLine,TextResult,hal.创建元组("line",LineIdx))
'         Find the exact position of the date within the text line
hal.tuple_strstr(SelectedDigits,Match,Pos)
hal.select_obj(TextLine,Date,hal.加(Pos,hal.创建序列(1,7, 1)))
.判断结束

LineIdx ＝ hal.加 (LineIdx, 1)
.判断循环尾 ()
return()
