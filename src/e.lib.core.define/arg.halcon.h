defARGINFO __arg_abs_diff_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("输出差分图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Absolute value of the difference of the input images."),defArg("比例因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor.")};
defARGINFO __arg_abs_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("绝对函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Function with the absolute values of the y values.")};
defARGINFO __arg_abs_image [] = {defArg("输入图像", dataTypeObj, 0, 0, "Image(s) for which the absolute gray values are to be calculated."),defArg("绝对值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s).")};
defARGINFO __arg_abs_invar_fourier_coeff [] = {defArg("实部系数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Real parts of the normalized Fourier coefficients."),defArg("虚部系数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Imaginary parts of the normalized Fourier coefficients."),defArg("系数P", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing coefficients p."),defArg("系数q", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing coefficients q."),defArg("AZ常数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of the AZ-invariants."),defArg("实部的绝对值系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Real parts of the normalized Fourier coefficients."),defArg("虚部的绝对值系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Imaginary parts of the normalized Fourier coefficients.")};
defARGINFO __arg_abs_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("输出矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the absolute values of the input matrix.")};
defARGINFO __arg_abs_matrix_mod [] = {defArg("矩阵标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix.")};
defARGINFO __arg_access_channel [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("输出图像", dataTypeObj, 0, AS_RECEIVE_VAR, "One channel of MultiChannelImage."),defArg("通道", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of channel to be accessed.")};
defARGINFO __arg_acos_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("反余弦图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_activate_compute_device [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle.")};
defARGINFO __arg_add_channels [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions (without pixel values)."),defArg("图像", dataTypeObj, 0, 0, "Input image with pixel values for regions."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image(s) with regions and pixel values (one image per input region).")};
defARGINFO __arg_add_class_train_data_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a GMM which receives the training data."),defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of training data for a classifier.")};
defARGINFO __arg_add_class_train_data_knn [] = {defArg("k近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a k-NN which receives the training data."),defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Training data for a classifier.")};
defARGINFO __arg_add_class_train_data_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle which receives the training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Training data for a classifier.")};
defARGINFO __arg_add_class_train_data_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a SVM which receives the training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Training data for a classifier.")};
defARGINFO __arg_add_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Image(s) 2."),defArg("结果图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the addition."),defArg("乘数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for gray value adaption."),defArg("加数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value for gray value range adaption.")};
defARGINFO __arg_add_matrix [] = {defArg("矩阵a", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("矩阵b", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the sum of the input matrices.")};
defARGINFO __arg_add_matrix_mod [] = {defArg("矩阵a", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("矩阵b", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B.")};
defARGINFO __arg_add_noise_distribution [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Noisy image."),defArg("分布", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Noise distribution.")};
defARGINFO __arg_add_noise_white [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像噪声", dataTypeObj, 0, AS_RECEIVE_VAR, "Noisy image."),defArg("最大噪声幅度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum noise amplitude.")};
defARGINFO __arg_add_noise_white_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Original contours."),defArg("噪声轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Noisy contours."),defArg("回归线点的个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points used to calculate the regression line."),defArg("振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum amplitude of the added noise (equally distributed in [-Amp,Amp]).")};
defARGINFO __arg_add_samples_image_class_gmm [] = {defArg("图像", dataTypeObj, 0, 0, "Training image."),defArg("类别区域", dataTypeObj, 0, 0, "Regions of the classes to be trained."),defArg("GMM句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("随机化种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gaussian noise added to the training data.")};
defARGINFO __arg_add_samples_image_class_knn [] = {defArg("图像", dataTypeObj, 0, 0, "Training image."),defArg("区域类别", dataTypeObj, 0, 0, "Regions of the classes to be trained."),defArg("最近邻分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier.")};
defARGINFO __arg_add_samples_image_class_mlp [] = {defArg("图像", dataTypeObj, 0, 0, "Training image."),defArg("类区域", dataTypeObj, 0, 0, "Regions of the classes to be trained."),defArg("MLP句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle.")};
defARGINFO __arg_add_samples_image_class_svm [] = {defArg("图像", dataTypeObj, 0, 0, "Training image."),defArg("类区域", dataTypeObj, 0, 0, "Regions of the classes to be trained."),defArg("SVM句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle.")};
defARGINFO __arg_add_sample_class_gmm [] = {defArg("GMM句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector of the training sample to be stored."),defArg("样本ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class of the training sample to be stored."),defArg("随机化种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gaussian noise added to the training data.")};
defARGINFO __arg_add_sample_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "List of features to add."),defArg("样本ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class IDs of the features.")};
defARGINFO __arg_add_sample_class_mlp [] = {defArg("MLP句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector of the training sample to be stored."),defArg("目标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class or target vector of the training sample to be stored.")};
defARGINFO __arg_add_sample_class_svm [] = {defArg("SVM句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector of the training sample to be stored."),defArg("类别", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class of the training sample to be stored.")};
defARGINFO __arg_add_sample_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The order of the feature vector."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector of the training sample."),defArg("训练样本ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class of the training sample.")};
defARGINFO __arg_adjust_mosaic_images [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("校正后的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output images."),defArg("原始图像属性", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "List of source images."),defArg("目标图像属性", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "List of destination images."),defArg("参考图像", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Reference image."),defArg("二维齐次投影矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Projective matrices."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm for the correction."),defArg("参数估计", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameters to be estimated."),defArg("OECF模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Model of OECF to be used.")};
defARGINFO __arg_affine_trans_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("轮廓图形变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed XLD contours."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix.")};
defARGINFO __arg_affine_trans_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像仿射变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed image."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("插值类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation."),defArg("调整图像大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adaption of size of result image.")};
defARGINFO __arg_affine_trans_image_size [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像仿射变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed image."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output image.")};
defARGINFO __arg_affine_trans_pixel [] = {defArg("齐次二维矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input pixel(s) (row coordinate)."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input pixel(s) (column coordinate)."),defArg("行变换", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output pixel(s) (row coordinate)."),defArg("列变换", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output pixel(s) (column coordinate).")};
defARGINFO __arg_affine_trans_point_2d [] = {defArg("齐次二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("X的坐标点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input point(s) (x or row coordinate)."),defArg("Y的坐标点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input point(s) (y or column coordinate)."),defArg("仿射变换后的X坐标点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point(s) (x or row coordinate)."),defArg("仿射变换后的Y坐标点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point(s) (y or column coordinate).")};
defARGINFO __arg_affine_trans_point_3d [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("px", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input point(s) (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input point(s) (y coordinate)."),defArg("pz", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input point(s) (z coordinate)."),defArg("qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point(s) (x coordinate)."),defArg("qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point(s) (y coordinate)."),defArg("qz", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point(s) (z coordinate).")};
defARGINFO __arg_affine_trans_polygon_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Input XLD polygons."),defArg("多边形的仿射变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed XLD polygons."),defArg("二维Hom矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix.")};
defARGINFO __arg_affine_trans_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be rotated and scaled."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed output region(s)."),defArg("齐次变换矩阵2d", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the transformation be done using interpolation?")};
defARGINFO __arg_angle_ll [] = {defArg("第一条直线起始点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the first line."),defArg("第一条直线起始点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the first line."),defArg("第一条直线终点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the first line."),defArg("第一条直线终点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the first line."),defArg("第二条直线起始点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the second line."),defArg("第二条直线起始点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the second line."),defArg("第二条直线终止点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the second line."),defArg("第二条直线终止点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the second line."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the lines [rad].")};
defARGINFO __arg_angle_lx [] = {defArg("起始点行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate the first point of the line."),defArg("起始点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("终点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("终点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the line and the horizontal axis [rad].")};
defARGINFO __arg_anisotrope_diff [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "For histogram analysis; higher values increase the smoothing effect, typically: 80-90."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of diffusion function."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations, typical values: 3-7."),defArg("领域类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required neighborhood type.")};
defARGINFO __arg_anisotropic_diffusion [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Diffusion coefficient as a function of the edge amplitude."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Contrast parameter."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_append_channel [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("附加图像", dataTypeObj, 0, 0, "Image to be appended."),defArg("附加后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image appended by Image.")};
defARGINFO __arg_apply_color_trans_lut [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image (channel 2)."),defArg("图像2", dataTypeObj, 0, 0, "Input image (channel 2)."),defArg("图像3", dataTypeObj, 0, 0, "Input image (channel 3)."),defArg("结果图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 1)."),defArg("结果图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 2)."),defArg("图像结果3", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 3)."),defArg("颜色变换查找表句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the look-up-table for the color space transformation.")};
defARGINFO __arg_apply_distance_transform_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contour(s) for whose points the distances are calculated."),defArg("输出轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Copy of Contour containing the distances as an attribute."),defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform of the reference contour.")};
defARGINFO __arg_approx_chain [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of the contour."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of the contour."),defArg("最小宽度坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum width of Gauss operator for coordinate smoothing (> 0.4)."),defArg("最大宽度坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of Gauss operator for coordinate smoothing (> 0.4)."),defArg("起始阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum threshold value of the curvature for accepting a corner (relative to the largest curvature present)."),defArg("结束阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum threshold value of the curvature for accepting a corner (relative to the largest curvature present)."),defArg("阈值步长", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step width for threshold increase."),defArg("最小平滑宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum width of Gauss operator for smoothing the curvature function (> 0.4)."),defArg("最大平滑宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of Gauss operator for smoothing the curvature function."),defArg("最小曲线宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum width of curve area for curvature determination (> 0.4)."),defArg("最大曲线宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of curve area for curvature determination."),defArg("权重1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting factor for approximation precision."),defArg("权重2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting factor for large segments."),defArg("权重3", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting factor for small segments."),defArg("弧中心行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the center of an arc."),defArg("弧中心列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the center of an arc."),defArg("弧角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of an arc."),defArg("起始弧行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the starting point of an arc."),defArg("起始弧列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the starting point of an arc."),defArg("起始线行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the starting point of a line segment."),defArg("起始线列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the starting point of a line segment."),defArg("结束线行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the ending point of a line segment."),defArg("结束线列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the ending point of a line segment."),defArg("顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sequence of line (value 0) and arc segments (value 1).")};
defARGINFO __arg_approx_chain_simple [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of the contour."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of the contour."),defArg("弧中心行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the center of an arc."),defArg("弧中心列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the center of an arc."),defArg("弧角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of an arc."),defArg("弧起始行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the starting point of an arc."),defArg("弧起始列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the starting point of an arc."),defArg("线起始行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the starting point of a line segment."),defArg("线起始列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the starting point of a line segment."),defArg("线结束行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row of the ending point of a line segment."),defArg("线结束列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of the ending point of a line segment."),defArg("顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sequence of line (value 0) and arc segments (value 1).")};
defARGINFO __arg_area_center [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area of the region."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of the center."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center.")};
defARGINFO __arg_area_center_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value volume of the region."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the gray value center of gravity."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the gray value center of gravity.")};
defARGINFO __arg_area_center_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Point clouds to be examined in form of contours or polygons."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area of the point cloud."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the centroid."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the centroid.")};
defARGINFO __arg_area_center_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area enclosed by the contour or polygon."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the centroid."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the centroid."),defArg("点顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "point order along the boundary ('positive'/'negative').")};
defARGINFO __arg_area_holes [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("孔洞面积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area(s) of holes of the region(s).")};
defARGINFO __arg_asin_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("反正弦图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_atan2_image [] = {defArg("Y方向的图像", dataTypeObj, 0, 0, "Input image 1."),defArg("X方向的图像", dataTypeObj, 0, 0, "Input image 2."),defArg("反正切函数图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_atan_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("反正切函数图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_attach_background_to_window [] = {defArg("图像", dataTypeObj, 0, 0, "Background image."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window handle.")};
defARGINFO __arg_attach_drawing_object_to_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window handle."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object.")};
defARGINFO __arg_auto_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions with gray values within the automatically determined intervals."),defArg("标准差系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma for the Gaussian smoothing of the histogram.")};
defARGINFO __arg_axis_angle_to_quat [] = {defArg("X轴", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X component of the rotation axis."),defArg("Y轴", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y component of the rotation axis."),defArg("Z轴", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z component of the rotation axis."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle in radians."),defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation quaternion.")};
defARGINFO __arg_background_seg [] = {defArg("前景", dataTypeObj, 0, 0, "Input regions."),defArg("背景区", dataTypeObj, 0, AS_RECEIVE_VAR, "Connected components of the background.")};
defARGINFO __arg_bandpass_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("带通滤波图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Bandpass-filtered images."),defArg("滤波器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter type: currently only 'lines' is supported.")};
defARGINFO __arg_binary_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input Image."),defArg("分割的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented output region."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Segmentation method."),defArg("前景还是背景", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extract foreground or background?"),defArg("使用的阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Used threshold.")};
defARGINFO __arg_binomial_filter [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter width."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter height.")};
defARGINFO __arg_bin_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dark regions of the image.")};
defARGINFO __arg_bit_and [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image(s) 2."),defArg("图像位与", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by AND-operation.")};
defARGINFO __arg_bit_lshift [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("图像位左移", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by shift operation."),defArg("移位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shift value.")};
defARGINFO __arg_bit_mask [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("图像掩码", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by combination with mask."),defArg("位掩码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Bit field")};
defARGINFO __arg_bit_not [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("图像求补", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by complement operation.")};
defARGINFO __arg_bit_or [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image(s) 2."),defArg("图像位或", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by OR-operation.")};
defARGINFO __arg_bit_rshift [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("图像位右移", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by shift operation."),defArg("移位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "shift value")};
defARGINFO __arg_bit_slice [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("图像像素提取", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by extraction."),defArg("位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Bit to be selected.")};
defARGINFO __arg_bit_xor [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image(s) 2."),defArg("图像像素点异或", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by XOR-operation.")};
defARGINFO __arg_bottom_hat [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position independent)."),defArg("区域底部的帽子", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the bottom hat operator.")};
defARGINFO __arg_boundary [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the boundary is to be computed."),defArg("区域边界", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting boundaries."),defArg("边界类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Boundary type.")};
defARGINFO __arg_broadcast_condition [] = {defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Condition synchronization object.")};
defARGINFO __arg_caltab_points [] = {defArg("校准板描述", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the mark center points in the coordinate system of the calibration plate."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the mark center points in the coordinate system of the calibration plate."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the mark center points in the coordinate system of the calibration plate.")};
defARGINFO __arg_cam_par_pose_to_hom_mat3d [] = {defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose."),defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3projection matrix.")};
defARGINFO __arg_cfa_to_rgb [] = {defArg("CFA图像", dataTypeObj, 0, 0, "Input image."),defArg("RGB图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("CFA类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Color filter array type."),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation type.")};
defARGINFO __arg_change_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新域", dataTypeObj, 0, 0, "New definition domain."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with new definition domain.")};
defARGINFO __arg_change_format [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with new format."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of new image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of new image.")};
defARGINFO __arg_channels_to_image [] = {defArg("单通道图像", dataTypeObj, 0, 0, "One-channel images to be combined into a one-channel image."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_char_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("直方图区域", dataTypeObj, 0, 0, "Region in which the histogram is computed."),defArg("字符", dataTypeObj, 0, AS_RECEIVE_VAR, "Dark regions (characters)."),defArg("标准差系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma for the Gaussian smoothing of the histogram."),defArg("百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage for the gray value difference."),defArg("阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated threshold.")};
defARGINFO __arg_check_difference [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("模式", dataTypeObj, 0, 0, "Comparison image."),defArg("选择的", dataTypeObj, 0, AS_RECEIVE_VAR, "Points in which the two images are similar/different."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode: return similar or different pixels."),defArg("差值下界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower bound of the tolerated gray value difference."),defArg("差值上界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper bound of the tolerated gray value difference."),defArg("灰度偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Offset gray value subtracted from the input image."),defArg("添加行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate by which the comparison image is translated."),defArg("添加列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate by which the comparison image is translated.")};
defARGINFO __arg_check_par_hw_potential [] = {defArg("检查每一个参数？", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Check every input parameter?")};
defARGINFO __arg_circularity [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("圆度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Circularity of the input region(s).")};
defARGINFO __arg_circularity_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("圆", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Roundness of the input contours or polygons.")};
defARGINFO __arg_classify_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of best classes to determine."),defArg("样本ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the feature vector with the GMM."),defArg("后验概率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A-posteriori probability of the classes."),defArg("密度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Probability density of the feature vector."),defArg("K西格玛问题", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Normalized k-sigma-probability for the feature vector.")};
defARGINFO __arg_classify_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Features that should be classified."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The classification result, either class IDs or sample indices."),defArg("评价", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A rating for the results. This value contains either a distance, a frequency or a weighted frequency.")};
defARGINFO __arg_classify_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of best classes to determine."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the feature vector with the MLP."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence(s) of the class(es) of the feature vector.")};
defARGINFO __arg_classify_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of best classes to determine."),defArg("类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the feature vector with the SVM.")};
defARGINFO __arg_classify_image_class_gmm [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented classes."),defArg("高斯混合模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("拒绝分类阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the rejection of the classification.")};
defARGINFO __arg_classify_image_class_knn [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented classes."),defArg("距离图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Distance of the pixel's nearest neighbor."),defArg("最近邻分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("拒绝阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the rejection of the classification.")};
defARGINFO __arg_classify_image_class_lut [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented classes."),defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the LUT classifier.")};
defARGINFO __arg_classify_image_class_mlp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented classes."),defArg("多层感知机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("拒绝分类阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the rejection of the classification.")};
defARGINFO __arg_classify_image_class_svm [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented classes."),defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle.")};
defARGINFO __arg_class_2dim_sup [] = {defArg("第一通道", dataTypeObj, 0, 0, "Input image (first channel)."),defArg("第二通道", dataTypeObj, 0, 0, "Input image (second channel)."),defArg("特征空间", dataTypeObj, 0, 0, "Region defining the feature space."),defArg("区域类别", dataTypeObj, 0, AS_RECEIVE_VAR, "Classified regions.")};
defARGINFO __arg_class_2dim_unsup [] = {defArg("图像1", dataTypeObj, 0, 0, "First input image."),defArg("图像2", dataTypeObj, 0, 0, "Second input image."),defArg("类别结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Classification result."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold (maximum distance to the cluster's center)."),defArg("聚类中心", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes (cluster centers).")};
defARGINFO __arg_class_ndim_box [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multi channel input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Classification result."),defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier.")};
defARGINFO __arg_class_ndim_norm [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multi channel input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Classification result."),defArg("度量方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Metric to be used."),defArg("单一结果区域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Return one region or one region for each cluster."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Cluster radii or half edge lengths (returned by learn_ndim_norm)."),defArg("中心", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Coordinates of the cluster centers (returned by learn_ndim_norm).")};















defARGINFO __arg_clear_barrier [] = {defArg("障碍同步对象句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Barrier synchronization object.")};
defARGINFO __arg_clear_class_gmm [] = {defArg("高斯混合模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle.")};
defARGINFO __arg_clear_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier.")};
defARGINFO __arg_clear_class_lut [] = {defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the LUT classifier.")};
defARGINFO __arg_clear_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle.")};
defARGINFO __arg_clear_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle.")};
defARGINFO __arg_clear_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of training data for a classifier.")};
defARGINFO __arg_clear_color_trans_lut [] = {defArg("颜色变换查找表句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the look-up-table handle for the color space transformation.")};
defARGINFO __arg_clear_condition [] = {defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Condition synchronization object.")};
defARGINFO __arg_clear_distance_transform_xld [] = {defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform.")};
defARGINFO __arg_clear_drawing_object [] = {defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object.")};
defARGINFO __arg_clear_event [] = {defArg("事件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Event synchronization object.")};
defARGINFO __arg_clear_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle.")};
defARGINFO __arg_clear_message [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle(s) to be closed.")};
defARGINFO __arg_clear_message_queue [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message queue handle(s) to be closed.")};
defARGINFO __arg_clear_mutex [] = {defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object.")};
defARGINFO __arg_clear_obj [] = {defArg("对象", dataTypeObj, 0, 0, "Objects to be deleted.")};
defARGINFO __arg_clear_rectangle [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of upper left corner."),defArg("列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner."),defArg("行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of lower right corner."),defArg("列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of lower right corner.")};
defARGINFO __arg_clear_samples_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle.")};
defARGINFO __arg_clear_samples_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle.")};
defARGINFO __arg_clear_samples_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle.")};
defARGINFO __arg_clear_sampset [] = {defArg("样本的关键因素", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the data set.")};
defARGINFO __arg_clear_scattered_data_interpolator [] = {defArg("散乱数据插值句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the scattered data interpolator")};
defARGINFO __arg_clear_serial [] = {defArg("串行句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle."),defArg("通道", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Buffer to be cleared.")};
defARGINFO __arg_clear_serialized_item [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_clear_text_result [] = {defArg("文本结果ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text result to be cleared.")};
defARGINFO __arg_clear_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_clip_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be clipped."),defArg("截取轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Clipped contours."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the upper left corner of the clip rectangle."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the upper left corner of the clip rectangle."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the lower right corner of the clip rectangle."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the lower right corner of the clip rectangle.")};
defARGINFO __arg_clip_end_points_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour"),defArg("修剪后轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Clipped contour"),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping mode."),defArg("长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping length in unit pixels (Mode = 'length') or number (Mode = 'num_points')")};
defARGINFO __arg_clip_region [] = {defArg("输入区域", dataTypeObj, 0, 0, "Region to be clipped."),defArg("截取区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Clipped regions."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the upper left corner of the rectangle."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the upper left corner of the rectangle."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the lower right corner of the rectangle."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the lower right corner of the rectangle.")};
defARGINFO __arg_clip_region_rel [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be clipped."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Clipped regions."),defArg("顶部", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows clipped at the top."),defArg("底部", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows clipped at the bottom."),defArg("左边", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns clipped at the left."),defArg("右边", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns clipped at the right.")};
defARGINFO __arg_closest_point_transform [] = {defArg("区域", dataTypeObj, 0, 0, "Region for which the distance to the border is computed."),defArg("距离", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the distance information."),defArg("临近点", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the coordinates of the closest points."),defArg("度量类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of metric to be used for the closest-point transformation."),defArg("前景", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Compute the distance for pixels inside (true) or outside (false) the input region."),defArg("临近点的模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode in which the coordinates of the closest points are returned."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output images."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output images.")};






defARGINFO __arg_close_bg_esti [] = {defArg("处理估计数据集", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set.")};
defARGINFO __arg_close_class_box [] = {defArg("分类处理", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier.")};
defARGINFO __arg_close_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be closed."),defArg("闭合轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Closed contours.")};
defARGINFO __arg_close_edges [] = {defArg("边缘", dataTypeObj, 0, 0, "Region containing one pixel thick edges."),defArg("边缘图像", dataTypeObj, 0, 0, "Edge amplitude (gradient) image."),defArg("区域效果", dataTypeObj, 0, AS_RECEIVE_VAR, "Region containing closed edges."),defArg("最小振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude.")};
defARGINFO __arg_close_edges_length [] = {defArg("边缘", dataTypeObj, 0, 0, "Region containing one pixel thick edges."),defArg("梯度", dataTypeObj, 0, 0, "Edge amplitude (gradient) image."),defArg("封闭的边缘", dataTypeObj, 0, AS_RECEIVE_VAR, "Region containing closed edges."),defArg("最小振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("最大间隙长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal number of points by which edges are extended.")};
defARGINFO __arg_close_file [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle.")};
defARGINFO __arg_close_framegrabber [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the image acquisition device to be closed.")};
defARGINFO __arg_close_io_channel [] = {defArg("I / O通道手柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels.")};
defARGINFO __arg_close_io_device [] = {defArg("I / O设备手柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device.")};
defARGINFO __arg_close_serial [] = {defArg("串行句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle.")};
defARGINFO __arg_close_socket [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_close_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_closing [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be closed."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position-invariant)."),defArg("闭运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Closed regions.")};
defARGINFO __arg_closing_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be closed."),defArg("闭运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Closed regions."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circular structuring element.")};
defARGINFO __arg_closing_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be closed."),defArg("闭运算区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Closed regions."),defArg("Golay码元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("循环", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_closing_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be closed."),defArg("闭运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Closed regions."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the structuring rectangle."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the structuring rectangle.")};
defARGINFO __arg_coherence_enhancing_diff [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing for derivative operator."),defArg("扩散平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing for diffusion coefficients."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_combine_roads_xld [] = {defArg("边的多边形", dataTypeObj, 0, 0, "XLD polygons to be examined."),defArg("改良水平线", dataTypeObj, 0, 0, "Modified parallels obtained from EdgePolygons."),defArg("扩展水平线", dataTypeObj, 0, 0, "Extended parallels obtained from EdgePolygons."),defArg("中心线", dataTypeObj, 0, 0, "Road-center-line polygons to be examined."),defArg("道路两侧", dataTypeObj, 0, AS_RECEIVE_VAR, "Roadsides found."),defArg("最大角度平行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle between two parallel line segments."),defArg("最大角度共线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle between two collinear line segments."),defArg("最大距离平行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between two parallel line segments."),defArg("最大距离共线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between two collinear line segments.")};
defARGINFO __arg_compactness [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("紧凑性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Compactness of the input region(s).")};
defARGINFO __arg_compactness_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("致密度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Compactness of the input contours or polygons.")};
defARGINFO __arg_compare_obj [] = {defArg("对象1", dataTypeObj, 0, 0, "Reference objects."),defArg("对象2", dataTypeObj, 0, 0, "Test objects."),defArg("最大灰度差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum allowed difference between two gray values or coordinates etc."),defArg("是否相等", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Boolean result value.")};
defARGINFO __arg_complement [] = {defArg("区域", dataTypeObj, 0, 0, "Input region(s)."),defArg("区域补集", dataTypeObj, 0, AS_RECEIVE_VAR, "Complemented regions.")};
defARGINFO __arg_complex_to_real [] = {defArg("复杂图像", dataTypeObj, 0, 0, "Complex image."),defArg("实数部分", dataTypeObj, 0, AS_RECEIVE_VAR, "Real part."),defArg("虚数部分", dataTypeObj, 0, AS_RECEIVE_VAR, "Imaginary part.")};
defARGINFO __arg_compose2 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose3 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("图像3", dataTypeObj, 0, 0, "Input image 3."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose4 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("图像3", dataTypeObj, 0, 0, "Input image 3."),defArg("图像4", dataTypeObj, 0, 0, "Input image 4."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose5 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("图像3", dataTypeObj, 0, 0, "Input image 3."),defArg("图像4", dataTypeObj, 0, 0, "Input image 4."),defArg("图像5", dataTypeObj, 0, 0, "Input image 5."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose6 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("图像3", dataTypeObj, 0, 0, "Input image 3."),defArg("图像4", dataTypeObj, 0, 0, "Input image 4."),defArg("图像5", dataTypeObj, 0, 0, "Input image 5."),defArg("图像6", dataTypeObj, 0, 0, "Input image 6."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose7 [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("图像3", dataTypeObj, 0, 0, "Input image 3."),defArg("图像4", dataTypeObj, 0, 0, "Input image 4."),defArg("图像5", dataTypeObj, 0, 0, "Input image 5."),defArg("图像6", dataTypeObj, 0, 0, "Input image 6."),defArg("图像7", dataTypeObj, 0, 0, "Input image 7."),defArg("多通道图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel image.")};
defARGINFO __arg_compose_funct_1d [] = {defArg("函数1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function 1."),defArg("函数2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function 2."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment for the input functions."),defArg("组成函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Composed function.")};
defARGINFO __arg_concat_obj [] = {defArg("元组1", dataTypeObj, 0, 0, "Object tuple 1."),defArg("元组2", dataTypeObj, 0, 0, "Object tuple 2."),defArg("合并元组", dataTypeObj, 0, AS_RECEIVE_VAR, "Concatenated objects.")};
defARGINFO __arg_connection [] = {defArg("区域", dataTypeObj, 0, 0, "Input region."),defArg("连通区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Connected components.")};
defARGINFO __arg_connect_and_holes [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("连接组件数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of connection components of a region."),defArg("孔洞数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of holes of a region.")};
defARGINFO __arg_contlength [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("轮廓长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Contour length of the input region(s).")};
defARGINFO __arg_contour_point_num_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contour."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of contour points.")};
defARGINFO __arg_control_io_channel [] = {defArg("输入输出通道句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels."),defArg("参数动作", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the action to perform."),defArg("参数列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of arguments for the action."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of values returned by the action.")};
defARGINFO __arg_control_io_device [] = {defArg("输入输出设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device."),defArg("动作", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the action to perform."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of arguments for the action."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of result values returned by the action.")};
defARGINFO __arg_control_io_interface [] = {defArg("IO接口名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "HALCON I/O interface name."),defArg("动作", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the action to perform."),defArg("参数列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of arguments for the action."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of results returned by the action.")};
defARGINFO __arg_convert_image_type [] = {defArg("图像", dataTypeObj, 0, 0, "Image whose image type is to be changed."),defArg("转换后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Converted image."),defArg("新类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired image type (i.e., type of the gray values).")};
defARGINFO __arg_convert_map_type [] = {defArg("映射图", dataTypeObj, 0, 0, "Input map."),defArg("地图转换", dataTypeObj, 0, AS_RECEIVE_VAR, "Converted map."),defArg("新型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of MapConverted."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of images to be mapped.")};
defARGINFO __arg_convert_pose_type [] = {defArg("输入姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Original 3D pose."),defArg("变换顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of rotation and translation."),defArg("旋转顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Meaning of the rotation values."),defArg("视图变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "View of transformation."),defArg("输出姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D transformation.")};
defARGINFO __arg_convexity [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("凸包", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Convexity of the input region(s).")};
defARGINFO __arg_convexity_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("凸性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Convexity of the input contours or polygons.")};
defARGINFO __arg_convol_fft [] = {defArg("傅立叶图像", dataTypeObj, 0, 0, "Complex input image."),defArg("滤波图像", dataTypeObj, 0, 0, "Filter in frequency domain."),defArg("卷积图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of applying the filter.")};
defARGINFO __arg_convol_gabor [] = {defArg("傅立叶图像", dataTypeObj, 0, 0, "Input image."),defArg("Gabor滤波器", dataTypeObj, 0, 0, "Gabor/Hilbert-Filter."),defArg("结果Gabor图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the Gabor filter."),defArg("结果希尔伯特图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the Hilbert filter.")};
defARGINFO __arg_convol_image [] = {defArg("图像", dataTypeObj, 0, 0, "Images for which the correlation will be calculated."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the correlation."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter mask as file name or tuple."),defArg("边界处理方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_cooc_feature_image [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be examined."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray values."),defArg("灰度数目", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of gray values to be distinguished (2^LdGray)."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Direction in which the matrix is to be calculated."),defArg("能量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value energy."),defArg("相关关系", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Correlation of gray values."),defArg("相同灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Local homogeneity of gray values."),defArg("灰度差异", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value contrast.")};
defARGINFO __arg_cooc_feature_matrix [] = {defArg("共性矩阵", dataTypeObj, 0, 0, "Co-occurrence matrix."),defArg("能量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneity of the gray values."),defArg("相互关系", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Correlation of gray values."),defArg("相同灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Local homogeneity of gray values."),defArg("灰度值差异", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value contrast.")};
defARGINFO __arg_copy_file [] = {defArg("源文件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File to be copied."),defArg("目标文件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Target location.")};
defARGINFO __arg_copy_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be copied."),defArg("复制图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Copied image.")};
defARGINFO __arg_copy_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle of the copied matrix.")};
defARGINFO __arg_copy_obj [] = {defArg("对象", dataTypeObj, 0, 0, "Objects to be copied."),defArg("复制对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Copied objects."),defArg("起始索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Starting index of the objects to be copied."),defArg("复制数量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of objects to be copied or -1.")};
defARGINFO __arg_copy_rectangle [] = {defArg("源窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the source window."),defArg("目标窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the destination window."),defArg("行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner in the source window."),defArg("列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner in the source window."),defArg("行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of lower right corner in the source window."),defArg("列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of lower right corner in the source window."),defArg("行距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner in the target window."),defArg("列距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner in the target window.")};
defARGINFO __arg_corner_response [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("角点图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the filtering."),defArg("大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired filtersize of the graymask."),defArg("权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting.")};
defARGINFO __arg_correlation_fft [] = {defArg("傅立叶图像1", dataTypeObj, 0, 0, "Fourier-transformed input image 1."),defArg("傅立叶图像2", dataTypeObj, 0, 0, "Fourier-transformed input image 2."),defArg("图像相关", dataTypeObj, 0, AS_RECEIVE_VAR, "Correlation of the input images in the frequency domain.")};
defARGINFO __arg_cos_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("余弦图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_count_channels [] = {defArg("多通道图像", dataTypeObj, 0, 0, "One- or multichannel image."),defArg("输出通道数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of channels.")};
defARGINFO __arg_count_obj [] = {defArg("对象元组", dataTypeObj, 0, 0, "Objects to be examined."),defArg("数量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of objects in the tuple Objects.")};
defARGINFO __arg_count_relation [] = {defArg("关系名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Relation of interest of the HALCON database."),defArg("元组数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of tuples in the relation.")};
defARGINFO __arg_count_seconds [] = {defArg("秒", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Processtime since the program start.")};
defARGINFO __arg_create_barrier [] = {defArg("属性名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Barrier attribute."),defArg("属性值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Barrier attribute value."),defArg("团队尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Barrier team size."),defArg("障碍句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Barrier synchronization object.")};
defARGINFO __arg_create_bg_esti [] = {defArg("初始化图像", dataTypeObj, 0, 0, "initialization image."),defArg("系统矩阵参数1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "1. system matrix parameter."),defArg("系统矩阵参数2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "2. system matrix parameter."),defArg("增益模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gain type."),defArg("增益1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kalman gain / foreground adaptation time."),defArg("增益2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kalman gain / background adaptation time."),defArg("适应模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold adaptation."),defArg("最小差异", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Foreground/background threshold."),defArg("数据集数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of statistic data sets."),defArg("置信度C", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Confidence constant."),defArg("衰减时间C", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Constant for decay time."),defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the BgEsti data set.")};
defARGINFO __arg_create_caltab [] = {defArg("行数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows."),defArg("每行的标志", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of marks per row."),defArg("直径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Diameter of the marks."),defArg("行扫描", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row indices of the finder patterns."),defArg("列扫描", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column indices of the finder patterns."),defArg("极性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Polarity of the marks"),defArg("标准板的描述", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("标准板的脚本文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the PostScript file.")};
defARGINFO __arg_create_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the classifier.")};
defARGINFO __arg_create_class_gmm [] = {defArg("维数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of dimensions of the feature space."),defArg("类别数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes of the GMM."),defArg("中心数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of centers per class."),defArg("协方差类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the covariance matrices."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization')."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed value of the random number generator that is used to initialize the GMM with random values."),defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "GMM handle.")};
defARGINFO __arg_create_class_knn [] = {defArg("维数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of dimensions of the feature."),defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the k-NN classifier.")};
defARGINFO __arg_create_class_lut_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the LUT classifier.")};
defARGINFO __arg_create_class_lut_knn [] = {defArg("k最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the LUT classifier.")};
defARGINFO __arg_create_class_lut_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the LUT classifier.")};
defARGINFO __arg_create_class_lut_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the LUT classifier creation."),defArg("类别查找表句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the LUT classifier.")};
defARGINFO __arg_create_class_mlp [] = {defArg("输入层个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of input variables (features) of the MLP."),defArg("隐层个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of hidden units of the MLP."),defArg("输出层个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of output variables (classes) of the MLP."),defArg("输出函数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the activation function in the output layer of the MLP."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization')."),defArg("随机种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed value of the random number generator that is used to initialize the MLP with random values."),defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "MLP handle.")};
defARGINFO __arg_create_class_svm [] = {defArg("特征数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of input variables (features) of the SVM."),defArg("核类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The kernel type."),defArg("核参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Additional parameter for the kernel function. In case of RBF kernel the value for gamma. For polynomial kernel the degree"),defArg("正则化常量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regularisation constant of the SVM."),defArg("类别数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The mode of the SVM."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization')."),defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "SVM handle.")};
defARGINFO __arg_create_class_train_data [] = {defArg("维数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of dimensions of the feature vector."),defArg("训练数据分类句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data.")};
defARGINFO __arg_create_color_trans_lut [] = {defArg("色空间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Color space of the output image."),defArg("反方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Direction of color space transformation."),defArg("位数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of bits of the input image."),defArg("颜色变换查找表句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the look-up-table for color space transformation.")};
defARGINFO __arg_create_condition [] = {defArg("属性名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute."),defArg("属性值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute value."),defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Condition synchronization object.")};
defARGINFO __arg_create_distance_transform_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Reference contour(s)."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Compute the distance to points ('point_to_point') or entire segments ('point_to_segment')."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of interest."),defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the XLD distance transform.")};
defARGINFO __arg_create_drawing_object_circle [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_circle_sector [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start angle of the arc."),defArg("结束角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End angle of the arc."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_ellipse [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the first half axis in radians."),defArg("半径1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First half axis."),defArg("半径2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second half axis."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_ellipse_sector [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the first half axis in radians."),defArg("半径1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First half axis."),defArg("半径2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second half axis."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start angle of the arc."),defArg("结束角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End angle of the arc."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_line [] = {defArg("行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the first line point."),defArg("列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the first line point."),defArg("行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the second line point."),defArg("列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the second line point."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_rectangle1 [] = {defArg("行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the upper left corner."),defArg("列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the upper left corner."),defArg("行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the lower right corner."),defArg("列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the lower right corner."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_rectangle2 [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the first half axis in radians."),defArg("长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First half axis."),defArg("长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second half axis."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_text [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the text position."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the text position."),defArg("字符串", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Character string to be displayed."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_drawing_object_xld [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the polygon."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the polygon."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the drawing object.")};
defARGINFO __arg_create_event [] = {defArg("属性名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute."),defArg("属性值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute value."),defArg("事件句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Event synchronization object.")};
defARGINFO __arg_create_funct_1d_array [] = {defArg("y值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X value for function points."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Created function.")};
defARGINFO __arg_create_funct_1d_pairs [] = {defArg("x值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X value for function points."),defArg("y值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y-value for function points."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Created function.")};
defARGINFO __arg_create_matrix [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows of the matrix."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns of the matrix."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values for initializing the elements of the matrix."),defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle.")};
defARGINFO __arg_create_message [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the newly created message.")};
defARGINFO __arg_create_message_queue [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the newly created message queue.")};
defARGINFO __arg_create_mutex [] = {defArg("属性名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute class."),defArg("属性值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mutex attribute kind."),defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mutex synchronization object.")};
defARGINFO __arg_create_pose [] = {defArg("沿X变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the x-axis (in [m])."),defArg("沿Y变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the y-axis (in [m])."),defArg("沿Z变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the z-axis (in [m])."),defArg("沿X的旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation around x-axis or x component of the Rodriguez vector (in [] or without unit)."),defArg("沿Y的旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation around y-axis or y component of the Rodriguez vector (in [] or without unit)."),defArg("沿Z的旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation around z-axis or z component of the Rodriguez vector (in [] or without unit)."),defArg("变换顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of rotation and translation."),defArg("旋转顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Meaning of the rotation values."),defArg("变换视图", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "View of transformation."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose.")};
defARGINFO __arg_create_rectification_grid [] = {defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the checkered pattern in meters (without the two frames)."),defArg("网格行列数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of squares per row and column."),defArg("网格文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the PostScript file.")};
defARGINFO __arg_create_scattered_data_interpolator [] = {defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the interpolation"),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the points used for the interpolation"),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the points used for the interpolation"),defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the points used for the interpolation"),defArg("产生的参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted"),defArg("句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the scattered data interpolator")};
defARGINFO __arg_create_serialized_item_ptr [] = {defArg("指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Data pointer of the serialized item."),defArg("大小", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Size of the serialized item."),defArg("复制", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Copy mode of the serialized item."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_critical_points_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the calculation of the partial derivatives."),defArg("西格玛", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum absolute value of the eigenvalues of the Hessian matrix."),defArg("最小行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected minima."),defArg("最小列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected minima."),defArg("最大行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected maxima."),defArg("最大列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected maxima."),defArg("鞍点行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected saddle points."),defArg("鞍点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected saddle points.")};
defARGINFO __arg_crop_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("裁剪后的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contours."),defArg("裁剪区域行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper border of the cropping rectangle."),defArg("裁剪区域列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Left border of the cropping rectangle."),defArg("裁剪区域行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower border of the cropping rectangle."),defArg("裁剪区域列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Right border of the cropping rectangle."),defArg("是否闭合轮廓", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should closed contours produce closed output contours?")};
defARGINFO __arg_crop_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image area.")};
defARGINFO __arg_crop_domain_rel [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image area."),defArg("顶边线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows clipped at the top."),defArg("左边线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns clipped at the left."),defArg("底边线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows clipped at the bottom."),defArg("右边线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns clipped at the right.")};
defARGINFO __arg_crop_part [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("截取图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image area."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of upper left corner of image area."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner of image area."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of new image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of new image.")};
defARGINFO __arg_crop_rectangle1 [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("截取图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image area."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of upper left corner of image area."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner of image area."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of lower right corner of image area."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of lower right corner of image area.")};

defARGINFO __arg_deactivate_compute_device [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle.")};
defARGINFO __arg_decompose2 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2.")};
defARGINFO __arg_decompose3 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2."),defArg("图像3", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 3.")};
defARGINFO __arg_decompose4 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2."),defArg("图像3", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 3."),defArg("图像4", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 4.")};
defARGINFO __arg_decompose5 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2."),defArg("图像3", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 3."),defArg("图像4", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 4."),defArg("图像5", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 5.")};
defARGINFO __arg_decompose6 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2."),defArg("图像3", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 3."),defArg("图像4", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 4."),defArg("图像5", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 5."),defArg("图像6", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 6.")};
defARGINFO __arg_decompose7 [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image."),defArg("图像1", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 1."),defArg("图像2", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 2."),defArg("图像3", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 3."),defArg("图像4", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 4."),defArg("图像5", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 5."),defArg("图像6", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 6."),defArg("图像7", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image 7.")};
defARGINFO __arg_decompose_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the input matrix."),defArg("矩阵1ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the output matrix 1."),defArg("矩阵2ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the output matrix 2.")};
defARGINFO __arg_delete_file [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File to be deleted.")};
defARGINFO __arg_dequeue_message [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message queue handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional generic parameters"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional generic parameters"),defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle(s) of the dequeued message(s).")};
defARGINFO __arg_derivate_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function"),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of derivative"),defArg("导数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Derivative of the input function")};
defARGINFO __arg_derivate_gauss [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered result images."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian."),defArg("成分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Derivative or feature to be calculated.")};
defARGINFO __arg_derivate_vector_field [] = {defArg("向量场", dataTypeObj, 0, 0, "Input vector field."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered result images."),defArg("高斯差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian."),defArg("组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Component to be calculated.")};
defARGINFO __arg_descript_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Highest dimension for output."),defArg("类别索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the classes."),defArg("箱编号", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the boxes."),defArg("下线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lower bounds of the boxes (for each dimension)."),defArg("上线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Higher bounds of the boxes (for each dimension)."),defArg("训练样本的个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of training samples that were used to define this box (for each dimension)."),defArg("训练样本的错误率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of training samples that were assigned incorrectly to the box.")};
defARGINFO __arg_deserialize_cam_par [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters.")};
defARGINFO __arg_deserialize_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_deserialize_class_gmm [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "GMM handle.")};
defARGINFO __arg_deserialize_class_knn [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the k-NN classifier.")};
defARGINFO __arg_deserialize_class_mlp [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "MLP handle.")};
defARGINFO __arg_deserialize_class_svm [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "SVM handle.")};
defARGINFO __arg_deserialize_class_train_data [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data.")};
defARGINFO __arg_deserialize_distance_transform_xld [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized XLD distance transform."),defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the deserialized XLD distance transform.")};
defARGINFO __arg_deserialize_fft_optimization_data [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_deserialize_hom_mat2d [] = {defArg("序列化句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("2d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix.")};
defARGINFO __arg_deserialize_hom_mat3d [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("3d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix.")};
defARGINFO __arg_deserialize_image [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_deserialize_matrix [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle.")};
defARGINFO __arg_deserialize_object [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Iconic object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_deserialize_pose [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose.")};
defARGINFO __arg_deserialize_quat [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Quaternion.")};
defARGINFO __arg_deserialize_region [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_deserialize_tuple [] = {defArg("处理序列化的项目", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("元组。", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple.")};
defARGINFO __arg_deserialize_xld [] = {defArg("XLD", dataTypeObj, 0, AS_RECEIVE_VAR, "XLD object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_detach_background_from_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window handle.")};
defARGINFO __arg_detach_drawing_object_from_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window Handle."),defArg("绘图对象句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object.")};
defARGINFO __arg_detect_edge_segments [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("Sobel模板尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mask size of the Sobel operator."),defArg("最小振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge strength."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the approximating line to its original edge."),defArg("最小长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum length of to resulting line segments."),defArg("起始点的行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the line segments' start points."),defArg("起始点的列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the line segments' start points."),defArg("端点的行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the line segments' end points."),defArg("端点的列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the line segments' end points.")};
defARGINFO __arg_determinant_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix."),defArg("行列式值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Determinant of the input matrix.")};
defARGINFO __arg_deviation_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the standard deviation is to be calculated."),defArg("图像偏差", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the standard deviation."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the mask in which the standard deviation is calculated."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the mask in which the standard deviation is calculated.")};
defARGINFO __arg_deviation_n [] = {defArg("图像", dataTypeObj, 0, 0, "Multichannel gray image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of calculation.")};
defARGINFO __arg_diameter_region [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the first extreme point."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the first extreme point."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the second extreme point."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the second extreme point."),defArg("直径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the two extreme points.")};
defARGINFO __arg_diameter_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the first extreme point of the contours or polygons."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the first extreme point of the contours or polygons."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the second extreme point of the contour or polygons."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the second extreme point of the contours or polygons."),defArg("直径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the two extreme points of the contours or polygons.")};
defARGINFO __arg_difference [] = {defArg("原始区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("子区域", dataTypeObj, 0, 0, "The union of these regions is subtracted from Region."),defArg("差集区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting region.")};
defARGINFO __arg_difference_closed_contours_xld [] = {defArg("原始轮廓", dataTypeObj, 0, 0, "Contours enclosing the region from which the second region is subtracted."),defArg("子轮廓", dataTypeObj, 0, 0, "Contours enclosing the region that is subtracted from the first region."),defArg("轮廓差集", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours enclosing the difference.")};
defARGINFO __arg_difference_closed_polygons_xld [] = {defArg("原始多边形", dataTypeObj, 0, 0, "Polygons enclosing the region from which the second region is subtracted."),defArg("子多边形", dataTypeObj, 0, 0, "Polyongs enclosing the region that is subtracted from the first region."),defArg("多边形差集", dataTypeObj, 0, AS_RECEIVE_VAR, "Polygons enclosing the difference.")};
defARGINFO __arg_diff_of_gauss [] = {defArg("图像", dataTypeObj, 0, 0, "Input image"),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "LoG image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing parameter of the Laplace operator to approximate."),defArg("标准偏差因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Ratio of the standard deviations used (Marr recommends 1.6).")};
defARGINFO __arg_dilation1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("膨胀区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_dilation2 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("膨胀后的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_dilation_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("膨胀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circular structuring element.")};
defARGINFO __arg_dilation_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("膨胀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("Golay码元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("循环", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_dilation_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("膨胀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the structuring rectangle."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the structuring rectangle.")};
defARGINFO __arg_dilation_seq [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("膨胀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("Golay码元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_disp_arc [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of center point."),defArg("中心列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of center point."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between start and end of the arc (in radians)."),defArg("起始行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the start of the arc."),defArg("起始列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the start of the arc.")};
defARGINFO __arg_disp_arrow [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("起点行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the start."),defArg("起点列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the start."),defArg("终点的行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the end."),defArg("终点的列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the end."),defArg("尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the arrowhead.")};
defARGINFO __arg_disp_caltab [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window in which the calibration plate should be visualized."),defArg("校准板的描述", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("校准板的姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "External camera parameters (3D pose of the calibration plate in camera coordinates)."),defArg("缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scaling factor for the visualization.")};
defARGINFO __arg_disp_channel [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel images to be displayed."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("通道", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of channel or the numbers of the RGB-channels")};
defARGINFO __arg_disp_circle [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle.")};
defARGINFO __arg_disp_color [] = {defArg("彩色图像", dataTypeObj, 0, 0, "Color image to display."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_disp_cross [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center."),defArg("大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the bars."),defArg("夹角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation.")};
defARGINFO __arg_disp_distribution [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("分布", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Gray value distribution (513 values)."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("规模", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of display.")};
defARGINFO __arg_disp_ellipse [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of center."),defArg("中心列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the ellipse in radians"),defArg("长轴半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of major axis."),defArg("短轴半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of minor axis.")};
defARGINFO __arg_disp_image [] = {defArg("图像", dataTypeObj, 0, 0, "Gray value image to display."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_disp_line [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("起点的行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the start."),defArg("起点的列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the start."),defArg("终点的行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of end."),defArg("终点的列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of end.")};
defARGINFO __arg_disp_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of centre of the graphic."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of centre of the graphic."),defArg("规模", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scaling of the graphic.")};
defARGINFO __arg_disp_obj [] = {defArg("图像对象", dataTypeObj, 0, 0, "Image object to be displayed."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_disp_polygon [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index"),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index")};
defARGINFO __arg_disp_rectangle1 [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("左上角的行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the upper left corner."),defArg("左上角的列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the upper left corner."),defArg("右下角行坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the lower right corner."),defArg("右下角的列坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the lower right corner.")};
defARGINFO __arg_disp_rectangle2 [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("中心列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of rectangle in radians."),defArg("长的一半", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half of the length of the longer side."),defArg("宽的一半", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half of the length of the shorter side.")};
defARGINFO __arg_disp_region [] = {defArg("显示区域", dataTypeObj, 0, 0, "Regions to display."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_disp_xld [] = {defArg("xld对象", dataTypeObj, 0, 0, "XLD object to display."),defArg("窗口ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window id.")};
defARGINFO __arg_distance_cc [] = {defArg("轮廓1", dataTypeObj, 0, 0, "First input contour."),defArg("轮廓2", dataTypeObj, 0, 0, "Second input contour."),defArg("方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance calculation mode."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between both contours."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between both contours.")};
defARGINFO __arg_distance_cc_min [] = {defArg("轮廓1", dataTypeObj, 0, 0, "First input contour."),defArg("轮廓2", dataTypeObj, 0, 0, "Second input contour."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance calculation mode."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the two contours.")};
defARGINFO __arg_distance_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours for whose points the distances are calculated."),defArg("轮廓", dataTypeObj, 0, 0, "Contours to which the distances are calculated to."),defArg("轮廓出来", dataTypeObj, 0, AS_RECEIVE_VAR, "Copy of ContourFrom containing the distances as an attribute."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Compute the distance to points ('point_to_point') or to entire segments ('point_to_segment').")};
defARGINFO __arg_distance_funct_1d [] = {defArg("函数1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function 1."),defArg("函数2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function 2."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Modes of invariants."),defArg("高斯平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Variance of the optional smoothing with a Gaussian filter."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the functions.")};
defARGINFO __arg_distance_lc [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line and the contour."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line and the contour.")};
defARGINFO __arg_distance_lr [] = {defArg("区域", dataTypeObj, 0, 0, "Input region."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line and the region"),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line and the region")};
defARGINFO __arg_distance_pc [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the point."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the point and the contour."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the point and the contour.")};
defARGINFO __arg_distance_pl [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column of the point."),defArg("起点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("起点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("终点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("终点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between the points.")};
defARGINFO __arg_distance_pp [] = {defArg("起始点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point."),defArg("起始点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point."),defArg("第二个点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point."),defArg("第二个点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between the points.")};
defARGINFO __arg_distance_pr [] = {defArg("区域", dataTypeObj, 0, 0, "Input region."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the point."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the point and the region."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the point and the region.")};
defARGINFO __arg_distance_ps [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line segment."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line segment."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line segment."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line segment."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the point and the line segment."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the point and the line segment.")};
defARGINFO __arg_distance_rr_min [] = {defArg("区域1", dataTypeObj, 0, 0, "Regions to be examined."),defArg("区域2", dataTypeObj, 0, 0, "Regions to be examined."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between contours of the regions."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index on contour in Regions1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index on contour in Regions1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index on contour in Regions2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index on contour in Regions2.")};
defARGINFO __arg_distance_rr_min_dil [] = {defArg("区域1", dataTypeObj, 0, 0, "Regions to be examined."),defArg("区域2", dataTypeObj, 0, 0, "Regions to be examined."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distances of the regions.")};
defARGINFO __arg_distance_sc [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line segment."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line segment."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line segment."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line segment."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line segment and the contour."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line segment and the contour.")};
defARGINFO __arg_distance_sl [] = {defArg("分割线的第一点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line segment."),defArg("分割线的第一点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line segment."),defArg("分割线的第二点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line segment."),defArg("分割线的第二点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line segment."),defArg("直线的第一点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("直线的第一点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("直线的第二点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("直线的第二点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line segment and the line."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line segment and the line.")};
defARGINFO __arg_distance_sr [] = {defArg("区域", dataTypeObj, 0, 0, "Input region."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line segment."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line segment."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line segment."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line segment."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line segment and the region."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line segment and the region.")};
defARGINFO __arg_distance_ss [] = {defArg("行A1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line segment."),defArg("分割线的第一点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line segment."),defArg("分割线的第一点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line segment."),defArg("分割线的第二点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line segment."),defArg("分割线的第二点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("分割线的第一点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column of the first point of the line."),defArg("分割线的第一点的列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("分割线的第二点的行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("分割线的第二点的列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance between the line segments."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance between the line segments.")};
defARGINFO __arg_distance_transform [] = {defArg("区域", dataTypeObj, 0, 0, "Region for which the distance to the border is computed."),defArg("图像距离", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the distance information."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of metric to be used for the distance transformation."),defArg("前景", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Compute the distance for pixels inside (true) or outside (false) the input region."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output image.")};
defARGINFO __arg_dist_ellipse_contour_points_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("距离模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode for unsigned or signed distance values."),defArg("夹点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and the end of the contours to be ignored for the computation of distances."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the ellipse."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the ellipse."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis in radian."),defArg("半径1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half axis."),defArg("半径2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half axis."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distances of the contour points to the ellipse.")};
defARGINFO __arg_dist_ellipse_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the determination of the distances."),defArg("最大点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of contour points used for the computation (-1 for all points)."),defArg("夹点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and the end of the contours to be ignored for the computation of distances."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the ellipse."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the ellipse."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis in radian."),defArg("半径1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half axis."),defArg("半径2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half axis."),defArg("最小距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum distance."),defArg("最大距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum distance."),defArg("平均距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean distance."),defArg("标准差距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Standard deviation of the distance.")};
defARGINFO __arg_dist_rectangle2_contour_points_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("被忽视的端点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and the end of the contours to be ignored for the computation of distances."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the rectangle."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the rectangle."),defArg("phi", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis of the rectangle [rad]."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "First radius (half length) of the rectangle."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Second radius (half width) of the rectangle."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distances of the contour points to the rectangle.")};
defARGINFO __arg_div_element_matrix [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the divided values of input matrices.")};
defARGINFO __arg_div_element_matrix_mod [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B.")};
defARGINFO __arg_div_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Image(s) 2."),defArg("结果图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the division."),defArg("乘数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for gray range adaption."),defArg("加数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value for gray range adaption.")};
defARGINFO __arg_dots_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("点图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("直径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Diameter of the dots to be enhanced."),defArg("过滤器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enhance dark, light, or all dots."),defArg("像素位移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shift of the filter response.")};
defARGINFO __arg_drag_region1 [] = {defArg("源区域", dataTypeObj, 0, 0, "Regions to move."),defArg("目的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Moved Regions."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_drag_region2 [] = {defArg("源区域", dataTypeObj, 0, 0, "Regions to move."),defArg("目的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Moved regions."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the reference point.")};
defARGINFO __arg_drag_region3 [] = {defArg("源区域", dataTypeObj, 0, 0, "Regions to move."),defArg("掩码区域", dataTypeObj, 0, 0, "Points on which it is allowed for a region to move."),defArg("目的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Moved regions."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the reference point.")};
defARGINFO __arg_draw_circle [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Barycenter's row index."),defArg("圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Barycenter's column index."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Circle's radius.")};
defARGINFO __arg_draw_circle_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("圆心Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("圆心X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle."),defArg("新圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the center."),defArg("新圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("新半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Circle's radius.")};
defARGINFO __arg_draw_ellipse [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the center."),defArg("圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("长半轴角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the first half axis in radians."),defArg("长轴半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First half axis."),defArg("短轴半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second half axis.")};
defARGINFO __arg_draw_ellipse_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("长半轴角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the bigger half axis in radians."),defArg("长轴半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Bigger half axis."),defArg("短轴半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Smaller half axis."),defArg("新圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the center."),defArg("新圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("新长轴角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the first half axis in radians."),defArg("新长轴半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First half axis."),defArg("新短轴半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second half axis.")};
defARGINFO __arg_draw_line [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("起点Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the first point of the line."),defArg("起点X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the first point of the line."),defArg("终点Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the second point of the line."),defArg("终点X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the second point of the line.")};
defARGINFO __arg_draw_line_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("起点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the first point of the line."),defArg("起点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the first point of the line."),defArg("终点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the second point of the line."),defArg("终点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the second point of the line."),defArg("新起点Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the first point of the line."),defArg("新起点X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the first point of the line."),defArg("新终点Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the second point of the line."),defArg("新终点X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the second point of the line.")};
defARGINFO __arg_draw_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_draw_nurbs [] = {defArg("逼近轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour approximating the NURBS curve."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?"),defArg("曲线阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The degree p of the NURBS curve. Reasonable values are 3 to 25."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the control polygon."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Columns coordinates of the control polygon."),defArg("权重", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Weight vector.")};
defARGINFO __arg_draw_nurbs_interp [] = {defArg("曲线轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour of the curve."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?"),defArg("曲线阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The degree p of the NURBS curve. Reasonable values are 3 to 5."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the control polygon."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the control polygon."),defArg("节点向量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Knot vector."),defArg("指定Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the points specified by the user."),defArg("指定X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the points specified by the user."),defArg("切线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tangents specified by the user.")};
defARGINFO __arg_draw_nurbs_interp_mod [] = {defArg("曲线轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour of the modified curve."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?"),defArg("是否编辑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable editing?"),defArg("曲线阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The degree p of the NURBS curve. Reasonable values are 3 to 5."),defArg("差值Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the input interpolation points."),defArg("差值X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the input interpolation points."),defArg("切线", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tangents."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the control polygon."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the control polygon."),defArg("节点向量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Knot vector."),defArg("指定X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the points specified by the user."),defArg("指定Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the points specified by the user."),defArg("切线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tangents specified by the user.")};
defARGINFO __arg_draw_nurbs_mod [] = {defArg("曲线轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour of the modified curve."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?"),defArg("是否编辑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable editing?"),defArg("曲线阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The degree p of the NURBS curve. Reasonable values are 3 to 25."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the input control polygon."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the input control polygon."),defArg("权重", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input weight vector."),defArg("新坐标Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the control polygon."),defArg("新坐标X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Columns coordinates of the control polygon."),defArg("权重", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Weight vector.")};
defARGINFO __arg_draw_point [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the point."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the point.")};
defARGINFO __arg_draw_point_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("输入Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the point."),defArg("输入X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the point."),defArg("输出Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the point."),defArg("输出X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the point.")};
defARGINFO __arg_draw_polygon [] = {defArg("多边形区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region, which encompasses all painted points."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_draw_rectangle1 [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("左上角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the left upper corner."),defArg("左上角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the left upper corner."),defArg("右下角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the right lower corner."),defArg("右下角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the right lower corner.")};
defARGINFO __arg_draw_rectangle1_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("左上角Y_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the left upper corner."),defArg("左上角X_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the left upper corner."),defArg("右下角Y_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the right lower corner."),defArg("右下角X_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the right lower corner."),defArg("左上角Y_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the left upper corner."),defArg("左上角X_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the left upper corner."),defArg("右下角Y_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the right lower corner."),defArg("右下角X_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the right lower corner.")};
defARGINFO __arg_draw_rectangle2 [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the center."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("长半轴角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the bigger half axis in radians."),defArg("长半轴长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Bigger half axis."),defArg("短半轴长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smaller half axis.")};
defARGINFO __arg_draw_rectangle2_mod [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("中心Y_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("中心X_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("长半轴角度_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the bigger half axis in radians."),defArg("长半轴长度_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Bigger half axis."),defArg("短半轴长度_入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Smaller half axis."),defArg("中心Y_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the center."),defArg("中心X_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("长半轴角度_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the bigger half axis in radians."),defArg("长半轴长度_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Bigger half axis."),defArg("短半轴长度_出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smaller half axis.")};
defARGINFO __arg_draw_region [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Interactive created region."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_draw_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Modified contour."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?")};
defARGINFO __arg_draw_xld_mod [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("输出轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Modified contour."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("是否旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable rotation?"),defArg("是否平移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable moving?"),defArg("是否缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable scaling?"),defArg("是否等比例缩放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keep ratio while scaling?"),defArg("是否编辑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable editing?")};
defARGINFO __arg_dual_rank [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered Image."),defArg("掩码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the mask."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the filter mask."),defArg("百分比模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter Mode: 0 corresponds to a gray value opening , 50 corresponds to a median and 100 to a gray values closing."),defArg("边缘", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_dual_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("正负区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Positive and negative regions."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regions smaller than MinSize are suppressed."),defArg("最小灰度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regions whose maximum absolute gray value is smaller than MinGray are suppressed."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regions that have a gray value smaller than Threshold (or larger than -Threshold) are suppressed.")};
defARGINFO __arg_dump_window [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("文件格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the target device or of the graphic format."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name (without extension).")};
defARGINFO __arg_dump_window_image [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Saved image."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_dyn_threshold [] = {defArg("原始图像", dataTypeObj, 0, 0, "Input image."),defArg("图像阈值", dataTypeObj, 0, 0, "Image containing the local thresholds."),defArg("局部区域动态阈值", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("偏差量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Offset applied to ThresholdImage."),defArg("明暗", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extract light, dark or similar areas?")};
defARGINFO __arg_eccentricity [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("半径之比", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Shape feature (in case of a circle = 1.0)."),defArg("蓬松度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated shape feature."),defArg("结构因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated shape feature.")};
defARGINFO __arg_eccentricity_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("等轴", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Anisometry of the contours or polygons.")};
defARGINFO __arg_eccentricity_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("等轴", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Anisometry of the contours or polygons."),defArg("蓬松度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Bulkiness of the contours or polygons."),defArg("结构因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Structure factor of the contours or polygons.")};
defARGINFO __arg_edges_color [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("幅值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Edge operator to be applied."),defArg("滤波系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny')."),defArg("非极大值抑制", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Non-maximum suppression ('none', if not desired)."),defArg("低阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation (negative if no thresholding is desired)."),defArg("高阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation (negative if no thresholding is desired).")};
defARGINFO __arg_edges_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Edge operator to be applied."),defArg("滤波器系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny')."),defArg("非极大值抑制", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Non-maximum suppression ('none', if not desired)."),defArg("低阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation (negative, if no thresholding is desired)."),defArg("高阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation (negative, if no thresholding is desired).")};
defARGINFO __arg_eigenvalues_general_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("计算特征向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of the eigenvectors."),defArg("特征值实部矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the real parts of the eigenvalues."),defArg("特征值虚部矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the imaginary parts of the eigenvalues."),defArg("特征向量实部矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the real parts of the eigenvectors."),defArg("特征向量虚部矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the imaginary parts of the eigenvectors.")};
defARGINFO __arg_eigenvalues_symmetric_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("计算特征向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of the eigenvectors."),defArg("特征值矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the eigenvalues."),defArg("特征向量矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the eigenvectors.")};
defARGINFO __arg_eliminate_min_max [] = {defArg("图像", dataTypeObj, 0, 0, "Image to smooth."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of filter mask."),defArg("间隙", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gap between local maximum/minimum and all other gray values of the neighborhood."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Replacement rule (1 = next minimum/maximum, 2 = average, 3 =median).")};
defARGINFO __arg_eliminate_runs [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be clipped."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Clipped regions."),defArg("消除短运动", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All runs which are shorter are eliminated."),defArg("消除长运动", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All runs which are longer are eliminated.")};
defARGINFO __arg_eliminate_sp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of filter mask."),defArg("最小阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum gray value."),defArg("最大阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum gray value.")};
defARGINFO __arg_elliptic_axis [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions."),defArg("主半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Main radius (normalized to the area)."),defArg("第二半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Secondary radius (normalized to the area)."),defArg("夹角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between main radius and x-axis in radians.")};
defARGINFO __arg_elliptic_axis_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("长轴", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Major axis of the region."),defArg("短轴", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minor axis of the region."),defArg("水平角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle enclosed by the major axis and the x-axis.")};
defARGINFO __arg_elliptic_axis_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("RA", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Major radius."),defArg("RB", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minor radius."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the major axis and the column axis (radians).")};
defARGINFO __arg_elliptic_axis_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("主半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Major radius."),defArg("第二半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minor radius."),defArg("夹角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the major axis and the x axis (radians).")};
defARGINFO __arg_emphasize [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be enhanced."),defArg("对比度加强后的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "contrast enhanced image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of low pass mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the low pass mask."),defArg("对比度系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Intensity of contrast emphasis.")};
defARGINFO __arg_energy_gabor [] = {defArg("小波图像", dataTypeObj, 0, 0, "1st channel of input image (usually: Gabor image)."),defArg("图像希尔伯特", dataTypeObj, 0, 0, "2nd channel of input image (usually: Hilbert image)."),defArg("能量", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the local energy.")};
defARGINFO __arg_enqueue_message [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message queue handle."),defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle(s) of message(s) to be enqueued."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of optional generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of optional generic parameters.")};
defARGINFO __arg_enquire_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Array of attributes which has to be classified."),defArg("类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the class to which the array of attributes had been assigned.")};
defARGINFO __arg_enquire_reject_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Array of attributes which has to be classified."),defArg("类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the class, to which the array of attributes had been assigned or -1 for the rejection class.")};
defARGINFO __arg_entropy_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Regions where the features are to be determined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("熵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information content (entropy) of the gray values."),defArg("各向异性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure of the symmetry of gray value distribution.")};
defARGINFO __arg_entropy_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the entropy is to be calculated."),defArg("图像熵", dataTypeObj, 0, AS_RECEIVE_VAR, "Entropy image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the mask in which the entropy is calculated."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the mask in which the entropy is calculated.")};
defARGINFO __arg_equ_histo_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be enhanced."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with linearized gray values.")};
defARGINFO __arg_erosion1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("侵蚀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_erosion2 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("侵蚀的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_erosion_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("腐蚀后的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circular structuring element.")};
defARGINFO __arg_erosion_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_erosion_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("腐蚀后的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the structuring rectangle."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the structuring rectangle.")};
defARGINFO __arg_erosion_seq [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_estimate_noise [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to estimate the image noise."),defArg("噪音百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage of used image points."),defArg("噪音", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Standard deviation of the image noise.")};
defARGINFO __arg_euler_number [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("欧拉数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated Euler number.")};
defARGINFO __arg_evaluate_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("后验概率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A-posteriori probability of the classes."),defArg("密度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Probability density of the feature vector."),defArg("k西格玛问题", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Normalized k-sigma-probability for the feature vector.")};
defARGINFO __arg_evaluate_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of evaluating the feature vector with the MLP.")};
defARGINFO __arg_evaluate_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Feature vector."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of evaluating the feature vector with the SVM.")};
defARGINFO __arg_exhaustive_match [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("感兴趣区域", dataTypeObj, 0, 0, "Area to be searched in the input image."),defArg("图像模板", dataTypeObj, 0, 0, "This area will be \"matched\" by Image within the RegionOfInterest."),defArg("匹配后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image: values of the matching criterion."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired matching criterion.")};
defARGINFO __arg_exhaustive_match_mg [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像模板", dataTypeObj, 0, 0, "The domain of this image will be matched with Image."),defArg("匹配图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image and result region: values of the matching criterion within the determined \"region of interest\"."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired matching criterion."),defArg("金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Startlevel in the resolution pyramid (highest resolution: Level 0)."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold to determine the \"region of interest\".")};
defARGINFO __arg_expand_domain_gray [] = {defArg("输入图像", dataTypeObj, 0, 0, "Input image with domain to be expanded."),defArg("扩展图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image with new gray values in the expanded domain."),defArg("扩展范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the gray value expansion, measured in pixels.")};
defARGINFO __arg_expand_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the gaps are to be closed, or which are to be separated."),defArg("图像", dataTypeObj, 0, 0, "Image (possibly multi-channel) for gray value or color comparison."),defArg("禁区", dataTypeObj, 0, 0, "Regions in which no expansion takes place."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Expanded or separated regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Expansion mode."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum difference between the gray value or color at the region's border and a candidate for expansion.")};
defARGINFO __arg_expand_gray_ref [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the gaps are to be closed, or which are to be separated."),defArg("图像", dataTypeObj, 0, 0, "Image (possibly multi-channel) for gray value or color comparison."),defArg("禁区", dataTypeObj, 0, 0, "Regions in which no expansion takes place."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Expanded or separated regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Expansion mode."),defArg("引用灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Reference gray value or color for comparison."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum difference between the reference gray value or color and a candidate for expansion.")};
defARGINFO __arg_expand_line [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域扩大", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted segments."),defArg("坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row or column coordinate."),defArg("停止准则", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stopping criterion."),defArg("分割模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Segmentation mode (row or column)."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the expansion.")};
defARGINFO __arg_expand_region [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the gaps are to be closed, or which are to be separated."),defArg("禁区", dataTypeObj, 0, 0, "Regions in which no expansion takes place."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Expanded or separated regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Expansion mode.")};
defARGINFO __arg_exp_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("指数图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("基", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Base of the exponentiation.")};
defARGINFO __arg_fast_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("最小的灰色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the gray values."),defArg("最大的灰色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the gray values."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of objects to be extracted.")};
defARGINFO __arg_fft_generic [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像的FFT", dataTypeObj, 0, AS_RECEIVE_VAR, "Fourier-transformed image."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Calculate forward or reverse transform."),defArg("指数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sign of the exponent."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the transform."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("结果类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image type of the output image.")};
defARGINFO __arg_fft_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像的FFT", dataTypeObj, 0, AS_RECEIVE_VAR, "Fourier-transformed image.")};
defARGINFO __arg_fft_image_inv [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("逆傅立叶图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Inverse-Fourier-transformed image.")};
defARGINFO __arg_file_exists [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of file to be checked."),defArg("文件存在", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "boolean number.")};
defARGINFO __arg_fill_interlace [] = {defArg("摄像机图像", dataTypeObj, 0, 0, "Gray image consisting of two half images."),defArg("填充后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Full image with interpolated/removed lines."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Instruction whether even or odd lines should be replaced/removed.")};
defARGINFO __arg_fill_up [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions containing holes."),defArg("区域填充", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions without holes.")};
defARGINFO __arg_fill_up_shape [] = {defArg("区域", dataTypeObj, 0, 0, "Input region(s)."),defArg("区域填充", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region(s) with filled holes."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape feature used."),defArg("特征的最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum value for Feature."),defArg("特征的最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum value for Feature.")};
defARGINFO __arg_filter_kalman [] = {defArg("维度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The dimensions of the state vector, the measurement and the controller vector."),defArg("模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The lined up matrices A,C,Q, possibly G and u, and if necessary L which have been stored in row-major order."),defArg("测量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The matrix R stored in row-major order and the measurement vector y lined up."),defArg("预测输入", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The matrix P* (the extrapolation-error covariances) stored in row-major order and the extrapolation vector x* lined up."),defArg("预测输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The matrix P* (the extrapolation-error covariances)stored in row-major order and the extrapolation vector x* lined up."),defArg("估计", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The matrix P~ (the estimation-error covariances) stored in row-major order and the estimated state x~ lined up.")};
defARGINFO __arg_find_caltab [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("校准板", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region."),defArg("校准板描述的文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("高斯尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter size of the Gaussian."),defArg("标记点阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold value for mark extraction."),defArg("标志点最小直径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Expected minimal diameter of the marks on the calibration plate.")};
defARGINFO __arg_find_marks_and_pose [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("校准板区域。", dataTypeObj, 0, 0, "Region of the calibration plate."),defArg("校准板描述的文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("相机的初始化参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial values for the internal camera parameters."),defArg("初始阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Initial threshold value for contour detection."),defArg("阈值递减", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Loop value for successive reduction of StartThresh."),defArg("最小阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum threshold for contour detection."),defArg("去噪系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter for contour detection, see edges_image."),defArg("最小轮廓长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum length of the contours of the marks."),defArg("最大轮廓标志", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum expected diameter of the marks."),defArg("行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with row coordinates of the detected marks."),defArg("列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with column coordinates of the detected marks."),defArg("相机的初始姿势", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Estimation for the external camera parameters.")};
defARGINFO __arg_find_neighbors [] = {defArg("区域1", dataTypeObj, 0, 0, "Starting regions."),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal distance of regions."),defArg("区域指数1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the found regions from Regions1."),defArg("区域指数2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the found regions from Regions2.")};
defARGINFO __arg_fitting [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring elements."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Fitted regions.")};
defARGINFO __arg_fit_circle_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the fitting of circles."),defArg("最大点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of contour points used for the computation (-1 for all points)."),defArg("最大的封闭区", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the end points of a contour to be considered as 'closed'."),defArg("夹点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and at the end of the contours to be ignored for the fitting."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations for the robust weighted fitting."),defArg("裁剪因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers (typical: 1.0 for Huber and 2.0 for Tukey)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the circle."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the circle."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radius of circle."),defArg("起点角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of the start point [rad]."),defArg("结束角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of the end point [rad]."),defArg("点顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Point order along the boundary.")};
defARGINFO __arg_fit_ellipse_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the fitting of ellipses."),defArg("最大点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of contour points used for the computation (-1 for all points)."),defArg("最大封闭距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the end points of a contour to be considered as 'closed'."),defArg("夹点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and at the end of the contours to be ignored for the fitting."),defArg("tab个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of circular segments used for the Voss approach."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations for the robust weighted fitting."),defArg("裁剪因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers (typical: 1.0 for '*huber' and 2.0 for '*tukey')."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the ellipse."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the ellipse."),defArg("主轴线方向角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the main axis [rad]."),defArg("半径1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of the larger half axis."),defArg("半径2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of the smaller half axis."),defArg("开始角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of the start point [rad]."),defArg("结束角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of the end point [rad]."),defArg("点顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "point order along the boundary.")};
defARGINFO __arg_fit_line_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the fitting of lines."),defArg("用于估计的最大点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of contour points used for the computation (-1 for all points)."),defArg("裁剪点部分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and at the end of the contours to be ignored for the fitting."),defArg("最大迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations (unused for 'regression')."),defArg("裁剪因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 'drop' and 2.0 for 'tukey')."),defArg("线段起始行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the starting points of the line segments."),defArg("线段起始列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the starting points of the line segments."),defArg("线段结束行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the end points of the line segments."),defArg("线段结束列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the end points of the line segments."),defArg("法线行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line parameter: Row coordinate of the normal vector"),defArg("法线列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line parameter: Column coordinate of the normal vector"),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line parameter: Distance of the line from the origin")};
defARGINFO __arg_fit_rectangle2_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for fitting the rectangles."),defArg("最大的点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of contour points used for the computation (-1 for all points)."),defArg("最大的闭合距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the end points of a contour to be considered as closed."),defArg("裁剪端点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points at the beginning and at the end of the contours to be ignored for the fitting."),defArg("迭代", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations (not used for 'regression')."),defArg("裁剪因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 2.0 for 'tukey')."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the rectangle."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the rectangle."),defArg("phi", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the main axis of the rectangle [rad]."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First radius (half length) of the rectangle."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second radius (half width) of the rectangle."),defArg("点顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Point order of the contour.")};
defARGINFO __arg_fit_surface_first_order [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be checked."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray values."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the fitting."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations (unused for 'regression')."),defArg("削波因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers."),defArg("Alpha参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Alpha of the approximating surface."),defArg("Beta参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Beta of the approximating surface."),defArg("Gamma参数；", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Gamma of the approximating surface.")};
defARGINFO __arg_fit_surface_second_order [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be checked."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray values."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the fitting."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations (unused for 'regression')."),defArg("削波因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers."),defArg("Alpha参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Alpha of the approximating surface."),defArg("Beta参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Beta of the approximating surface."),defArg("Gamma参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Gamma of the approximating surface."),defArg("Delta参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Delta of the approximating surface."),defArg("Epsilon参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Epsilon of the approximating surface."),defArg("Zeta参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Zeta of the approximating surface.")};
defARGINFO __arg_fnew_line [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle.")};
defARGINFO __arg_fourier_1dim [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the contour."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the contour."),defArg("缩放因素", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter scale."),defArg("最大系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired number of Fourier coefficients or all of them (0)."),defArg("系数实部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Real parts of the Fourier coefficients."),defArg("系数虚部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Imaginary parts of the Fourier coefficients.")};
defARGINFO __arg_fourier_1dim_inv [] = {defArg("系数实部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Real parts."),defArg("系数虚部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Imaginary parts."),defArg("最大系数个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input of the steps for the backtransformation."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates.")};
defARGINFO __arg_fread_char [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read character or control string ('eof').")};
defARGINFO __arg_fread_line [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read line."),defArg("文件是否结束", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Reached end of file.")};
defARGINFO __arg_fread_serialized_item [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_fread_string [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("输出字符串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read character sequence."),defArg("文件是否结束", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Reached end of file.")};
defARGINFO __arg_frei_amp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像边缘幅度", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image.")};
defARGINFO __arg_frei_dir [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("边缘角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image.")};
defARGINFO __arg_full_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with maximum definition domain.")};
defARGINFO __arg_funct_1d_to_pairs [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("x值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X values of the function."),defArg("y值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y values of the function.")};
defARGINFO __arg_fuzzy_entropy [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the fuzzy entropy is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Input image containing the fuzzy membership values."),defArg("开始模糊值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start of the fuzzy function."),defArg("结束模糊值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End of the fuzzy function."),defArg("模糊熵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Fuzzy entropy of a region.")};
defARGINFO __arg_fuzzy_perimeter [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the fuzzy perimeter is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Input image containing the fuzzy membership values."),defArg("开始模糊值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start of the fuzzy function."),defArg("结束模糊值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End of the fuzzy function."),defArg("周长", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Fuzzy perimeter of a region.")};
defARGINFO __arg_fwrite_serialized_item [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_fwrite_string [] = {defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File handle."),defArg("字符串", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values to be put out on the file.")};
defARGINFO __arg_gamma_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("伽马射线图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("γ", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gamma coefficient of the exponential part of the transformation."),defArg("偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Offset of the exponential part of the transformation."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value for which the transformation switches from linear to exponential."),defArg("最大的灰色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum gray value of the input image type."),defArg("编码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "If 'true', perform a gamma encoding, otherwise a gamma decoding.")};
defARGINFO __arg_gauss_distribution [] = {defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gaussian noise distribution."),defArg("分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Resulting Gaussian noise distribution.")};
defARGINFO __arg_gauss_filter [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required filter size.")};
defARGINFO __arg_gauss_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required filter size.")};
defARGINFO __arg_generalized_eigenvalues_general_matrix [] = {defArg("矩阵A", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("矩阵B", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("计算的特征向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of the eigenvectors."),defArg("特征值实部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the real parts of the eigenvalues."),defArg("特征值虚部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the imaginary parts of the eigenvalues."),defArg("特征向量实部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the real parts of the eigenvectors."),defArg("特征向量虚部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the imaginary parts of the eigenvectors.")};
defARGINFO __arg_generalized_eigenvalues_symmetric_matrix [] = {defArg("矩阵A", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the symmetric input matrix A."),defArg("矩阵B", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the symmetric positive definite input matrix B."),defArg("计算的特征向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of the eigenvectors."),defArg("特征值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the eigenvalues."),defArg("特征向量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the eigenvectors.")};
defARGINFO __arg_gen_bandfilter [] = {defArg("图像滤波", dataTypeObj, 0, AS_RECEIVE_VAR, "Band filter in the frequency domain."),defArg("最小频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum frequency."),defArg("最大频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum frequency."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_bandpass [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Bandpass filter in the frequency domain."),defArg("最小频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum frequency."),defArg("最大频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum frequency."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_caltab [] = {defArg("X个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of marks in x direction."),defArg("Y个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of marks in y direction."),defArg("标志距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the marks in meters."),defArg("直径比值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Ratio of the mark diameter to the mark distance."),defArg("校准板描述", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("校准板的脚本文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the PostScript file.")};
defARGINFO __arg_gen_checker_region [] = {defArg("棋盘区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created checkerboard region."),defArg("区域宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Largest occurring x value of the region."),defArg("区域高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Largest occurring y value of the region."),defArg("宽度模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of a field of the checkerboard."),defArg("高度模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of a field of the checkerboard.")};
defARGINFO __arg_gen_circle [] = {defArg("圆", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated circle."),defArg("圆心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of center."),defArg("圆心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of circle.")};
defARGINFO __arg_gen_circle_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contours."),defArg("圆心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the circles or circular arcs."),defArg("圆心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the circles or circular arcs."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circles or circular arcs."),defArg("起点角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start points of the circles or circular arcs [rad]."),defArg("终点角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end points of the circles or circular arcs [rad]."),defArg("圆弧方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the circles or circular arcs."),defArg("分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance between neighboring contour points.")};
defARGINFO __arg_gen_circle_sector [] = {defArg("生成的扇形", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated circle sector."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of circle."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start angle of the circle sector."),defArg("结束角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End angle of the circle sector.")};
defARGINFO __arg_gen_contours_skeleton_xld [] = {defArg("骨架", dataTypeObj, 0, 0, "Skeleton of which the contours are to be determined."),defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contours."),defArg("最小长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum number of points a contour has to have."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Contour filter mode.")};
defARGINFO __arg_gen_contour_nurbs_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "The contour that approximates the NURBS curve."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the control polygon."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the control polygon."),defArg("节点向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The knot vector u."),defArg("权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The weight vector w."),defArg("阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The degree p of the NURBS curve."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the NURBS curve and its approximation."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between two subsequent Contour points.")};
defARGINFO __arg_gen_contour_polygon_rounded_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contour."),defArg("坐标Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the polygon."),defArg("坐标X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the polygon."),defArg("圆角半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radii of the rounded corners."),defArg("采样间隔", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the samples.")};
defARGINFO __arg_gen_contour_polygon_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contour."),defArg("坐标Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the polygon."),defArg("坐标X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the polygon.")};
defARGINFO __arg_gen_contour_region_xld [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions."),defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contours."),defArg("生成模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of contour generation.")};
defARGINFO __arg_gen_cooc_matrix [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be checked."),defArg("图像", dataTypeObj, 0, 0, "Image providing the gray values."),defArg("矩阵", dataTypeObj, 0, AS_RECEIVE_VAR, "Co-occurrence matrix (matrices)."),defArg("灰度值数量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of gray values to be distinguished (2^LdGray)."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Direction of neighbor relation.")};
defARGINFO __arg_gen_cross_contour_xld [] = {defArg("十字轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated XLD contours."),defArg("坐标Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the input points."),defArg("坐标X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the input points."),defArg("十字线长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the cross bars."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the crosses.")};
defARGINFO __arg_gen_derivative_filter [] = {defArg("图像导数", dataTypeObj, 0, AS_RECEIVE_VAR, "Derivative filter as image in the frequency domain."),defArg("导数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Derivative to be computed."),defArg("指数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Exponent used in the reverse transform."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_disc_se [] = {defArg("结构元素", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated structuring element."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the structuring element."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the structuring element."),defArg("最大灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum gray value of the structuring element.")};
defARGINFO __arg_gen_ellipse [] = {defArg("椭圆", dataTypeObj, 0, AS_RECEIVE_VAR, "Created ellipse(s)."),defArg("中心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of center."),defArg("中心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("长半轴角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the longer radius (Radius1)."),defArg("长轴长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Longer radius."),defArg("短轴长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shorter radius.")};
defARGINFO __arg_gen_ellipse_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contour."),defArg("中心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the ellipse."),defArg("中心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the ellipse."),defArg("长半轴角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis [rad]."),defArg("长半轴长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half axis."),defArg("短半轴长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half axis."),defArg("起点角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point on the smallest surrounding circle [rad]."),defArg("终点角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point on the smallest surrounding circle [rad]."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "point order along the boundary."),defArg("分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Resolution: Maximum distance between neighboring contour points.")};
defARGINFO __arg_gen_ellipse_sector [] = {defArg("椭圆扇形", dataTypeObj, 0, AS_RECEIVE_VAR, "Created ellipse(s)."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the longer radius (Radius1)."),defArg("半径1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Longer radius."),defArg("半径2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shorter radius."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start angle of the sector."),defArg("结束角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "End angle of the sector.")};
defARGINFO __arg_gen_empty_obj [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "No objects.")};
defARGINFO __arg_gen_empty_region [] = {defArg("空区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Empty region (no pixels).")};
defARGINFO __arg_gen_filter_mask [] = {defArg("图像滤波", dataTypeObj, 0, AS_RECEIVE_VAR, "Filter in the spatial domain."),defArg("过滤器掩码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter mask as file name or tuple."),defArg("比例因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scaling factor."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_gabor [] = {defArg("图像滤波", dataTypeObj, 0, AS_RECEIVE_VAR, "Gabor and Hilbert filter."),defArg("角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle range, inversely proportional to the range of orientations."),defArg("频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the center of the filter to the DC term."),defArg("带宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Bandwidth range, inversely proportional to the range of frequencies being passed."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the principal orientation."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_gauss_filter [] = {defArg("图像高斯", dataTypeObj, 0, AS_RECEIVE_VAR, "Gaussian filter as image in the frequency domain."),defArg("标准差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gaussian in the principal direction of the filter in the spatial domain."),defArg("标准差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gaussian perpendicular to the principal direction of the filter in the spatial domain."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Principal direction of the filter in the spatial domain."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_gauss_pyramid [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像金字塔", dataTypeObj, 0, AS_RECEIVE_VAR, "Output images."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of filtermask."),defArg("缩小因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for scaling down.")};
defARGINFO __arg_gen_grid_region [] = {defArg("网格区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created lines/pixel region."),defArg("行步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step width in line direction or zero."),defArg("列步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step width in column direction or zero."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of created pattern."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of pattern."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum height of pattern.")};
defARGINFO __arg_gen_highpass [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Highpass filter in the frequency domain."),defArg("频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Cutoff frequency."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_image1 [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("像素类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image."),defArg("像素指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to first gray value.")};
defARGINFO __arg_gen_image1_extern [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created HALCON image."),defArg("图像类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image."),defArg("像素指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the first gray value."),defArg("释放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the procedure re-releasing the memory of the image when deleting the object.")};
defARGINFO __arg_gen_image1_rect [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created HALCON image."),defArg("像素指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the first pixel."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image."),defArg("垂直间距", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distance (in bytes) between pixel m in row n and pixel m in row n+1 of the 'input image'."),defArg("水平间距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance between two neighboring pixels in bits ."),defArg("每像素位数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of used bits per pixel."),defArg("是否复制", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Copy image data."),defArg("释放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the procedure releasing the memory of the image when deleting the object.")};
defARGINFO __arg_gen_image3 [] = {defArg("RGB图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("像素类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image."),defArg("红色通道指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to first red value (channel 1)."),defArg("绿色通道指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to first green value (channel 2)."),defArg("蓝色通道指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to first blue value (channel 3).")};
defARGINFO __arg_gen_image3_extern [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created HALCON image."),defArg("图像类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image."),defArg("指针红色", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the first gray value of the first channel."),defArg("指针绿色", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the first gray value of the second channel."),defArg("指针蓝", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the first gray value of the third channel."),defArg("释放", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the procedure re-releasing the memory of the image when deleting the object.")};
defARGINFO __arg_gen_image_const [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("像素类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image.")};
defARGINFO __arg_gen_image_gray_ramp [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("横向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gradient in line direction."),defArg("纵向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gradient in column direction."),defArg("平均灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mean gray value."),defArg("参考点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of reference point."),defArg("参考点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of reference point."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image.")};
defARGINFO __arg_gen_image_interleaved [] = {defArg("RGB图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("像素指针", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to interleaved pixels."),defArg("颜色格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Format of the input pixels."),defArg("原始宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of input image."),defArg("原始高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of input image."),defArg("对齐", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Reserved."),defArg("图像类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type of output image."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of output image."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of output image."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line number of upper left corner of desired image part."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column number of upper left corner of desired image part."),defArg("每通道位数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of used bits per pixel and channel of the output image (-1: All bits are used)."),defArg("位移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of bits that the color values of the input pixels are shifted to the right (only uint2 images).")};
defARGINFO __arg_gen_image_proto [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("输出图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with constant gray value."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value to be used for the output image.")};
defARGINFO __arg_gen_image_surface_first_order [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("像素类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("横向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First order coefficient in vertical direction."),defArg("纵向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First order coefficient in horizontal direction."),defArg("次序系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Zero order coefficient."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point of the surface."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point of the surface."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image.")};
defARGINFO __arg_gen_image_surface_second_order [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Created image with new image matrix."),defArg("图像类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type."),defArg("横向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second order coefficient in vertical direction."),defArg("纵向倾斜度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second order coefficient in horizontal direction."),defArg("次序系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mixed second order coefficient."),defArg("垂直一次序系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First order coefficient in vertical direction."),defArg("水平一次序系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First order coefficient in horizontal direction."),defArg("次序系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Zero order coefficient."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point of the surface."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point of the surface."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of image.")};
defARGINFO __arg_gen_lowpass [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Lowpass filter in the frequency domain."),defArg("频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Cutoff frequency."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_mean_filter [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Mean filter as image in the frequency domain."),defArg("掩码形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the filter mask in the spatial domain."),defArg("直径1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Diameter of the mean filter in the principal direction of the filter in the spatial domain."),defArg("直径2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Diameter of the mean filter perpendicular to the principal direction of the filter in the spatial domain."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Principal direction of the filter in the spatial domain."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_nurbs_interp [] = {defArg("点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of input point list."),defArg("点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of input point list."),defArg("点切线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tangents at first and last point."),defArg("曲线阶数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of the output curve."),defArg("多边形Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the control polygon."),defArg("多边形X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the control polygon."),defArg("节点向量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The knot vector of the output curve.")};
defARGINFO __arg_gen_parallels_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Input polygons."),defArg("并行", dataTypeObj, 0, AS_RECEIVE_VAR, "Parallel polygons."),defArg("长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum length of the individual polygon segments."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the polygon segments."),defArg("Alpha", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle difference of the polygon segments."),defArg("合并", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should adjacent parallel relations be merged?")};
defARGINFO __arg_gen_parallel_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be transformed."),defArg("平行轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Parallel contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode, with which the direction information is computed."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the parallel contour.")};
defARGINFO __arg_gen_polygons_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be approximated."),defArg("多边形", dataTypeObj, 0, AS_RECEIVE_VAR, "Approximating polygons."),defArg("逼近模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of approximation."),defArg("逼近阀值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the approximation.")};
defARGINFO __arg_gen_principal_comp_trans [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel input image."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix for the computation of the PCA."),defArg("逆变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix for the computation of the inverse PCA."),defArg("平均灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean gray value of the channels."),defArg("协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrix of the channels."),defArg("通道信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information content of the transformed channels.")};
defARGINFO __arg_gen_psf_defocus [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Impulse response of uniform out-of-focus blurring."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of result image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of result image."),defArg("模糊度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Degree of Blurring.")};
defARGINFO __arg_gen_psf_motion [] = {defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Impulse response of motion-blur."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of impulse response image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of impulse response image."),defArg("模糊度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Degree of motion-blur."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between direction of motion and x-axis (anticlockwise)."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "PSF prototype resp. type of motion.")};
defARGINFO __arg_gen_random_region [] = {defArg("值", dataTypeObj, 0, AS_RECEIVE_VAR, "Created random region with expansion Width x Height."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum horizontal expansion of random region."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum vertical expansion of random region.")};
defARGINFO __arg_gen_random_regions [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created regions."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of regions to be created."),defArg("最小宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum width of the region."),defArg("最大宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of the region."),defArg("最小高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum height of the region."),defArg("最大高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum height of the region."),defArg("最小旋转角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum rotation angle of the region."),defArg("最大旋转角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum rotation angle of the region."),defArg("区域数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of regions."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum horizontal expansion."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum vertical expansion.")};
defARGINFO __arg_gen_rectangle1 [] = {defArg("矩形", dataTypeObj, 0, AS_RECEIVE_VAR, "Created rectangle."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line of upper left corner point."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of upper left corner point."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line of lower right corner point."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of lower right corner point.")};
defARGINFO __arg_gen_rectangle2 [] = {defArg("矩形", dataTypeObj, 0, AS_RECEIVE_VAR, "Created rectangle."),defArg("中心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of the center."),defArg("中心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of longitudinal axis to the horizontal (in radians)."),defArg("宽度半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width."),defArg("高度半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height.")};
defARGINFO __arg_gen_rectangle2_contour_xld [] = {defArg("矩形", dataTypeObj, 0, AS_RECEIVE_VAR, "Rectangle contour."),defArg("中心Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the rectangle."),defArg("中心X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the rectangle."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis of the rectangle [rad]."),defArg("长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First radius (half length) of the rectangle."),defArg("长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second radius (half width) of the rectangle.")};
defARGINFO __arg_gen_region_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour(s)."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region(s)."),defArg("填充模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fill mode of the region(s).")};
defARGINFO __arg_gen_region_histo [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region containing the histogram."),defArg("直方图", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input histogram."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the histogram."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the histogram."),defArg("尺度系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor for the histogram.")};
defARGINFO __arg_gen_region_hline [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created regions (one for every line), clipped to maximum image format."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the normal vector in radians."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance from the line to the coordinate origin (0.0).")};
defARGINFO __arg_gen_region_line [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created regions."),defArg("起点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line coordinates of the starting points of the input lines."),defArg("起点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("终点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line coordinates of the ending points of the input lines."),defArg("终点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines.")};
defARGINFO __arg_gen_region_points [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lines of the pixels in the region."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Columns of the pixels in the region.")};
defARGINFO __arg_gen_region_polygon [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line indices of the base points of the region contour."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Colum indices of the base points of the region contour.")};
defARGINFO __arg_gen_region_polygon_filled [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line indices of the base points of the region contour."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column indices of the base points of the region contour.")};
defARGINFO __arg_gen_region_polygon_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Input polygon(s)."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region(s)."),defArg("填充模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fill mode of the region(s).")};
defARGINFO __arg_gen_region_runs [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Created region."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lines of the runs."),defArg("列开始", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Columns of the starting points of the runs."),defArg("列结束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Columns of the ending points of the runs.")};
defARGINFO __arg_gen_sin_bandpass [] = {defArg("图像滤波", dataTypeObj, 0, AS_RECEIVE_VAR, "Bandpass filter as image in the frequency domain."),defArg("频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the filter's maximum from the DC term."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_std_bandpass [] = {defArg("滤波后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Bandpass filter as image in the frequency domain."),defArg("频率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of the filter's maximum from the DC term."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Bandwidth of the filter (standard deviation)."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter type."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the filter."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Location of the DC term in the frequency domain."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image (filter)."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image (filter).")};
defARGINFO __arg_gen_struct_elements [] = {defArg("结构元素", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated structuring elements."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of structuring element to generate."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point.")};
defARGINFO __arg_get_aop_info [] = {defArg("算子", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Operator to get information for"),defArg("索引名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further index stages"),defArg("索引值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further index values"),defArg("信息名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scope of information"),defArg("信息值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of information")};
defARGINFO __arg_get_bg_esti_params [] = {defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set."),defArg("系统矩阵参数1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "1. system matrix parameter."),defArg("系统矩阵参数2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "2. system matrix parameter."),defArg("增益模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gain type."),defArg("增益时间1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Kalman gain / foreground adaptation time."),defArg("增益时间2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Kalman gain / background adaptation time."),defArg("自适应模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Threshold adaptation."),defArg("最小差异阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Foreground / background threshold."),defArg("数据集数量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of statistic data sets."),defArg("信心常数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence constant."),defArg("时间常数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Constant for decay time.")};
defARGINFO __arg_get_channel_info [] = {defArg("对象", dataTypeObj, 0, 0, "Image object to be examined."),defArg("请求", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required information about object components."),defArg("通道", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Components to be examined (0 for region/XLD)."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Requested information.")};
defARGINFO __arg_get_chapter_info [] = {defArg("运算符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Operator class or subclass of interest."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Operator classes (Chapter = \") or operator subclasses respectively operators.")};
defARGINFO __arg_get_check [] = {defArg("控制模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuplet of the currently activated control modes.")};
defARGINFO __arg_get_class_box_param [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("标志", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the system parameter."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the system parameter.")};
defARGINFO __arg_get_class_train_data_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a GMM that contains training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data of the classifier.")};
defARGINFO __arg_get_class_train_data_knn [] = {defArg("k近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier that contains training data."),defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data of the classifier.")};
defARGINFO __arg_get_class_train_data_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a MLP that contains training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data of the classifier.")};
defARGINFO __arg_get_class_train_data_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a SVM that contains training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data of the classifier.")};
defARGINFO __arg_get_comprise [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Display mode for images.")};
defARGINFO __arg_get_compute_device_info [] = {defArg("设备标识符", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle."),defArg("信息名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of Information to query."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Returned information.")};
defARGINFO __arg_get_compute_device_param [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter to query."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the parameter.")};
defARGINFO __arg_get_contour_angle_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("角模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Return type of the angles."),defArg("角度计算模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for computing the angles."),defArg("考虑的点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points to take into account."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Direction of the tangent to the contour points.")};
defARGINFO __arg_get_contour_attrib_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contour."),defArg("名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the attribute."),defArg("属性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Attribute values.")};
defARGINFO __arg_get_contour_global_attrib_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contour."),defArg("属性名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the attribute."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Attribute values.")};
defARGINFO __arg_get_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contour."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the contour's points."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the contour's points.")};
defARGINFO __arg_get_current_dir [] = {defArg("目录名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of current working directory.")};
defARGINFO __arg_get_diagonal_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("对角线数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of the desired diagonal."),defArg("向量ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle containing the diagonal elements.")};
defARGINFO __arg_get_distance_transform_xld_contour [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Reference contour."),defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform.")};
defARGINFO __arg_get_distance_transform_xld_param [] = {defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("域", dataTypeObj, 0, AS_RECEIVE_VAR, "Definition domains of input images.")};
defARGINFO __arg_get_draw [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current region fill mode.")};
defARGINFO __arg_get_drawing_object_iconic [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Copy of the iconic object represented by the drawing object."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object.")};
defARGINFO __arg_get_drawing_object_params [] = {defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object."),defArg("参数名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter names of the drawing object."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter values.")};
defARGINFO __arg_get_error_text [] = {defArg("错误代码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "HALCON error code."),defArg("错误消息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Corresponding error message.")};
defARGINFO __arg_get_extended_error_info [] = {defArg("算子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Operator that set the error code."),defArg("错误代码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extended error code."),defArg("错误消息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extended error message.")};
defARGINFO __arg_get_fix [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current Mode of fixing.")};
defARGINFO __arg_get_fixed_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mode of fixing.")};
defARGINFO __arg_get_font [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("字体", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the current font.")};
defARGINFO __arg_get_font_extents [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("基线最大高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum height above baseline."),defArg("基线最大扩展", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum extension below baseline."),defArg("最大宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum character width."),defArg("最大高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum character height.")};
defARGINFO __arg_get_framegrabber_callback [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("应答类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Callback type."),defArg("回调函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the callback function."),defArg("用户数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to user-specific context data.")};
defARGINFO __arg_get_framegrabber_lut [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("映射表红", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Red level of the LUT entries."),defArg("映射表绿", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Green level of the LUT entries."),defArg("映射表蓝", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Blue level of the LUT entries.")};
defARGINFO __arg_get_framegrabber_param [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("指定参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter of interest."),defArg("输出参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter value.")};
defARGINFO __arg_get_full_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the matrix elements.")};
defARGINFO __arg_get_grayval [] = {defArg("图像", dataTypeObj, 0, 0, "Image whose gray value is to be accessed."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of pixels to be viewed."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of pixels to be viewed."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray values of indicated pixels.")};
defARGINFO __arg_get_grayval_contour_xld [] = {defArg("图像", dataTypeObj, 0, 0, "Image whose gray values are to be accessed."),defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contour with the coordinates of the positions."),defArg("插入方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray values of the selected image coordinates.")};
defARGINFO __arg_get_grayval_interpolated [] = {defArg("图像", dataTypeObj, 0, 0, "Image whose gray values are to be accessed."),defArg("坐标Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of positions."),defArg("坐标X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of positions."),defArg("插入方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray values of the selected image coordinates.")};
defARGINFO __arg_get_hsi [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("色调", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hue (color value) of the current color."),defArg("饱和", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Saturation of the current color."),defArg("两度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Intensity of the current color.")};
defARGINFO __arg_get_icon [] = {defArg("图标", dataTypeObj, 0, AS_RECEIVE_VAR, "Icon for the regions center of gravity."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id.")};
defARGINFO __arg_get_image_pointer1 [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("指针", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the image data in the HALCON database."),defArg("图像类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of image."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of image."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of image.")};
defARGINFO __arg_get_image_pointer1_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Input image (Himage)."),defArg("像素点数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the image data."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the output image."),defArg("垂直行数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width(input image)*(HorizontalBitPitch/8)."),defArg("水平数量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between two neighboring pixels in bits ."),defArg("元素大小", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of used bits per pixel.")};
defARGINFO __arg_get_image_pointer3 [] = {defArg("RGB图像", dataTypeObj, 0, 0, "Input image."),defArg("红色通道图像指针", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the pixels of the first channel."),defArg("绿色通道图像指针", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the pixels of the second channel."),defArg("蓝色通道图像指针", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer to the pixels of the third channel."),defArg("图像类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of image."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of image."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of image.")};
defARGINFO __arg_get_image_size [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of image."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of image.")};
defARGINFO __arg_get_image_time [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("毫秒", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Milliseconds (0..999)."),defArg("秒", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Seconds (0..59)."),defArg("分钟", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minutes (0..59)."),defArg("小时", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hours (0..23)."),defArg("日", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Day of the month (1..31)."),defArg("天", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Day of the year (1..366)."),defArg("月", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Month (1..12)."),defArg("年", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Year (xxxx).")};
defARGINFO __arg_get_image_type [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of image.")};
defARGINFO __arg_get_insert [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Display mode.")};
defARGINFO __arg_get_io_channel_param [] = {defArg("输入输出通道句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter values.")};
defARGINFO __arg_get_io_device_param [] = {defArg("输入输出设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter values.")};
defARGINFO __arg_get_keywords [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Substring in the names of those operators for which keywords are needed."),defArg("关键词", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Keywords for the operators.")};
defARGINFO __arg_get_lines_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Input XLD polygons."),defArg("起点行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the lines' start points."),defArg("起点列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the lines' start points."),defArg("结束行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the lines' end points."),defArg("结束列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the lines' end points."),defArg("线段长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lengths of the line segments."),defArg("线段角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles of the line segments.")};
defARGINFO __arg_get_line_approx [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("逼近误差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current approximation error for contour display.")};
defARGINFO __arg_get_line_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("风格", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Template for contour display.")};
defARGINFO __arg_get_line_width [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current line width for contour display.")};
defARGINFO __arg_get_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("查找表", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of look-up-table or tuple of RGB-values.")};
defARGINFO __arg_get_lut_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("色调", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Modification of color value."),defArg("饱和", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Modification of saturation."),defArg("亮度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Modification of intensity.")};
defARGINFO __arg_get_mbutton [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the mouse position in the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the mouse position in the window."),defArg("按钮", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mouse button(s) pressed.")};
defARGINFO __arg_get_mbutton_sub_pix [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the mouse position in the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the mouse position in the window."),defArg("按钮", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mouse button(s) pressed.")};
defARGINFO __arg_get_message_obj [] = {defArg("对象数据", dataTypeObj, 0, AS_RECEIVE_VAR, "Tuple value retrieved from the message."),defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Key string.")};
defARGINFO __arg_get_message_param [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the message parameters or info queries."),defArg("消息键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message keys the parameter/query should be applied to."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the message parameters or info queries.")};
defARGINFO __arg_get_message_queue_param [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message queue handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the queue parameters or info queries."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the queue parameters or info queries.")};
defARGINFO __arg_get_message_tuple [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Key string."),defArg("元组数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple value retrieved from the message.")};
defARGINFO __arg_get_modules [] = {defArg("使用的模块", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of used modules."),defArg("模块的关键码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Key for licence manager.")};
defARGINFO __arg_get_mposition [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the mouse position in the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the mouse position in the window."),defArg("按钮", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mouse button(s) pressed or 0.")};
defARGINFO __arg_get_mposition_sub_pix [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the mouse position in the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the mouse position in the window."),defArg("按钮", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mouse button(s) pressed or 0.")};
defARGINFO __arg_get_mshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("光标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mouse pointer name.")};
defARGINFO __arg_get_next_socket_data_type [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("数据类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Data type of next HALCON data.")};
defARGINFO __arg_get_obj_class [] = {defArg("对象", dataTypeObj, 0, 0, "Image objects to be examined."),defArg("类名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of class.")};
defARGINFO __arg_get_operator_info [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the operator on which more information is needed."),defArg("槽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired information."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information (empty if no information is available)")};
defARGINFO __arg_get_operator_name [] = {defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Substring of the seeked names (empty <=> all names)."),defArg("算子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Detected operator names.")};
defARGINFO __arg_get_os_window_handle [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("操作系统窗口句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Operating system window handle."),defArg("操作系统显示句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Operating system display handle (under Unix-like systems only).")};
defARGINFO __arg_get_paint [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name and parameter values of the current display mode.")};
defARGINFO __arg_get_pair_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the control points."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X value at the given control points."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y value at the given control points.")};
defARGINFO __arg_get_parallels_xld [] = {defArg("平行线轮廓", dataTypeObj, 0, 0, "Input XLD parallels."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the points on polygon P1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the points on polygon P1."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lengths of the line segments on polygon P1."),defArg("角度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles of the line segments on polygon P1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the points on polygon P2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the points on polygon P2."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lengths of the line segments on polygon P2."),defArg("角度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles of the line segments on polygon P2.")};
defARGINFO __arg_get_params_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("维数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of dimensions of the feature space."),defArg("类别数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of classes of the GMM."),defArg("最小类别中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum number of centers per GMM class."),defArg("最大类别中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum number of centers per GMM class."),defArg("协方差类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of the covariance matrices.")};
defARGINFO __arg_get_params_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the parameters that can be read from the k-NN classifier."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the selected parameters.")};
defARGINFO __arg_get_params_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("输入层数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of input variables (features) of the MLP."),defArg("隐层数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of hidden units of the MLP."),defArg("输出层数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of output variables (classes) of the MLP."),defArg("输出函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of the activation function in the output layer of the MLP."),defArg("预处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Preprocessing parameter: Number of transformed features.")};
defARGINFO __arg_get_params_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("特征数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of input variables (features) of the SVM."),defArg("核类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The kernel type."),defArg("核参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Additional parameter for the kernel."),defArg("正则化常量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Regularization constant of the SVM."),defArg("类别数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of classes of the test data."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The mode of the SVM."),defArg("预处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization').")};
defARGINFO __arg_get_param_info [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the operator on whose parameter more information is needed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter on which more information is needed."),defArg("槽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired information."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information (empty in case there is no information available).")};
defARGINFO __arg_get_param_names [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the operator."),defArg("输入对象名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the input objects."),defArg("输出对象名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the output objects."),defArg("输入控制参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the input control parameters."),defArg("输出控制参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the output control parameters.")};
defARGINFO __arg_get_param_num [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the operator."),defArg("c函数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the called C-function."),defArg("输入对象参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the input object parameters."),defArg("输出对象参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the output object parameters."),defArg("输入控制参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the input control parameters."),defArg("输出控制参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of the output control parameters."),defArg("类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "System operator or user procedure.")};
defARGINFO __arg_get_param_types [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the operator."),defArg("输入控制参数默认类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Default type of the input control parameters."),defArg("输出控制参数默认类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Default type of the output control parameters.")};
defARGINFO __arg_get_part [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the image part's upper left corner."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the image part's upper left corner."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of the image part's lower right corner."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the image part's lower right corner.")};
defARGINFO __arg_get_part_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("风格", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolation mode for image display: 0 (fast, low quality) to 2 (slow, high quality).")};
defARGINFO __arg_get_pixel [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("像素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the current color look-up table.")};
defARGINFO __arg_get_points_ellipse [] = {defArg("角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle corresponding to the resulting point [rad]."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the ellipse."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the ellipse."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis [rad]."),defArg("半径1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half axis."),defArg("半径2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half axis."),defArg("点行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the point on the ellipse."),defArg("点列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the point on the ellipse.")};
defARGINFO __arg_get_polygon_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Input XLD polygon."),defArg("基准Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the polygons' points."),defArg("基准X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the polygons' points."),defArg("线段长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lengths of the line segments."),defArg("线段夹角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles of the line segments.")};
defARGINFO __arg_get_pose_type [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose."),defArg("变换顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Order of rotation and translation."),defArg("旋转顺序", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Meaning of the rotation values."),defArg("变换视图", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "View of transformation.")};
defARGINFO __arg_get_prep_info_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("信息内容", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative information content of the transformed feature vectors."),defArg("累积信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative information content of the transformed feature vectors.")};
defARGINFO __arg_get_prep_info_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("信息内容", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative information content of the transformed feature vectors."),defArg("累积信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative information content of the transformed feature vectors.")};
defARGINFO __arg_get_prep_info_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("信息内容", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative information content of the transformed feature vectors."),defArg("累积信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative information content of the transformed feature vectors.")};
defARGINFO __arg_get_region_chain [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be transformed."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line of starting point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column of starting point."),defArg("链", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Direction code of the contour (from starting point).")};
defARGINFO __arg_get_region_contour [] = {defArg("区域", dataTypeObj, 0, 0, "Output region."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line numbers of the contour pixels."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the contour pixels.")};
defARGINFO __arg_get_region_convex [] = {defArg("区域", dataTypeObj, 0, 0, "Output region."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line numbers of contour pixels."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the contour pixels.")};
defARGINFO __arg_get_region_index [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("像素行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of the test pixel."),defArg("像素列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the test pixel."),defArg("测试像素所在区域索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the regions containing the test pixel.")};
defARGINFO __arg_get_region_points [] = {defArg("区域", dataTypeObj, 0, 0, "This region is accessed."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line numbers of the pixels in the region"),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the pixels in the region.")};
defARGINFO __arg_get_region_polygon [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be approximated."),defArg("距离公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between the polygon and the edge of the region."),defArg("基准点Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line numbers of the base points of the contour."),defArg("基准点X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the base points of the contour.")};
defARGINFO __arg_get_region_runs [] = {defArg("区域", dataTypeObj, 0, 0, "Output region."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line numbers of the chords."),defArg("起始列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the starting points of the chords."),defArg("结束列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column numbers of the ending points of the chords.")};
defARGINFO __arg_get_region_thickness [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be analysed."),defArg("厚度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Thickness of the region along its main axis."),defArg("直方图", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Histogram of the thickness of the region along its main axis.")};
defARGINFO __arg_get_regress_params_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of contour points."),defArg("法线回归线x", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X-coordinate of the normal vector of the regression line."),defArg("法线回归线y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y-coordinate of the normal vector of the regression line."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the regression line from the origin."),defArg("F投影x", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X-coordinate of the projection of the start point of the contour onto the regression line."),defArg("F投影y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y-coordinate of the projection of the start point of the contour onto the regression line."),defArg("L投影x", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X-coordinate of the projection of the end point of the contour onto the regression line."),defArg("L投影y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y-coordinate of the projection of the end point of the contour onto the regression line."),defArg("平均距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean distance of the contour points from the regression line."),defArg("偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Standard deviation of the distances from the regression line.")};
defARGINFO __arg_get_regularization_params_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the regularization parameter to return."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the regularization parameter.")};
defARGINFO __arg_get_rejection_params_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters to return."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_rgb [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("红色", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The current color's red value."),defArg("绿色", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The current color's green value."),defArg("蓝色", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The current color's blue value.")};
defARGINFO __arg_get_sample_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("样本数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the stored training sample."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the training sample."),defArg("样本ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Class of the training sample.")};
defARGINFO __arg_get_sample_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("样本索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the training sample."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the training sample."),defArg("样本ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Class of the training sample.")};
defARGINFO __arg_get_sample_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("样本索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of stored training sample."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the training sample."),defArg("目标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Target vector of the training sample.")};
defARGINFO __arg_get_sample_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("样本索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the stored training sample."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the training sample."),defArg("目标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Target vector of the training sample.")};
defARGINFO __arg_get_sample_class_train_data [] = {defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of training data for a classifier."),defArg("样本指数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of stored training sample."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the training sample."),defArg("分类器ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Class of the training sample.")};
defARGINFO __arg_get_sample_num_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("样本个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stored training samples.")};
defARGINFO __arg_get_sample_num_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("样本个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stored training samples.")};
defARGINFO __arg_get_sample_num_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("样本数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stored training samples.")};
defARGINFO __arg_get_sample_num_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("样本数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stored training samples.")};
defARGINFO __arg_get_sample_num_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of training data."),defArg("样本个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stored training samples.")};
defARGINFO __arg_get_serialized_item_ptr [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("数据指针", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Data pointer of the serialized item."),defArg("大小", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Size of the serialized item.")};
defARGINFO __arg_get_serial_param [] = {defArg("串口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle."),defArg("波特率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Speed of the serial interface."),defArg("数据位", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of data bits of the serial interface."),defArg("流量控制类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of flow control of the serial interface."),defArg("奇偶校验", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parity of the serial interface."),defArg("停止位", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of stop bits of the serial interface."),defArg("总超时时间", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Total timeout of the serial interface in ms."),defArg("字符间超时", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Inter-character timeout of the serial interface in ms.")};
defARGINFO __arg_get_shape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("显示形状", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current region output shape.")};
defARGINFO __arg_get_size_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of rows of the matrix."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of columns of the matrix.")};
defARGINFO __arg_get_socket_descriptor [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("套接字描述符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Socket descriptor used by the operating system.")};
defARGINFO __arg_get_socket_param [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the socket parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the socket parameter.")};
defARGINFO __arg_get_socket_timeout [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("超时时间", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Socket timeout.")};
defARGINFO __arg_get_spy [] = {defArg("控制模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Control mode"),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "State of the control mode.")};
defARGINFO __arg_get_string_extents [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values to consider."),defArg("基线最大高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum height above baseline."),defArg("基线下的最大扩展", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum extension below baseline."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Text width."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Text height.")};
defARGINFO __arg_get_sub_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper row position of the sub-matrix in the input matrix."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Left column position of the sub-matrix in the input matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of rows of the sub-matrix."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns of the sub-matrix."),defArg("子矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle of the sub-matrix.")};
defARGINFO __arg_get_support_vector_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("支持向量索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of stored support vectors."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the support vector in the training set.")};
defARGINFO __arg_get_support_vector_num_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("支持向量个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Total number of support vectors."),defArg("支持向量子向量数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of SV of each sub-SVM.")};
defARGINFO __arg_get_system [] = {defArg("查询", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired system parameter."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Current value of the system parameter.")};
defARGINFO __arg_get_system_time [] = {defArg("毫秒", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Milliseconds (0..999)."),defArg("秒", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Seconds (0..59)."),defArg("分钟", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minutes (0..59)."),defArg("小时", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hours (0..23)."),defArg("以月为单位的天", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Day of the month (1..31)."),defArg("以年为单位的天", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Day of the year (1..366)."),defArg("月", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Month (1..12)."),defArg("年", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Year (xxxx).")};
defARGINFO __arg_get_text_object [] = {defArg("字符", dataTypeObj, 0, AS_RECEIVE_VAR, "Returned result."),defArg("文本结果ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text result."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the result to be returned.")};
defARGINFO __arg_get_text_result [] = {defArg("图像结果ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text result."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the result to be returned."),defArg("结果值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of ResultName.")};
defARGINFO __arg_get_threading_attrib [] = {defArg("线程句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Threading object."),defArg("线程类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Class name of threading object."),defArg("属性名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of an attribute."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the attribute.")};
defARGINFO __arg_get_tposition [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of text cursor position."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of text cursor position.")};
defARGINFO __arg_get_tshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("光标名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the current text cursor.")};
defARGINFO __arg_get_value_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row numbers of matrix elements to be returned."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column numbers of matrix elements to be returned."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of indicated matrix elements.")};
defARGINFO __arg_get_window_attr [] = {defArg("属性名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the attribute that should be returned."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Attribute value.")};
defARGINFO __arg_get_window_background_image [] = {defArg("背景图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Copy of the background image."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "HALCON Window ID.")};
defARGINFO __arg_get_window_extents [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row index of upper left corner of the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of upper left corner of the window."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window width."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window height.")};
defARGINFO __arg_get_window_param [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the parameter.")};
defARGINFO __arg_get_window_pointer3 [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("红通道", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer on red channel of pixel data."),defArg("绿通道", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer on green channel of pixel data."),defArg("蓝通道", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pointer on blue channel of pixel data."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of an image line."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of image lines.")};
defARGINFO __arg_get_window_type [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("窗口类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window type")};
defARGINFO __arg_get_y_value_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("x", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinate at which the function should be evaluated."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment for the input function."),defArg("y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y value at the given x value.")};
defARGINFO __arg_give_bg_esti [] = {defArg("背景图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Estimated background image of the current data set."),defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set.")};
defARGINFO __arg_gnuplot_close [] = {defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Identifier for the gnuplot output stream.")};
defARGINFO __arg_gnuplot_open_file [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Base name for control and data files."),defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Identifier for the gnuplot output stream.")};
defARGINFO __arg_gnuplot_open_pipe [] = {defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Identifier for the gnuplot output stream.")};
defARGINFO __arg_gnuplot_plot_ctrl [] = {defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Identifier for the gnuplot output stream."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Control values to be plotted (y-values).")};
defARGINFO __arg_gnuplot_plot_funct_1d [] = {defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Identifier for the gnuplot output stream."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Function to be plotted.")};
defARGINFO __arg_gnuplot_plot_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be plotted."),defArg("gnuplot文件ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Identifier for the gnuplot output stream."),defArg("样品的X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of samples in the x-direction."),defArg("样品Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of samples in the y-direction."),defArg("查看腐X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the plot about the x-axis."),defArg("查看腐Z", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the plot about the z-axis."),defArg("hidden3 D", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Plot the image with hidden surfaces removed.")};
defARGINFO __arg_golay_elements [] = {defArg("结构元素1", dataTypeObj, 0, AS_RECEIVE_VAR, "Structuring element for the foreground."),defArg("结构元素2", dataTypeObj, 0, AS_RECEIVE_VAR, "Structuring element for the background."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the structuring element."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point.")};
defARGINFO __arg_grab_data [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Grabbed image data."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Preprocessed image regions."),defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Preprocessed XLD contours."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Preprocessed control data.")};
defARGINFO __arg_grab_data_async [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Grabbed image data."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Pre-processed image regions."),defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Pre-processed XLD contours."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("最大延迟", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms]."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pre-processed control data.")};
defARGINFO __arg_grab_image [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Grabbed image."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used.")};
defARGINFO __arg_grab_image_async [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Grabbed image."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("最大延迟", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum tolerated delay between the start of the asynchronous grab and the delivery of the image [ms].")};
defARGINFO __arg_grab_image_start [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("最大延迟", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "This parameter is obsolete and has no effect.")};
defARGINFO __arg_gray_bothat [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Bottom hat image.")};
defARGINFO __arg_gray_closing [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素。", dataTypeObj, 0, 0, "Structuring element."),defArg("关闭灰度值的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-closed image.")};
defARGINFO __arg_gray_closing_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("关闭图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-closed image."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask.")};
defARGINFO __arg_gray_closing_shape [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the minimum gray values are to be calculated."),defArg("闭合图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the minimum gray values."),defArg("掩模高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩膜宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩模的形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the mask.")};
defARGINFO __arg_gray_dilation [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素。", dataTypeObj, 0, 0, "Structuring element."),defArg("膨胀的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-dilated image.")};
defARGINFO __arg_gray_dilation_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the maximum gray values are to be calculated."),defArg("最大值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the maximum gray values."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask.")};
defARGINFO __arg_gray_dilation_shape [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the maximum gray values are to be calculated."),defArg("图像的最大灰度", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the maximum gray values."),defArg("掩模高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩模的形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the mask.")};
defARGINFO __arg_gray_erosion [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-eroded image.")};
defARGINFO __arg_gray_erosion_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the minimum gray values are to be calculated."),defArg("最小值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the minimum gray values."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask.")};
defARGINFO __arg_gray_erosion_shape [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the minimum gray values are to be calculated."),defArg("最小灰度值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the minimum gray values."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩膜形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the mask.")};
defARGINFO __arg_gray_features [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the features."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value sof the features.")};
defARGINFO __arg_gray_histo [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the histogram is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Image the gray value distribution of which is to be calculated."),defArg("出现频率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute frequencies of the gray values."),defArg("区域出现频率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Frequencies, normalized to the area of the region.")};
defARGINFO __arg_gray_histo_abs [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the histogram is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Image the gray value distribution of which is to be calculated."),defArg("量化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Quantization of the gray values."),defArg("绝对频率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute frequencies of the gray values.")};
defARGINFO __arg_gray_histo_range [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the histogram is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("最小灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum gray value."),defArg("最大灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum gray value."),defArg("灰度值宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of bins."),defArg("分布值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Histogram to be calculated."),defArg("宽度大小", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Bin size.")};
defARGINFO __arg_gray_inside [] = {defArg("图像", dataTypeObj, 0, 0, "Image being processed."),defArg("结果图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image.")};
defARGINFO __arg_gray_opening [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素。", dataTypeObj, 0, 0, "Structuring element."),defArg("开运算图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-opened image.")};
defARGINFO __arg_gray_opening_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("开运算后图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray-opened image."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask.")};
defARGINFO __arg_gray_opening_shape [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the minimum gray values are to be calculated."),defArg("开运算结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the minimum gray values."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩码形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape of the mask.")};
defARGINFO __arg_gray_range_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the gray value range is to be calculated."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the gray value range."),defArg("掩模高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("掩膜宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask.")};
defARGINFO __arg_gray_skeleton [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be thinned."),defArg("灰度图骨架", dataTypeObj, 0, AS_RECEIVE_VAR, "Thinned image.")};
defARGINFO __arg_gray_tophat [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Top hat image.")};
defARGINFO __arg_hamming_change_region [] = {defArg("输入区域", dataTypeObj, 0, 0, "Region to be modified."),defArg("输出区", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions having the required Hamming distance."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the region to be changed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the region to be changed."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Hamming distance between the old and new regions.")};
defARGINFO __arg_hamming_distance [] = {defArg("区域1", dataTypeObj, 0, 0, "Regions to be examined."),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hamming distance of two regions."),defArg("相似度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Similarity of two regions.")};
defARGINFO __arg_hamming_distance_norm [] = {defArg("区域1", dataTypeObj, 0, 0, "Regions to be examined."),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions."),defArg("标准化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of normalization."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hamming distance of two regions."),defArg("相似度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Similarity of two regions.")};
defARGINFO __arg_harmonic_interpolation [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("精度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computational accuracy.")};
defARGINFO __arg_highpass_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("高通", dataTypeObj, 0, AS_RECEIVE_VAR, "High-pass-filtered result image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask.")};
defARGINFO __arg_histo_2dim [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the histogram is to be calculated."),defArg("图像1", dataTypeObj, 0, 0, "Channel 1."),defArg("图像2", dataTypeObj, 0, 0, "Channel 2."),defArg("分布图", dataTypeObj, 0, AS_RECEIVE_VAR, "Histogram to be calculated.")};
defARGINFO __arg_histo_to_thresh [] = {defArg("直方图", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Gray value histogram."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma for the Gaussian smoothing of the histogram."),defArg("最小阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum thresholds."),defArg("最大阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum thresholds.")};
defARGINFO __arg_hit_or_miss [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素1", dataTypeObj, 0, 0, "Erosion mask for the input regions."),defArg("结构元素2", dataTypeObj, 0, 0, "Erosion mask for the complements of the input regions."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the hit-or-miss operation."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point.")};
defARGINFO __arg_hit_or_miss_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the hit-or-miss operation."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_hit_or_miss_seq [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("击中区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the hit-or-miss operation."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet.")};
defARGINFO __arg_hom_mat2d_compose [] = {defArg("左矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Left input transformation matrix."),defArg("右矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Right input transformation matrix."),defArg("组合的结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_determinant [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("行列式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Determinant of the input matrix.")};
defARGINFO __arg_hom_mat2d_identity [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix.")};
defARGINFO __arg_hom_mat2d_invert [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("矩阵逆", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_reflect [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("轴点x1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First point of the axis (x coordinate)."),defArg("轴点y1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First point of the axis (y coordinate)."),defArg("轴点x2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second point of the axis (x coordinate)."),defArg("轴点y2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second point of the axis (y coordinate)."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_reflect_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("轴坐标x", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point that defines the axis (x coordinate)."),defArg("轴坐标y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point that defines the axis (y coordinate)."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_rotate [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("旋转角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("x", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (x coordinate)."),defArg("y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (y coordinate)."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_rotate_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("旋转角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_scale [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the x-axis."),defArg("y缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the y-axis."),defArg("固定点x", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (x coordinate)."),defArg("固定点y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (y coordinate)."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_scale_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the x-axis."),defArg("y缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the y-axis."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_slant [] = {defArg("齐次二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("倾斜角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Slant angle."),defArg("倾斜的坐标轴", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Coordinate axis that is slanted."),defArg("X点的变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (x coordinate)."),defArg("Y点的变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (y coordinate)."),defArg("其次倾斜二维矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_slant_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Slant angle."),defArg("轴", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Coordinate axis that is slanted."),defArg("输出变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_to_affine_par [] = {defArg("2d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x缩放因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scaling factor along the x direction."),defArg("y缩放因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scaling factor along the y direction."),defArg("旋转角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle."),defArg("倾斜角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Slant angle."),defArg("x平移", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Translation along the x direction."),defArg("y平移", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Translation along the y direction.")};
defARGINFO __arg_hom_mat2d_translate [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the x-axis."),defArg("y平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the y-axis."),defArg("结果矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_translate_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the x-axis."),defArg("y平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the y-axis."),defArg("结果变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat2d_transpose [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("转置", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_compose [] = {defArg("变换矩阵左", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Left input transformation matrix."),defArg("变换矩阵右", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Right input transformation matrix."),defArg("组成的变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_determinant [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("行列式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Determinant of the input matrix.")};
defARGINFO __arg_hom_mat3d_identity [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix.")};
defARGINFO __arg_hom_mat3d_invert [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("变换后矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_project [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "33D transformation matrix."),defArg("主点行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the principal point."),defArg("主点列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the principal point."),defArg("焦距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Focal length in pixels."),defArg("2d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix.")};
defARGINFO __arg_hom_mat3d_rotate [] = {defArg("齐次三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("旋转轴", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Axis, to be rotated around."),defArg("X点的变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (x coordinate)."),defArg("Y点的变换", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (y coordinate)."),defArg("Z点的变幻", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (z coordinate)."),defArg("旋转的齐次三维矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_rotate_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("旋转角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("旋转轴", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Axis, to be rotated around."),defArg("旋转后的变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_scale [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("sx", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the x-axis."),defArg("sy", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the y-axis."),defArg("sz", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the z-axis."),defArg("px", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (y coordinate)."),defArg("pz", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fixed point of the transformation (z coordinate)."),defArg("坎dscale mat3", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_scale_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("sx", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the x-axis."),defArg("sy", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the y-axis."),defArg("sz", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor along the z-axis."),defArg("变换后的矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_to_pose [] = {defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous transformation matrix."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Equivalent 3D pose.")};
defARGINFO __arg_hom_mat3d_translate [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the x-axis."),defArg("y平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the y-axis."),defArg("z平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the z-axis."),defArg("输出变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_translate_local [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("x平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the x-axis."),defArg("y平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the y-axis."),defArg("z平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation along the z-axis."),defArg("输出的变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hom_mat3d_transpose [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input transformation matrix."),defArg("输出变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_hough_circles [] = {defArg("区域", dataTypeObj, 0, 0, "Binary edge image in which the circles are to be detected."),defArg("区域输出", dataTypeObj, 0, AS_RECEIVE_VAR, "Centres of those circles which are included in the edge image by Percent percent."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be searched in the image."),defArg("百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indicates the percentage (approximately) of the (ideal) circle which must be present in the edge image RegionIn."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The modus defines the position of the circle in question: 0 - the radius is equivalent to the outer border of the set pixels. 1 - the radius is equivalent to the centres of the circle lines pixels. 2 - both 0 and 1 (a little more fuzzy, but more reliable in contrast to circles set slightly differently, necessitates 50 % more processing capacity compared to 0 or 1 alone).")};
defARGINFO __arg_hough_circle_trans [] = {defArg("区域", dataTypeObj, 0, 0, "Binary edge image in which the circles are to be detected."),defArg("霍夫图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Hough transform for circles with a given radius."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be searched in the image.")};
defARGINFO __arg_hough_lines [] = {defArg("区域", dataTypeObj, 0, 0, "Binary edge image in which the lines are to be detected."),defArg("角分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adjusting the resolution in the angle area."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold value in the Hough image."),defArg("角度间隙", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimal distance of two maxima in the Hough image (direction: angle)."),defArg("距离间隙", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimal distance of two maxima in the Hough image (direction: distance)."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles (in radians) of the detected lines' normal vectors."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the detected lines from the origin.")};
defARGINFO __arg_hough_lines_dir [] = {defArg("方向图像", dataTypeObj, 0, 0, "Image containing the edge direction. The edges are described by the image domain."),defArg("霍夫图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Hough transform."),defArg("线输出", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions of the input image that contributed to the local maxima."),defArg("方向的不确定性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Uncertainty of edge direction (in degrees)."),defArg("角分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Resolution in the angle area (in 1/degrees)."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing filter for hough image."),defArg("滤波器大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required smoothing filter size."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold value in the Hough image."),defArg("角度间隙", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum distance of two maxima in the Hough image (direction: angle)."),defArg("距离间隙", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum distance of two maxima in the Hough image (direction: distance)."),defArg("线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Create line regions if 'true'."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles (in radians) of the detected lines' normal vectors."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the detected lines from the origin.")};
defARGINFO __arg_hough_line_trans [] = {defArg("区域", dataTypeObj, 0, 0, "Binary edge image in which lines are to be detected."),defArg("霍夫图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Hough transform for lines."),defArg("角分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adjusting the resolution in the angle area.")};
defARGINFO __arg_hough_line_trans_dir [] = {defArg("方向图像", dataTypeObj, 0, 0, "Image containing the edge direction. The edges must be described by the image domain."),defArg("霍夫图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Hough transform."),defArg("方向的不确定性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Uncertainty of the edge direction (in degrees)."),defArg("角分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Resolution in the angle area (in 1/degrees).")};
defARGINFO __arg_hysteresis_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("分割的滞后区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented region."),defArg("低阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the gray values."),defArg("高阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the gray values."),defArg("最大长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum length of a path of \"potential\" points to reach a \"secure\" point.")};
defARGINFO __arg_illuminate [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be enhanced."),defArg("图像说明", dataTypeObj, 0, AS_RECEIVE_VAR, "\"Illuminated\" image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of low pass mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of low pass mask."),defArg("系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scales the \"correction gray value\" added to the original gray values.")};
defARGINFO __arg_image_to_channels [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel image to be decomposed."),defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated one-channel images.")};
defARGINFO __arg_info_edges [] = {defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the edge operator."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "1D edge filter ('edge') or 1D smoothing filter ('smooth')."),defArg("滤波器系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny')."),defArg("尺寸", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Filter width in pixels."),defArg("系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "For Canny filters: Coefficients of the \"positive\" half of the 1D impulse response.")};
defARGINFO __arg_info_framegrabber [] = {defArg("接口名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "HALCON image acquisition interface name, i.e., name of the corresponding DLL (Windows) or shared library (Linux/OS X)."),defArg("查找信息", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the chosen query."),defArg("输出数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Textual information (according to Query)."),defArg("数据列表", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of values (according to Query).")};
defARGINFO __arg_info_parallels_xld [] = {defArg("并行", dataTypeObj, 0, 0, "Input XLD Parallels."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray value image."),defArg("最小的品质因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum quality factor."),defArg("最大的品质因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum quality factor."),defArg("最小的灰度均值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum mean gray value."),defArg("最大的灰度均值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum mean gray value."),defArg("最小标准偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum standard deviation."),defArg("最大标准偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum standard deviation.")};
defARGINFO __arg_info_smooth [] = {defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of required filter."),defArg("阿尔法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values effect strong smoothing (reversed in case of 'gauss')."),defArg("大小", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of filter is approx. size x size pixels."),defArg("系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "In case of gauss filter: coefficients of the \"positive\" half of the 1D impulse answer.")};
defARGINFO __arg_init_compute_device [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle."),defArg("操作", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of operators to prepare.")};
defARGINFO __arg_inner_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of the center."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radius of the inner circle.")};
defARGINFO __arg_inner_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be examined."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the upper left corner point."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the upper left corner point."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the lower right corner point."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the lower right corner point.")};
defARGINFO __arg_inpainting_aniso [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of edge sharpening algorithm."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Contrast parameter."),defArg("θ", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step size."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("Rho", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing coefficient for edge information.")};
defARGINFO __arg_inpainting_ced [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing for derivative operator."),defArg("平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing for diffusion coefficients."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_inpainting_ct [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("邻域半径。", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the pixel neighborhood."),defArg("清晰度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sharpness parameter in percent."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pre-smoothing parameter."),defArg("方向估计", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing parameter for the direction estimation."),defArg("信道系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Channel weights.")};
defARGINFO __arg_inpainting_mcf [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing for derivative operator."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_inpainting_texture [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, 0, "Inpainting region."),defArg("修复图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the inpainting blocks."),defArg("搜索大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the search window."),defArg("各向异性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the edge amplitude on the inpainting order."),defArg("迭代后", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Post-iteration for artifact reduction."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value tolerance for post-iteration.")};
defARGINFO __arg_inspect_shape_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像金字塔", dataTypeObj, 0, AS_RECEIVE_VAR, "Image pyramid of the input image"),defArg("模型区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Model region pyramid"),defArg("金字塔级数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the image and optionally minimum size of the object parts.")};
defARGINFO __arg_integer_to_obj [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Created objects."),defArg("代理对象", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple of object surrogates.")};
defARGINFO __arg_integrate_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("正例", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area under the positive part of the function."),defArg("负例", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Area under the negative part of the function.")};
defARGINFO __arg_intensity [] = {defArg("区域", dataTypeObj, 0, 0, "Regions in which the features are calculated."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("平均灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean gray value of a region."),defArg("偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Deviation of gray values within a region.")};
defARGINFO __arg_interjacent [] = {defArg("区域", dataTypeObj, 0, 0, "Regions for which the separating lines are to be determined."),defArg("中间区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region containing the separating lines."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of operation.")};
defARGINFO __arg_interpolate_scattered_data [] = {defArg("散乱数据插值句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the scattered data interpolator"),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of points to be interpolated"),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of points to be interpolated"),defArg("值插值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of interpolated points")};
defARGINFO __arg_interpolate_scattered_data_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to interpolate"),defArg("插值区域", dataTypeObj, 0, 0, "Region to interpolate"),defArg("插值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Interpolated image"),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the interpolation"),defArg("参数名词", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted")};
defARGINFO __arg_interpolate_scattered_data_points_to_image [] = {defArg("插值图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Interpolated image"),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the interpolation"),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the points used for the interpolation"),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the points used for the interpolation"),defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the points used for the interpolation"),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the interpolated image"),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the interpolated image"),defArg("参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted")};
defARGINFO __arg_intersection [] = {defArg("区域1", dataTypeObj, 0, 0, "Regions to be intersected with all regions in Region2."),defArg("区域2", dataTypeObj, 0, 0, "Regions with which Region1 is intersected."),defArg("交集区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the intersection.")};
defARGINFO __arg_intersection_circles [] = {defArg("圆1行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the first circle or circular arc."),defArg("圆1列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the first circle or circular arc."),defArg("圆1半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the first circle or circular arc."),defArg("圆1起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point of the first circle or circular arc [rad]."),defArg("圆1终止角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point of the first circle or circular arc [rad]."),defArg("圆1点顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the first circle or circular arc."),defArg("圆2行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the second circle or circular arc."),defArg("圆2列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the second circle or circular arc."),defArg("圆2半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the second circle or circular arc."),defArg("圆2起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point of the second circle or circular arc [rad]."),defArg("圆2终止角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point of the second circle or circular arc [rad]."),defArg("圆2点顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the second circle or circular arc."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Do both circles or circular arcs have a part in common?")};
defARGINFO __arg_intersection_circle_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contour."),defArg("圆心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the circle or circular arc."),defArg("圆心列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the circle or circular arc."),defArg("圆半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle or circular arc."),defArg("圆起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point of the circle or circular arc [rad]."),defArg("圆终止角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point of the circle or circular arc [rad]."),defArg("界点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the circle or circular arc."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points.")};
defARGINFO __arg_intersection_closed_contours_xld [] = {defArg("轮廓1", dataTypeObj, 0, 0, "Contours enclosing the first region to be intersected."),defArg("轮廓2", dataTypeObj, 0, 0, "Contours enclosing the second region to be intersected."),defArg("轮廓交集", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours enclosing the intersection.")};
defARGINFO __arg_intersection_closed_polygons_xld [] = {defArg("多边形1", dataTypeObj, 0, 0, "Polygons enclosing the first region to be intersected."),defArg("多边形2", dataTypeObj, 0, 0, "Polygons enclosing the second region to be intersected."),defArg("多边形交集", dataTypeObj, 0, AS_RECEIVE_VAR, "Polygons enclosing the intersection.")};
defARGINFO __arg_intersection_contours_xld [] = {defArg("轮廓1", dataTypeObj, 0, 0, "First XLD contour."),defArg("轮廓2", dataTypeObj, 0, 0, "Second XLD contour."),defArg("交叉类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Intersection points to be returned."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Does a part of a contour lies above another contour part?")};
defARGINFO __arg_intersection_lines [] = {defArg("线1行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the first line."),defArg("线1列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the first line."),defArg("线1行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the first line."),defArg("线1列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the first line."),defArg("线2行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the second line."),defArg("线2列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the second line."),defArg("线2行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the second line."),defArg("线2列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the second line."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the intersection point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the intersection point."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Are both lines identical?")};
defARGINFO __arg_intersection_line_circle [] = {defArg("线行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("线列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("线行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("线列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("圆心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the circle or circular arc."),defArg("圆心列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the circle or circular arc."),defArg("圆半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle or circular arc."),defArg("圆起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point of the circle or circular arc [rad]."),defArg("圆终止角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point of the circle or circular arc [rad]."),defArg("圆点顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the circle or circular arc."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points.")};
defARGINFO __arg_intersection_line_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contour."),defArg("线行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("线列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("线行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("线列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Does a part of the XLD contour lies on the line?")};
defARGINFO __arg_intersection_ll [] = {defArg("行A1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the first line."),defArg("柱A1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the first line."),defArg("排A2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the first line."),defArg("柱A2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the first line."),defArg("行B1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the second line."),defArg("柱B1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the second line."),defArg("行B2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the second line."),defArg("柱B2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the second line."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the intersection point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the intersection point."),defArg("是否平行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Are the two lines parallel?")};
defARGINFO __arg_intersection_segments [] = {defArg("分段1行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the first segment."),defArg("分段1列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the first segment."),defArg("分段1行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the first segment."),defArg("分段1列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the first segment."),defArg("分段2行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the second segment."),defArg("分段2列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the second segment."),defArg("分段2行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the second segment."),defArg("分段2列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the second segment."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the intersection point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the intersection point."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Do both segments have a part in common?")};
defARGINFO __arg_intersection_segment_circle [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the segment."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the segment."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the segment."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the segment."),defArg("圆心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the circle or circular arc."),defArg("圆心列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the circle or circular arc."),defArg("圆半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle or circular arc."),defArg("圆起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the start point of the circle or circular arc [rad]."),defArg("圆终止角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the end point of the circle or circular arc [rad]."),defArg("圆点顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the circle or circular arc."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points.")};
defARGINFO __arg_intersection_segment_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contour."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the segment."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the segment."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the segment."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the segment."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the intersection points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the intersection points."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Do the segment and the XLD contour have a part in common?")};
defARGINFO __arg_intersection_segment_line [] = {defArg("分段行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the segment."),defArg("分段列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the segment."),defArg("分段行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the segment."),defArg("分段列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the segment."),defArg("线行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point of the line."),defArg("线列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point of the line."),defArg("线行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point of the line."),defArg("线列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point of the line."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the intersection point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the intersection point."),defArg("是否重叠", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Do the segment and the line have a part in common?")};
defARGINFO __arg_invar_fourier_coeff [] = {defArg("系数实部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Real parts of the Fourier coefficients."),defArg("系数虚部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Imaginary parts of the Fourier coefficients."),defArg("归一化系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input of the normalizing coefficients."),defArg("映射类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indicates the level of the affine mappings."),defArg("结果实部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Real parts of the normalized Fourier coefficients."),defArg("结果虚部", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Imaginary parts of the normalized Fourier coefficients.")};
defARGINFO __arg_invert_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("逆函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Inverse of the input function.")};
defARGINFO __arg_invert_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image(s)."),defArg("反转图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image(s) with inverted gray values.")};
defARGINFO __arg_invert_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix."),defArg("E", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of inversion."),defArg("结果矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the inverse matrix.")};
defARGINFO __arg_invert_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix."),defArg("E", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of inversion.")};
defARGINFO __arg_isotropic_diffusion [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("平滑图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the Gauss distribution."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_junctions_skeleton [] = {defArg("区域", dataTypeObj, 0, 0, "Input skeletons."),defArg("端点", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted end points."),defArg("关节点", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted junctions.")};
defARGINFO __arg_kirsch_amp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image.")};
defARGINFO __arg_kirsch_dir [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("边缘角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image.")};
defARGINFO __arg_label_to_region [] = {defArg("标签图像", dataTypeObj, 0, 0, "Label image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions having a constant gray value.")};
defARGINFO __arg_laplace [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("拉普拉斯图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Laplace-filtered result image."),defArg("结果类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the result image, whereas for byte and uint2 the absolute value is used."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of filter mask."),defArg("过滤式掩码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter mask used in the Laplace operator")};
defARGINFO __arg_laplace_of_gauss [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Laplace filtered image."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing parameter of the Gaussian.")};
defARGINFO __arg_learn_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Array of attributes to learn."),defArg("类", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Class to which the array has to be assigned.")};
defARGINFO __arg_learn_ndim_box [] = {defArg("前景", dataTypeObj, 0, 0, "Foreground pixels to be trained."),defArg("背景", dataTypeObj, 0, 0, "Background pixels to be trained (rejection class)."),defArg("多通道图像", dataTypeObj, 0, 0, "Multi-channel training image."),defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier.")};
defARGINFO __arg_learn_ndim_norm [] = {defArg("前景", dataTypeObj, 0, 0, "Foreground pixels to be trained."),defArg("背景", dataTypeObj, 0, 0, "Background pixels to be trained (rejection class)."),defArg("图像", dataTypeObj, 0, 0, "Multi-channel training image."),defArg("度量方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Metric to be used."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum cluster radius."),defArg("最小百分数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The ratio of the number of pixels in a cluster to the total number of pixels (in percent) must be larger than MinNumberPercent (otherwise the cluster is not output)."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cluster radii or half edge lengths."),defArg("中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Coordinates of all cluster centers."),defArg("质量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Overlap of the rejection class with the classified objects (1: no overlap).")};
defARGINFO __arg_learn_sampset_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("关键属性", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the data set to train."),defArg("输出文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the protocol file."),defArg("n个样本", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of arrays of attributes to learn."),defArg("停止错误", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Classification error for termination."),defArg("错误", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Error during the assignment.")};
defARGINFO __arg_length_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of the contour or polygon.")};
defARGINFO __arg_linear_trans_color [] = {defArg("图像", dataTypeObj, 0, 0, "Multichannel input image."),defArg("图像变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel output image."),defArg("颜色变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix for the color values.")};
defARGINFO __arg_line_orientation [] = {defArg("行开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points of the input lines."),defArg("列开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("行结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the ending points of the input lines."),defArg("列结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the input lines.")};
defARGINFO __arg_line_position [] = {defArg("行开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points of the input lines."),defArg("列开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("行结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the ending points of the input lines."),defArg("列结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines."),defArg("行中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the centers of gravity of the input lines."),defArg("列中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the centers of gravity of the input lines."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Euclidean length of the input lines."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the input lines.")};
defARGINFO __arg_list_files [] = {defArg("目录", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of directory to be listed."),defArg("选项", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Processing options."),defArg("文件夹", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Found files (and directories).")};
defARGINFO __arg_load_par_knowledge [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of parallelization knowledge file.")};
defARGINFO __arg_local_max [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("局部极大值", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted local maxima as a region.")};
defARGINFO __arg_local_max_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contours to be examined."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray value image."),defArg("局部最大轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Selected contours."),defArg("最小百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum percentage of maximum points."),defArg("最小差异", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum amount by which the gray value at the maximum must be larger than in the profile."),defArg("距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum width of profile used to check for maxima.")};
defARGINFO __arg_local_max_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the calculation of the partial derivatives."),defArg("西格玛", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum absolute value of the eigenvalues of the Hessian matrix."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected maxima."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected maxima.")};
defARGINFO __arg_local_min [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be processed."),defArg("局部极小值", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted local minima as regions.")};
defARGINFO __arg_local_min_max_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function"),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Handling of plateaus"),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation of the input function"),defArg("最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum points of the input function"),defArg("最大值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum points of the input function")};
defARGINFO __arg_local_min_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the calculation of the partial derivatives."),defArg("西格玛", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum absolute value of the eigenvalues of the Hessian matrix."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected minima."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected minima.")};
defARGINFO __arg_local_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input Image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented output region."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Segmentation method."),defArg("保留暗部或亮部？", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extract foreground or background?"),defArg("参数明列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of generic parameter names."),defArg("参数值列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of generic parameter values.")};
defARGINFO __arg_lock_mutex [] = {defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object.")};
defARGINFO __arg_log_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("对数图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("基", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Base of the logarithm.")};
defARGINFO __arg_lowlands [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be processed."),defArg("低地", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted lowlands as regions (one region for each lowland).")};
defARGINFO __arg_lowlands_center [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be processed."),defArg("低地", dataTypeObj, 0, AS_RECEIVE_VAR, "Centers of gravity of the extracted lowlands as regions (one region for each lowland).")};
defARGINFO __arg_lut_trans [] = {defArg("图像", dataTypeObj, 0, 0, "Image whose gray values are to be transformed."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed image."),defArg("查找表", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Table containing the transformation.")};
defARGINFO __arg_make_dir [] = {defArg("目录名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of directory to be created.")};
defARGINFO __arg_map_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be mapped."),defArg("映射数据", dataTypeObj, 0, 0, "Image containing the mapping data."),defArg("图像映射", dataTypeObj, 0, AS_RECEIVE_VAR, "Mapped image.")};
defARGINFO __arg_match_fourier_coeff [] = {defArg("系数1实部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Real parts of the pattern Fourier coefficients."),defArg("系数1虚部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Imaginary parts of the pattern Fourier coefficients."),defArg("系数2实部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Real parts of the Fourier coefficients to be compared."),defArg("系数2虚部", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Imaginary parts of the Fourier coefficients to be compared."),defArg("最大系数个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Total number of Fourier coefficients."),defArg("衰减", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of attenuation."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Similarity of the contours.")};
defARGINFO __arg_match_funct_1d_trans [] = {defArg("函数1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Function 1."),defArg("函数2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Function 2."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment for function 2."),defArg("参数常量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the parameters to remain constant."),defArg("使用参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should a parameter be adapted for it?"),defArg("参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation parameters between the functions."),defArg("卡方", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Quadratic error of the output function."),defArg("协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance Matrix of the transformation parameters.")};
defARGINFO __arg_max_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Image(s) 2."),defArg("最大的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the maximization.")};
defARGINFO __arg_max_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("最大测定类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of maximum determination."),defArg("结果矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the maximum values of the input matrix.")};
defARGINFO __arg_max_parallels_xld [] = {defArg("合并XLD的平行线", dataTypeObj, 0, 0, "Extended XLD parallels."),defArg("最大的多边形", dataTypeObj, 0, AS_RECEIVE_VAR, "Maximally extended parallels.")};
defARGINFO __arg_mean_curvature_flow [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("平滑参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing parameter for derivative operator."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_mean_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of filter mask.")};
defARGINFO __arg_mean_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("平均值类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of mean determination."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the mean values of the input matrix.")};
defARGINFO __arg_mean_n [] = {defArg("图像", dataTypeObj, 0, 0, "Multichannel gray image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of averaging.")};
defARGINFO __arg_mean_sp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of filter mask."),defArg("最小阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum gray value."),defArg("最大阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum gray value.")};
defARGINFO __arg_median_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("图像中值", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("掩码型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter mask type."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the filter mask."),defArg("边缘", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_median_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("图像中值", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask.")};
defARGINFO __arg_median_separate [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Median filtered image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of rank mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of rank mask."),defArg("边缘", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_median_weighted [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("图像wmedian", dataTypeObj, 0, AS_RECEIVE_VAR, "Median filtered image."),defArg("掩码型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of median mask."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "mask size.")};
defARGINFO __arg_merge_cont_line_scan_xld [] = {defArg("当前轮廓", dataTypeObj, 0, 0, "Current input contours."),defArg("前一次轮廓", dataTypeObj, 0, 0, "Merged contours from the previous iteration."),defArg("当前合并数", dataTypeObj, 0, AS_RECEIVE_VAR, "Current contours, merged with old ones where applicable."),defArg("前一次的合并数", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours from the previous iteration which could not be merged with the current ones."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the line scan images."),defArg("幅度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of contours from the image border."),defArg("合并边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image line of the current image, which touches the previous image."),defArg("最大的图像轮廓", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of images covered by one contour.")};
defARGINFO __arg_merge_regions_line_scan [] = {defArg("当前区域", dataTypeObj, 0, 0, "Current input regions."),defArg("前一个区域", dataTypeObj, 0, 0, "Merged regions from the previous iteration."),defArg("当前合并区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Current regions, merged with old ones where applicable."),defArg("前一个合并区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions from the previous iteration which could not be merged with the current ones."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the line scan images."),defArg("合并边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image line of the current image, which touches the previous image."),defArg("最大图像区域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of images for a single region.")};
defARGINFO __arg_midrange_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("掩码", dataTypeObj, 0, 0, "Filter mask."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_minkowski_add1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_minkowski_add2 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be dilated."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Dilated regions."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_minkowski_sub1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_minkowski_sub2 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be eroded."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Eroded regions."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_min_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Image(s) 2."),defArg("最小图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the minimization.")};
defARGINFO __arg_min_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("最小测定类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of minimum determination."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the minimum values of the input matrix.")};
defARGINFO __arg_min_max_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Regions, the features of which are to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("阀值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage below (above) the absolute maximum (minimum)."),defArg("最小灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "\"Minimum\" gray value."),defArg("最大灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "\"Maximum\" gray value."),defArg("偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Difference between Max and Min.")};
defARGINFO __arg_mirror_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("镜像", dataTypeObj, 0, AS_RECEIVE_VAR, "Reflected image."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Axis of reflection.")};
defARGINFO __arg_mirror_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be reflected."),defArg("镜像后区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Reflected region(s)."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Axis of symmetry."),defArg("宽度和高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Twice the coordinate of the axis of symmetry.")};
defARGINFO __arg_mod_parallels_xld [] = {defArg("并行", dataTypeObj, 0, 0, "Input XLD parallels."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray value image."),defArg("改进的并行", dataTypeObj, 0, AS_RECEIVE_VAR, "Modified XLD parallels."),defArg("合并并行", dataTypeObj, 0, AS_RECEIVE_VAR, "Extended XLD parallels."),defArg("品质", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum quality factor (measure of parallelism)."),defArg("最小的灰色均值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum mean gray value."),defArg("最大的灰色均值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum mean gray value."),defArg("最大标准", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum allowed standard deviation.")};
defARGINFO __arg_moments_any_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation mode."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Area enclosed by the contour or polygon."),defArg("中心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the centroid."),defArg("中心列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the centroid."),defArg("P", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First index of the desired moments M[P,Q]."),defArg("Q", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second index of the desired moments M[P,Q]."),defArg("M", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The computed moments.")};
defARGINFO __arg_moments_any_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation mode."),defArg("点顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Point order along the boundary."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Area enclosed by the contour or polygon."),defArg("中心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the centroid."),defArg("中心行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the centroid."),defArg("P", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "First index of the desired moments M[P,Q]."),defArg("Q", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Second index of the desired moments M[P,Q]."),defArg("M", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The computed moments.")};
defARGINFO __arg_moments_gray_plane [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be checked."),defArg("图像", dataTypeObj, 0, 0, "Corresponding gray values."),defArg("Y矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed moments along a line."),defArg("X矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed moments along a column."),defArg("Alpha值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Alpha of the approximating plane."),defArg("Beta值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter Beta of the approximating plane."),defArg("平均灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean gray value.")};
defARGINFO __arg_moments_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("M11", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed second order moment."),defArg("M20", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second order moment along the row axis."),defArg("M02", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second order moment along the column axis.")};
defARGINFO __arg_moments_region_2nd [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions."),defArg("M11", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Product of inertia of the axes through the center parallel to the coordinate axes."),defArg("M20", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order (row-dependent)."),defArg("M02", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order (column-dependent)."),defArg("IA", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of the major axis of the input region."),defArg("IB", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length of the minor axis of the input region.")};
defARGINFO __arg_moments_region_2nd_invar [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("M11", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Product of inertia of the axes through the center parallel to the coordinate axes."),defArg("M20", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order (line-dependent)."),defArg("M02", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order (column-dependent).")};
defARGINFO __arg_moments_region_2nd_rel_invar [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("PHI1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("PHI2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order.")};
defARGINFO __arg_moments_region_3rd [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("M21", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (line-dependent)."),defArg("M12", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (column-dependent)."),defArg("M03", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (column-dependent)."),defArg("M30", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (line-dependent).")};
defARGINFO __arg_moments_region_3rd_invar [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("M21", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (line-dependent)."),defArg("M12", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (column-dependent)."),defArg("M03", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (column-dependent)."),defArg("M30", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order (line-dependent).")};
defARGINFO __arg_moments_region_central [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("I1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("I2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("I3", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("I4", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 3rd order.")};
defARGINFO __arg_moments_region_central_invar [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("PSI1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("PSI2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("psi3", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order."),defArg("psi4", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Moment of 2nd order.")};
defARGINFO __arg_moments_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("M11", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed second order moment."),defArg("M20", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second order moment along the row axis."),defArg("M02", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second order moment along the column axis.")};
defARGINFO __arg_monotony [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the monotony operator.")};
defARGINFO __arg_morph_hat [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position-invariant)."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Union of top hat and bottom hat.")};
defARGINFO __arg_morph_skeleton [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("骨架区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting morphological skeleton.")};
defARGINFO __arg_morph_skiz [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be thinned."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the skiz operator."),defArg("迭代次数1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations for the sequential thinning with the element 'l' of the Golay alphabet."),defArg("迭代次数2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations for the sequential thinning with the element 'e' of the Golay alphabet.")};
defARGINFO __arg_move_contour_orig [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the contour."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the contour."),defArg("行移动", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the displaced contour."),defArg("列移动", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the displaced contour.")};
defARGINFO __arg_move_rectangle [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner of the source rectangle."),defArg("列1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner of the source rectangle."),defArg("行2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of lower right corner of the source rectangle."),defArg("列2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of lower right corner of the source rectangle."),defArg("行距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner of the target position."),defArg("列距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner of the target position.")};
defARGINFO __arg_move_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be moved."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Translated region(s)."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the vector by which the region is to be moved."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the vector by which the region is to be moved.")};
defARGINFO __arg_mult_element_matrix [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the multiplied values of the input matrices.")};
defARGINFO __arg_mult_element_matrix_mod [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B.")};
defARGINFO __arg_mult_image [] = {defArg("图像1", dataTypeObj, 0, 0, "Image(s) 1."),defArg("图像2", dataTypeObj, 0, 0, "Image(s) 2."),defArg("结果图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the product."),defArg("乘数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for gray range adaption."),defArg("加数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value for gray range adaption.")};
defARGINFO __arg_mult_matrix [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the input matrices."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle of the multiplied matrices.")};
defARGINFO __arg_mult_matrix_mod [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the input matrices.")};
defARGINFO __arg_negate_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Function with the negated y values.")};
defARGINFO __arg_new_extern_window [] = {defArg("windows窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Windows window handle of a previously created window."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of upper left corner."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of upper left corner."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the window."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the window."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window identifier.")};
defARGINFO __arg_new_line [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_noise_distribution_mean [] = {defArg("区域", dataTypeObj, 0, 0, "Region from which the noise distribution is to be estimated."),defArg("图像", dataTypeObj, 0, 0, "Corresponding image."),defArg("滤波器大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the mean filter."),defArg("分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Noise distribution of all input regions.")};
defARGINFO __arg_nonmax_suppression_amp [] = {defArg("梯度图像", dataTypeObj, 0, 0, "Amplitude (gradient magnitude) image."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with thinned edge regions."),defArg("非极大值抑制模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select horizontal/vertical or undirected NMS.")};
defARGINFO __arg_nonmax_suppression_dir [] = {defArg("幅度图", dataTypeObj, 0, 0, "Amplitude (gradient magnitude) image."),defArg("方向图", dataTypeObj, 0, 0, "Direction image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with thinned edge regions."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select non-maximum-suppression or interpolating NMS.")};
defARGINFO __arg_norm_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("范数类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of norm."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Norm of the input matrix.")};
defARGINFO __arg_num_points_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of control points.")};
defARGINFO __arg_obj_diff [] = {defArg("对象", dataTypeObj, 0, 0, "Object tuple 1."),defArg("子对象", dataTypeObj, 0, 0, "Object tuple 2."),defArg("差异", dataTypeObj, 0, AS_RECEIVE_VAR, "Objects from Objects that are not part of ObjectsSub.")};
defARGINFO __arg_obj_to_integer [] = {defArg("对象", dataTypeObj, 0, 0, "Objects for which the surrogates are to be returned."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Starting index of the surrogates to be returned."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of surrogates to be returned."),defArg("代理元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple containing the surrogates.")};
defARGINFO __arg_opening [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be opened."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position-invariant)."),defArg("开运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Opened regions.")};
defARGINFO __arg_opening_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be opened."),defArg("开运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Opened regions."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circular structuring element.")};
defARGINFO __arg_opening_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be opened."),defArg("开运算区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Opened regions."),defArg("Golay码元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("循环", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_opening_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be opened."),defArg("开运算的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Opened regions."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the structuring rectangle."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the structuring rectangle.")};
defARGINFO __arg_opening_seg [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be opened."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position-invariant)."),defArg("开运算区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Opened regions.")};
defARGINFO __arg_open_compute_device [] = {defArg("设备标识符", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device Identifier."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Compute device handle.")};
defARGINFO __arg_open_file [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of file to be opened."),defArg("文件类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of file."),defArg("文件句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "File handle.")};
defARGINFO __arg_open_framegrabber [] = {defArg("设备名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "HALCON image acquisition interface name, i.e., name of the corresponding DLL (Windows) or shared library (Linux/OS X)."),defArg("水平解析度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired horizontal resolution of image acquisition interface (absolute value or 1 for full resolution, 2 for half resolution, or 4 for quarter resolution)."),defArg("垂直解析度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired vertical resolution of image acquisition interface (absolute value or 1 for full resolution, 2 for half resolution, or 4 for quarter resolution)."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of desired image part (absolute value or 0 for HorizontalResolution - 2*StartColumn)."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of desired image part (absolute value or 0 for VerticalResolution - 2*StartRow)."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line number of upper left corner of desired image part (or border height if ImageHeight = 0)."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column number of upper left corner of desired image part (or border width if ImageWidth = 0)."),defArg("视野", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired half image or full image."),defArg("通道位数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of transferred bits per pixel and image channel (-1: device-specific default value)."),defArg("色域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Output color format of the grabbed images, typically 'gray' or 'raw' for single-channel or 'rgb' or 'yuv' for three-channel images ('default': device-specific default value)."),defArg("通用参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter with device-specific meaning."),defArg("外部触发", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "External triggering."),defArg("相机接口类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of used camera ('default': device-specific default value)."),defArg("连接装置", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Device the image acquisition device is connected to ('default': device-specific default value)."),defArg("连接端口", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Port the image acquisition device is connected to (-1: device-specific default value)."),defArg("输入线类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera input line of multiplexer (-1: device-specific default value)."),defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the opened image acquisition device.")};
defARGINFO __arg_open_io_channel [] = {defArg("I / O设备的句柄。", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device."),defArg("I/O通道名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "HALCON I/O channel names of the specified device."),defArg("Gen参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter values."),defArg("I / O通道手柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of the opened I/O channel.")};
defARGINFO __arg_open_io_device [] = {defArg("I/O接口名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "HALCON I/O interface name."),defArg("I/O设备名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "I/O device name."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Dynamic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Dynamic parameter values."),defArg("I / O设备手柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the opened I/O device.")};
defARGINFO __arg_open_serial [] = {defArg("端口名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the serial port."),defArg("串行句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Serial interface handle.")};
defARGINFO __arg_open_socket_accept [] = {defArg("端口", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Port number."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the socket."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the socket."),defArg("接受中的套接字号", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Socket number.")};
defARGINFO __arg_open_socket_connect [] = {defArg("主机名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Hostname of the computer to connect to."),defArg("端口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Port number."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the socket."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the socket."),defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Socket number.")};
defARGINFO __arg_open_textwindow [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window's width."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window's height."),defArg("边框宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window border's width."),defArg("边框颜色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window border's color."),defArg("背景颜色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Background color."),defArg("父窗口", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Logical number of the father window. For the display as father you may specify 'root' or 0."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window mode."),defArg("机器码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computer name, where the window has to be opened or empty string."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window identifier.")};
defARGINFO __arg_open_window [] = {defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the window."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the window."),defArg("父窗口", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Logical number of the father window. To specify the display as father you may enter 'root' or 0."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Window mode."),defArg("机器码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the computer on which you want to open the window. Otherwise the empty string."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Window identifier.")};
defARGINFO __arg_optical_flow_mg [] = {defArg("图像T1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像T2", dataTypeObj, 0, 0, "Input image 2."),defArg("向量场", dataTypeObj, 0, AS_RECEIVE_VAR, "Optical flow."),defArg("算法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for computing the optical flow."),defArg("平滑标准差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation for initial Gaussian smoothing."),defArg("积分标准差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Standard deviation of the integration filter."),defArg("流平滑权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the smoothing term relative to the data term."),defArg("梯度稳定性权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the gradient constancy relative to the gray value constancy."),defArg("多重网格算法参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the multigrid algorithm."),defArg("多重网格算法参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the multigrid algorithm.")};
defARGINFO __arg_optimize_aop [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Operators to check"),defArg("标志类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Iconic object types to check"),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Knowledge file name"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value")};
defARGINFO __arg_optimize_fft_speed [] = {defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image for which the runtime should be optimized."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image for which the runtime should be optimized."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Thoroughness of the search for the optimum runtime.")};
defARGINFO __arg_optimize_rft_speed [] = {defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image for which the runtime should be optimized."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image for which the runtime should be optimized."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Thoroughness of the search for the optimum runtime.")};
defARGINFO __arg_orientation_points_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the contours or polygons (radians).")};
defARGINFO __arg_orientation_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("区域方向弧度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of region (arc measure).")};
defARGINFO __arg_orientation_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the contours or polygons (radians).")};
defARGINFO __arg_orthogonal_decompose_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("分解式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method of decomposition."),defArg("输出矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of output matrices."),defArg("计算正交", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of the orthogonal matrix."),defArg("正交矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the orthogonal part of the decomposed input matrix."),defArg("三角阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the triangular part of the decomposed input matrix.")};
defARGINFO __arg_overpaint_gray [] = {defArg("被附加图像", dataTypeObj, 0, 0, "Input image to be painted over."),defArg("附加图像", dataTypeObj, 0, 0, "Input image containing the desired gray values.")};
defARGINFO __arg_overpaint_region [] = {defArg("图像", dataTypeObj, 0, 0, "Image in which the regions are to be painted."),defArg("区域", dataTypeObj, 0, 0, "Regions to be painted into the input image."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired gray values of the regions."),defArg("附加方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Paint regions filled or as boundaries.")};
defARGINFO __arg_paint_gray [] = {defArg("输入图像", dataTypeObj, 0, 0, "Input image containing the desired gray values."),defArg("被绘制图像", dataTypeObj, 0, 0, "Input image to be painted over."),defArg("混合图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image.")};
defARGINFO __arg_paint_region [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be painted into the input image."),defArg("被绘图像", dataTypeObj, 0, 0, "Image in which the regions are to be painted."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the result."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired gray values of the regions."),defArg("填充模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Paint regions filled or as boundaries.")};
defARGINFO __arg_paint_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD objects to be painted into the input image."),defArg("被绘图像", dataTypeObj, 0, 0, "Image in which the xld objects are to be painted."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the result."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired gray value of the xld object.")};
defARGINFO __arg_partition_dynamic [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be partitioned."),defArg("划分区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Partitioned region."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Approximate width of the resulting region parts."),defArg("百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum percental shift of the split position.")};
defARGINFO __arg_partition_lines [] = {defArg("行开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points of the input lines."),defArg("列开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("行结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the ending points of the input lines."),defArg("列结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Features to be used for selection."),defArg("操作", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Desired combination of the features."),defArg("最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limits of the features or 'min'."),defArg("最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limits of the features or 'max'."),defArg("行开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the starting points of the lines fulfilling the conditions."),defArg("列开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the starting points of the lines fulfilling the conditions."),defArg("行结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the ending points of the lines fulfilling the conditions."),defArg("列结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the ending points of the lines fulfilling the conditions."),defArg("失败行开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the starting points of the lines not fulfilling the conditions."),defArg("失败列开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the starting points of the lines not fulfilling the conditions."),defArg("失败行结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the ending points of the lines not fulfilling the conditions."),defArg("失败列结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the ending points of the lines not fulfilling the conditions.")};
defARGINFO __arg_partition_rectangle [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be partitioned."),defArg("划分区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Partitioned region."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the individual rectangles."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the individual rectangles.")};
defARGINFO __arg_phase_correlation_fft [] = {defArg("傅立叶图像1", dataTypeObj, 0, 0, "Fourier-transformed input image 1."),defArg("傅立叶图像2", dataTypeObj, 0, 0, "Fourier-transformed input image 2."),defArg("图像的相位相关", dataTypeObj, 0, AS_RECEIVE_VAR, "Phase correlation of the input images in the frequency domain.")};
defARGINFO __arg_phase_deg [] = {defArg("频域图像", dataTypeObj, 0, 0, "Input image in frequency domain."),defArg("图像相位", dataTypeObj, 0, AS_RECEIVE_VAR, "Phase of the image in degrees.")};
defARGINFO __arg_phase_rad [] = {defArg("频域图像", dataTypeObj, 0, 0, "Input image in frequency domain."),defArg("图像相位", dataTypeObj, 0, AS_RECEIVE_VAR, "Phase of the image in radians.")};
defARGINFO __arg_plane_deviation [] = {defArg("区域", dataTypeObj, 0, 0, "Regions, of which the plane deviation is to be calculated."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("偏差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Deviation of the gray values within a region.")};
defARGINFO __arg_plateaus [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("高原", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted plateaus as regions (one region for each plateau).")};
defARGINFO __arg_plateaus_center [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("高原", dataTypeObj, 0, AS_RECEIVE_VAR, "Centers of gravity of the extracted plateaus as regions (one region for each plateau).")};
defARGINFO __arg_points_foerstner [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("西格玛梯度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used for the calculation of the gradient. If Smoothing is 'mean', SigmaGrad is ignored."),defArg("西格玛混合", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used for the integration of the gradients."),defArg("西格玛点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used in the optimization functions."),defArg("非均匀图像区域阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the segmentation of inhomogeneous image areas."),defArg("形状阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the segmentation of point areas."),defArg("平滑方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Used smoothing method."),defArg("消除双峰", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Elimination of multiply detected points."),defArg("连接点行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected junction points."),defArg("连接点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected junction points."),defArg("协方差矩阵行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row part of the covariance matrix of the detected junction points."),defArg("协方差矩阵混合部分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed part of the covariance matrix of the detected junction points."),defArg("协方差矩阵列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column part of the covariance matrix of the detected junction points."),defArg("区域行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected area points."),defArg("区域列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected area points."),defArg("区域协方差矩阵行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row part of the covariance matrix of the detected area points."),defArg("区域协方差矩阵混合部分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mixed part of the covariance matrix of the detected area points."),defArg("区域协方差矩阵列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column part of the covariance matrix of the detected area points.")};
defARGINFO __arg_points_harris [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("西格玛梯度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used for the calculation of the gradient."),defArg("西格玛平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used for the integration of the gradients."),defArg("阿尔法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the squared trace of the squared gradient matrix."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum filter response for the points."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected points.")};
defARGINFO __arg_points_harris_binomial [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("掩码大小梯度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of binomial smoothing used for the calculation of the gradient."),defArg("掩码尺寸平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of smoothing used for the integration of the gradients."),defArg("阿尔法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the squared trace of the squared gradient matrix."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum filter response for the points."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Turn on or off subpixel refinement."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected points.")};
defARGINFO __arg_points_lepetit [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle."),defArg("领域数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of checked neighbors on the circle."),defArg("最小检测邻近差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold of grayvalue difference to each circle point."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold of grayvalue difference to all circle points."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy of point coordinates."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row-coordinates of the detected points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column-coordinates of the detected points.")};
defARGINFO __arg_points_sojka [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Required filter size."),defArg("西格玛W", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the weight function according to the distance to the corner candidate."),defArg("西格玛D", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the weight function for the distance to the ideal gray value edge."),defArg("最小梯度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the magnitude of the gradient."),defArg("最小外观", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for Apparentness."),defArg("最小角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the direction change in a corner point (radians)."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel precise calculation of the corner points."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected corner points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected corner points.")};
defARGINFO __arg_point_line_to_hom_mat2d [] = {defArg("变换类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the transformation to compute."),defArg("原点x", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("原点y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("线x1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the first point on the corresponding line."),defArg("线y1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the first point on the corresponding line."),defArg("线x2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the second point on the corresponding line."),defArg("线y2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the second point on the corresponding line."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_polar_trans_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("极性反式轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contour."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to the column coordinate 0 of PolarTransContour."),defArg("角端", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to the column coordinate Width-1 of PolarTransContour to."),defArg("起始半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to the row coordinate 0 of PolarTransContour."),defArg("结束半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to the row coordinate Height-1 of PolarTransContour."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual output image.")};
defARGINFO __arg_polar_trans_contour_xld_inv [] = {defArg("极坐标轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("笛卡尔坐标轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contour."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the column coordinate 0 of PolarContour to."),defArg("终止角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the column coordinate WidthIn-1 of PolarContour to."),defArg("起始半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the row coordinate 0 of PolarContour to."),defArg("终止半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the row coordinate HeightIn-1 of PolarContour to."),defArg("输入的图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual input image."),defArg("输入的图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual input image."),defArg("输出的图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual output image."),defArg("输出的图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual output image.")};
defARGINFO __arg_polar_trans_image [] = {defArg("图像XY", dataTypeObj, 0, 0, "Input image in cartesian coordinates."),defArg("图像极性", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image in polar coordinates."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the coordinate system."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the coordinate system."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the result image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the result image.")};
defARGINFO __arg_polar_trans_image_ext [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("配极变换图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to the first column of the output image."),defArg("角端", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to the last column of the output image."),defArg("起始半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to the first row of the output image."),defArg("结束半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to the last row of the output image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation.")};
defARGINFO __arg_polar_trans_image_inv [] = {defArg("极性图像", dataTypeObj, 0, 0, "Input image."),defArg("x和y方向的变换图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the first column of the input image to."),defArg("角端", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the last column of the input image to."),defArg("起始半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the first row of the input image to."),defArg("结束半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the last row of the input image to."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation.")};
defARGINFO __arg_polar_trans_region [] = {defArg("区域", dataTypeObj, 0, 0, "Input region."),defArg("极坐标区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("角开始", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to column coordinate 0 of PolarTransRegion."),defArg("角结束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to be mapped to column coordinate Width-1 of PolarTransRegion."),defArg("半径开始", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to row coordinate 0 of PolarTransRegion."),defArg("半径结束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to be mapped to row coordinate Height-1 of PolarTransRegion."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual output image."),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation.")};
defARGINFO __arg_polar_trans_region_inv [] = {defArg("极性区域", dataTypeObj, 0, 0, "Input region."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the column coordinate 0 of PolarRegion to."),defArg("角结束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the ray to map the column coordinate WidthIn-1 of PolarRegion to."),defArg("半径开始", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the row coordinate 0 of PolarRegion to."),defArg("半径结束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle to map the row coordinate HeightIn-1 of PolarRegion to."),defArg("宽度输入", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual input image."),defArg("高度输入", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual input image."),defArg("宽度输出", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the virtual output image."),defArg("高度输出", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the virtual output image."),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation.")};
defARGINFO __arg_pose_average [] = {defArg("模式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Set of poses of which the average if computed."),defArg("权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Empty tuple, or one weight per pose."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Averaging mode."),defArg("σt", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the translation."),defArg("∑R", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the rotation."),defArg("平均的模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Weighted mean of the poses."),defArg("品质因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Deviation of the mean from the input poses.")};
defARGINFO __arg_pose_compose [] = {defArg("左模式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple containing the left poses."),defArg("右模式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple containing the right poses."),defArg("模式成分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple containing the returned poses.")};
defARGINFO __arg_pose_invert [] = {defArg("模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple of 3D poses."),defArg("模型反转", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple of inverted 3D poses.")};
defARGINFO __arg_pose_to_hom_mat3d [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose."),defArg("齐次3D变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Equivalent homogeneous transformation matrix.")};
defARGINFO __arg_pose_to_quat [] = {defArg("3d姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D Pose."),defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation quaternion.")};
defARGINFO __arg_pouring [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of operation."),defArg("最小的灰色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All gray values smaller than this threshold are disregarded."),defArg("最大的灰色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All gray values larger than this threshold are disregarded.")};
defARGINFO __arg_power_byte [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in frequency domain."),defArg("功率谱", dataTypeObj, 0, AS_RECEIVE_VAR, "Power spectrum of the input image.")};
defARGINFO __arg_power_ln [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in frequency domain."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Power spectrum of the input image.")};
defARGINFO __arg_power_real [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in frequency domain."),defArg("图像结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Power spectrum of the input image.")};
defARGINFO __arg_pow_element_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix of the base."),defArg("指数矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix with exponents."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the raised power of the input matrix.")};
defARGINFO __arg_pow_element_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix of the base."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix with exponents.")};
defARGINFO __arg_pow_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("幂指数图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("指数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Power to which the gray values are raised.")};
defARGINFO __arg_pow_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix."),defArg("幂", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The power."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the raised powered matrix.")};
defARGINFO __arg_pow_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix."),defArg("幂", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The power.")};
defARGINFO __arg_pow_scalar_element_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("幂", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The power."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the raised power of the input matrix.")};
defARGINFO __arg_pow_scalar_element_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("幂", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The power.")};
defARGINFO __arg_prep_contour_fourier [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row indices of the contour."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column indices of the contour."),defArg("参数化模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of parameterization."),defArg("参数化轮廓", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameterized contour.")};
defARGINFO __arg_prewitt_amp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像边缘幅度", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image.")};
defARGINFO __arg_prewitt_dir [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("边缘角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image.")};
defARGINFO __arg_principal_comp [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multichannel input image."),defArg("PCA图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Multichannel output image."),defArg("通道信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information content of each output channel.")};
defARGINFO __arg_projection_pl [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the point."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the point."),defArg("起点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point on the line."),defArg("起点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point on the line."),defArg("终点的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point on the line."),defArg("终点的列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point on the line."),defArg("投影行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the projected point."),defArg("投影列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the projected point")};
defARGINFO __arg_projective_trans_contour_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours."),defArg("轮廓投影变换", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contours."),defArg("齐次二维矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix.")};
defARGINFO __arg_projective_trans_hom_point_3d [] = {defArg("齐次射影变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (y coordinate)."),defArg("pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (z coordinate)."),defArg("pw", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (w coordinate)."),defArg("qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (x coordinate)."),defArg("qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (y coordinate)."),defArg("qz", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (z coordinate)."),defArg("qw", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (w coordinate).")};
defARGINFO __arg_projective_trans_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("变换图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("二维齐次变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation."),defArg("调整图像大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adapt the size of the output image automatically?"),defArg("变换域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the domain of the input image also be transformed?")};
defARGINFO __arg_projective_trans_image_size [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("变换图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("齐次二维矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Output image width."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Output image height."),defArg("变换域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the domain of the input image also be transformed?")};
defARGINFO __arg_projective_trans_pixel [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input pixel(s) (row coordinate)."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Input pixel(s) (column coordinate)."),defArg("输出行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output pixel(s) (row coordinate)."),defArg("输出列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output pixel(s) (column coordinate).")};
defARGINFO __arg_projective_trans_point_2d [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("点x", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (x coordinate)."),defArg("点y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (y coordinate)."),defArg("点w", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (w coordinate)."),defArg("结果点x", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (x coordinate)."),defArg("结果点y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (y coordinate)."),defArg("结果点w", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (w coordinate).")};
defARGINFO __arg_projective_trans_point_3d [] = {defArg("齐次投影变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (y coordinate)."),defArg("pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (z coordinate)."),defArg("qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (x coordinate)."),defArg("qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (y coordinate)."),defArg("qz", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (z coordinate).")};
defARGINFO __arg_projective_trans_region [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Output regions."),defArg("齐次变换矩阵2d", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for the transformation.")};
defARGINFO __arg_project_hom_point_hom_mat3d [] = {defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3projection matrix."),defArg("Px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (y coordinate)."),defArg("Pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (z coordinate)."),defArg("Pw", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (w coordinate)."),defArg("Qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (x coordinate)."),defArg("Qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (y coordinate)."),defArg("Qw", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (w coordinate).")};
defARGINFO __arg_project_point_hom_mat3d [] = {defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3projection matrix."),defArg("Px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (y coordinate)."),defArg("Pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input point (z coordinate)."),defArg("Qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (x coordinate)."),defArg("Qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output point (y coordinate).")};
defARGINFO __arg_pruning [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("修剪区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the pruning operation."),defArg("长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the branches to be removed.")};
defARGINFO __arg_quat_compose [] = {defArg("四元左", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Left quaternion."),defArg("四元右", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Right quaternion."),defArg("组成的四元数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Product of the input quaternions.")};
defARGINFO __arg_quat_conjugate [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input quaternion."),defArg("共轭四元", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Conjugated quaternion.")};
defARGINFO __arg_quat_interpolate [] = {defArg("四元数开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Start quaternion."),defArg("四元数结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "End quaternion."),defArg("差值参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation parameter."),defArg("四元插值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolated quaternion.")};
defARGINFO __arg_quat_normalize [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input quaternion."),defArg("归一化四元数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Normalized quaternion.")};
defARGINFO __arg_quat_rotate_point_3d [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation quaternion."),defArg("px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinate of the point to be rotated."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinate of the point to be rotated."),defArg("pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinate of the point to be rotated."),defArg("qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the rotated point."),defArg("qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the rotated point."),defArg("qz", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the rotated point.")};
defARGINFO __arg_quat_to_hom_mat3d [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation quaternion."),defArg("Rotation矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation matrix.")};
defARGINFO __arg_quat_to_pose [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation quaternion."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D Pose.")};
defARGINFO __arg_query_all_colors [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("颜色名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Color names.")};
defARGINFO __arg_query_aop_info [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Operator to get information for"),defArg("索引名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further specific index"),defArg("索引值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further specific address"),defArg("名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of next index stage"),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of next index stage")};
defARGINFO __arg_query_available_compute_devices [] = {defArg("设备标识符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of available compute devices.")};
defARGINFO __arg_query_color [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("颜色", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Color names.")};
defARGINFO __arg_query_colored [] = {defArg("可能颜色数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple of the possible numbers of colors.")};
defARGINFO __arg_query_contour_attribs_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("属性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of the defined contour attributes.")};
defARGINFO __arg_query_contour_global_attribs_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contour."),defArg("属性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of the defined global contour attributes.")};
defARGINFO __arg_query_font [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("字体", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with available font names.")};
defARGINFO __arg_query_gray [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple of all displayable gray values.")};
defARGINFO __arg_query_insert [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Display function name.")};
defARGINFO __arg_query_io_device [] = {defArg("输入输出设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device."),defArg("输入输出通道名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Channel names to query."),defArg("查询", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the query."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of values (according to Query).")};
defARGINFO __arg_query_io_interface [] = {defArg("IO借口名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "HALCON I/O interface name."),defArg("查询", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name of the query."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of result values (according to Query).")};
defARGINFO __arg_query_line_width [] = {defArg("最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Displayable minimum width."),defArg("最大值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Displayable maximum width.")};
defARGINFO __arg_query_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("查找表", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of look-up-tables.")};
defARGINFO __arg_query_mshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("形状名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Available mouse pointer names.")};
defARGINFO __arg_query_operator_info [] = {defArg("槽", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Slotnames of the operator get_operator_info.")};
defARGINFO __arg_query_paint [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value display mode names.")};
defARGINFO __arg_query_param_info [] = {defArg("槽", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Slotnames for the operator get_param_info.")};
defARGINFO __arg_query_shape [] = {defArg("显示形状", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "region display mode names.")};
defARGINFO __arg_query_spy [] = {defArg("类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Available control modes (see also set_spy)."),defArg("数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Corresponding state of the control modes.")};
defARGINFO __arg_query_tshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("文本光标名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the available text cursors.")};
defARGINFO __arg_query_window_type [] = {defArg("窗口类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of available window types.")};
defARGINFO __arg_rank_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("掩码", dataTypeObj, 0, 0, "Filter mask."),defArg("图像秩", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("秩", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rank of the output gray value."),defArg("边缘", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_rank_n [] = {defArg("图像", dataTypeObj, 0, 0, "Multichannel gray image."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the rank function."),defArg("秩索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rank of the gray value images to return.")};
defARGINFO __arg_rank_rect [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered image."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("秩", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rank of the output gray value.")};
defARGINFO __arg_rank_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be transformed."),defArg("区域数量", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting region(s)."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the filter mask."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the filter mask."),defArg("最小点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum number of points lying within the filter mask.")};
defARGINFO __arg_read_aop_knowledge [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of knowledge file"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value"),defArg("属性", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Knowledge attributes"),defArg("算子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Updated Operators")};
defARGINFO __arg_read_cam_par [] = {defArg("相机文件参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of internal camera parameters."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters.")};
defARGINFO __arg_read_char [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input character (if it is not a control character)."),defArg("代码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Code for input character.")};
defARGINFO __arg_read_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Filename of the classifier.")};
defARGINFO __arg_read_class_gmm [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "GMM handle.")};
defARGINFO __arg_read_class_knn [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name of the classifier."),defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the k-NN classifier.")};
defARGINFO __arg_read_class_mlp [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "MLP handle.")};
defARGINFO __arg_read_class_svm [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "SVM handle.")};
defARGINFO __arg_read_class_train_data [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name of the training data."),defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training data.")};
defARGINFO __arg_read_contour_xld_arc_info [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Read XLD contours."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the ARC/INFO file.")};
defARGINFO __arg_read_contour_xld_dxf [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Read XLD contours."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the DXF file."),defArg("Gen参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the DXF input."),defArg("Gen参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the DXF input."),defArg("文状态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status information.")};
defARGINFO __arg_read_distance_transform_xld [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file."),defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the XLD distance transform.")};
defARGINFO __arg_read_fft_optimization_data [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the optimization data.")};
defARGINFO __arg_read_funct_1d [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file to be read."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Function from the file.")};
defARGINFO __arg_read_gray_se [] = {defArg("结构元素", dataTypeObj, 0, AS_RECEIVE_VAR, "Generated structuring element."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file containing the structuring element.")};
defARGINFO __arg_read_image [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Read image."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the image to be read.")};
defARGINFO __arg_read_io_channel [] = {defArg("输入输出通道句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read value."),defArg("状态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status of read value.")};
defARGINFO __arg_read_kalman [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Description file for a Kalman filter."),defArg("维度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The dimensions of the state vector, the measurement vector and the controller vector."),defArg("模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The lined up matrices A, C, Q, possibly G and u, and if necessary L stored in row-major order."),defArg("测量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The matrix R stored in row-major order."),defArg("预测", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The matrix P0 (error covariance matrix of the initial state estimate) stored in row-major order and the initial state estimate x0 lined up.")};
defARGINFO __arg_read_matrix [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle.")};
defARGINFO __arg_read_object [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Iconic object."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of file.")};
defARGINFO __arg_read_polygon_xld_arc_info [] = {defArg("亚像素多边形对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Read XLD polygons."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the ARC/INFO file.")};
defARGINFO __arg_read_polygon_xld_dxf [] = {defArg("多边形", dataTypeObj, 0, AS_RECEIVE_VAR, "Read XLD polygons."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the DXF file."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the DXF input."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the DXF input."),defArg("dxf文件状态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status information.")};
defARGINFO __arg_read_pose [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the external camera parameters."),defArg("姿势", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose.")};
defARGINFO __arg_read_region [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Read region."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the region to be read.")};
defARGINFO __arg_read_samples_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_read_samples_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_read_samples_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_read_sampset [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filename of the data set to train."),defArg("样本的关键因素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Identification of the data set to train.")};
defARGINFO __arg_read_sequence [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image read."),defArg("文件头大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of bytes for file header."),defArg("源宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of image columns of the filed image."),defArg("源高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of image lines of the filed image."),defArg("起始行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Starting point of image area (line)."),defArg("起始列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Starting point of image area (column)."),defArg("目标宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of image columns of output image."),defArg("目标高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of image lines of output image."),defArg("像素类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of pixel values."),defArg("位顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sequence of bits within one byte."),defArg("字节顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sequence of bytes within one 'short' unit."),defArg("数据行对其数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Data units within one image line (alignment)."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of images in the file."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of input file.")};
defARGINFO __arg_read_serial [] = {defArg("串行句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle."),defArg("字符个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of characters to read."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read characters (as tuple of integers).")};
defARGINFO __arg_read_string [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("输入字符串", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Default string (visible before input)."),defArg("长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of characters."),defArg("输出字符串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Read string.")};
defARGINFO __arg_read_tuple [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file to be read."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with any kind of data.")};
defARGINFO __arg_read_world_file [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the ARC/INFO world file."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformation matrix from image to world coordinates.")};
defARGINFO __arg_real_to_complex [] = {defArg("图像实数", dataTypeObj, 0, 0, "Real part."),defArg("图像虚数", dataTypeObj, 0, 0, "Imaginary part."),defArg("复杂图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Complex image.")};
defARGINFO __arg_real_to_vector_field [] = {defArg("矢量Y", dataTypeObj, 0, 0, "Vector component in the row direction."),defArg("矢量X", dataTypeObj, 0, 0, "Vector component in the column direction."),defArg("矢量域", dataTypeObj, 0, AS_RECEIVE_VAR, "Displacement vector field."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Semantic kind of the vector field.")};
defARGINFO __arg_receive_data [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Specification how to convert the data to tuples."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value (or tuple of values) holding the received and converted data."),defArg("来源IP地址", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "IP address or hostname and network port of the communication partner.")};
defARGINFO __arg_receive_image [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Received image."),defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_receive_region [] = {defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Received regions."),defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_receive_serialized_item [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_receive_tuple [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Received tuple.")};
defARGINFO __arg_receive_xld [] = {defArg("XLD", dataTypeObj, 0, AS_RECEIVE_VAR, "Received XLD object."),defArg("串口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_rectangle1_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with reduced definition domain."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of upper left corner of image area."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner of image area."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of lower right corner of image area."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of lower right corner of image area.")};
defARGINFO __arg_rectangularity [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("矩形", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rectangularity of the input region(s).")};
defARGINFO __arg_reduce_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Original SVM handle."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of postprocessing to reduce number of SV."),defArg("最小剩余支持向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum number of remaining SVs."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum allowed error of reduction."),defArg("减少后的svm句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "SVMHandle of reduced SVM.")};
defARGINFO __arg_reduce_domain [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("新定义域", dataTypeObj, 0, 0, "New definition domain."),defArg("新图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with reduced definition domain.")};
defARGINFO __arg_regiongrowing [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Vertical distance between tested pixels (height of the raster)."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Horizontal distance between tested pixels (height of the raster)."),defArg("容忍误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Points with a gray value difference less then or equal to tolerance are accumulated into the same object."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of the output regions.")};
defARGINFO __arg_regiongrowing_mean [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("开始行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points."),defArg("开始列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points."),defArg("容忍误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum deviation from the mean."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of a region.")};
defARGINFO __arg_regiongrowing_n [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("度量方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Metric for the distance of the feature vectors."),defArg("最小公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the features' distance."),defArg("最大公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the features' distance."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of the output regions.")};
defARGINFO __arg_region_features [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape features to be calculated."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The calculated features.")};
defARGINFO __arg_region_to_bin [] = {defArg("输入区域", dataTypeObj, 0, 0, "Regions to be converted."),defArg("二进制图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image of dimension Width * Height containing the converted regions."),defArg("前景灰度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value in which the regions are displayed."),defArg("背景灰度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value in which the background is displayed."),defArg("图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image to be generated."),defArg("图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image to be generated.")};
defARGINFO __arg_region_to_label [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be converted."),defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image of dimension Width * Height containing the converted regions."),defArg("图像类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pixel type of the result image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image to be generated."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image to be generated.")};
defARGINFO __arg_region_to_mean [] = {defArg("区域", dataTypeObj, 0, 0, "Input regions."),defArg("图像", dataTypeObj, 0, 0, "original gray-value image."),defArg("平均灰度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image with painted regions.")};
defARGINFO __arg_regress_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("回归线", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting XLD contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of outlier treatment."),defArg("迭代", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations for the outlier treatment.")};

defARGINFO __arg_release_compute_device [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle.")};
defARGINFO __arg_remove_dir [] = {defArg("目录名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of directory to be deleted.")};
defARGINFO __arg_remove_noise_region [] = {defArg("输入区域", dataTypeObj, 0, 0, "Regions to be modified."),defArg("输出区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Less noisy regions."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of noise removal.")};
defARGINFO __arg_repeat_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of copies of input matrix in row direction."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of copies of input matrix in column direction."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle of the repeated copied matrix.")};
defARGINFO __arg_reset_obj_db [] = {defArg("默认图像宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Default image width (in pixels)."),defArg("默认图像高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Default image height (in pixels)."),defArg("默认通道", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Usual number of channels.")};
defARGINFO __arg_rft_generic [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("傅立叶图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Fourier-transformed image."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Calculate forward or reverse transform."),defArg("归一化因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normalizing factor of the transform."),defArg("结果类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image type of the output image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image for which the runtime should be optimized.")};
defARGINFO __arg_rgb1_to_gray [] = {defArg("RGB图像", dataTypeObj, 0, 0, "Three-channel RBG image."),defArg("灰度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray scale image.")};
defARGINFO __arg_rgb3_to_gray [] = {defArg("红色通道", dataTypeObj, 0, 0, "Input image (red channel)."),defArg("绿色通道", dataTypeObj, 0, 0, "Input image (green channel)."),defArg("蓝色通道", dataTypeObj, 0, 0, "Input image (blue channel)."),defArg("灰度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Gray scale image.")};
defARGINFO __arg_roberts [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("Roberts图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Roberts-filtered result images."),defArg("过滤器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter type.")};
defARGINFO __arg_robinson_amp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image.")};
defARGINFO __arg_robinson_dir [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘梯度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("边缘角度图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image.")};
defARGINFO __arg_rotate_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像旋转", dataTypeObj, 0, AS_RECEIVE_VAR, "Rotated image."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation.")};
defARGINFO __arg_roundness [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean distance from the center."),defArg("标准差系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Standard deviation of Distance."),defArg("圆度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Shape factor for roundness."),defArg("边", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of polygon sides.")};
defARGINFO __arg_runlength_distribution [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be examined."),defArg("前景", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length distribution of the region (foreground)."),defArg("背景", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Length distribution of the background.")};
defARGINFO __arg_runlength_features [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("行程数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of runs."),defArg("K因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Storing factor in relation to a square."),defArg("L因子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean number of runs per line."),defArg("平均长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean length of runs."),defArg("字节", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of bytes necessary for coding the region.")};
defARGINFO __arg_run_bg_esti [] = {defArg("目前的图像", dataTypeObj, 0, 0, "Current image."),defArg("前景区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region of the detected foreground."),defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set.")};
defARGINFO __arg_saddle_points_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the calculation of the partial derivatives."),defArg("西格玛", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian. If Filter is 'facet', Sigma may be 0.0 to avoid the smoothing of the input image."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum absolute value of the eigenvalues of the Hessian matrix."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected saddle points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected saddle points.")};
defARGINFO __arg_sample_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("x最小值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Minimum x value of the output function."),defArg("x最大值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Maximum x value of the output function."),defArg("样本间距", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distance of the samples."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment for the input function."),defArg("抽样函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sampled function.")};
defARGINFO __arg_scale_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image(s) whose gray values are to be scaled."),defArg("图像缩放", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the scale."),defArg("乘数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor."),defArg("加数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Offset.")};
defARGINFO __arg_scale_image_max [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be scaled."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "contrast enhanced image.")};
defARGINFO __arg_scale_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("比例因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the scaled elements.")};
defARGINFO __arg_scale_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("比例因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor.")};
defARGINFO __arg_scale_y_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("缩放因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for scaling of the y values."),defArg("附加值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Constant which is added to the y values."),defArg("变换函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformed function.")};
defARGINFO __arg_scene_flow_calib [] = {defArg("图像区域1T1", dataTypeObj, 0, 0, "Input image 1 at time t_1."),defArg("图像区域2T1", dataTypeObj, 0, 0, "Input image 2 at time t_1."),defArg("图像区域1T2", dataTypeObj, 0, 0, "Input image 1 at time t_2."),defArg("图像区域2T2", dataTypeObj, 0, 0, "Input image 2 at time t_2."),defArg("时间差", dataTypeObj, 0, 0, "Disparity between input images 1 and 2 at time t_1."),defArg("平滑流权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the regularization term relative to the data term (derivatives of the optical flow)."),defArg("平滑时间差权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the regularization term relative to the data term (derivatives of the disparity change)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the algorithm."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the algorithm."),defArg("相机1内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 1."),defArg("相机2内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 2."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the rectified camera 2 in relation to the rectified camera 1."),defArg("对象3d模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model.")};
defARGINFO __arg_scene_flow_uncalib [] = {defArg("图像1T1", dataTypeObj, 0, 0, "Input image 1 at time t_1."),defArg("图像2T1", dataTypeObj, 0, 0, "Input image 2 at time t_1."),defArg("图像1T2", dataTypeObj, 0, 0, "Input image 1 at time t_2."),defArg("图像2T2", dataTypeObj, 0, 0, "Input image 2 at time t_2."),defArg("时间差", dataTypeObj, 0, 0, "Disparity between input images 1 and 2 at time t_1."),defArg("光流估计", dataTypeObj, 0, AS_RECEIVE_VAR, "Estimated optical flow."),defArg("视察变化", dataTypeObj, 0, AS_RECEIVE_VAR, "Estimated change in disparity."),defArg("平滑流权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the regularization term relative to the data term (derivatives of the optical flow)."),defArg("平滑时间差权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the regularization term relative to the data term (derivatives of the disparity change)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the algorithm."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the algorithm.")};
defARGINFO __arg_search_operator [] = {defArg("关键词", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Keyword for which corresponding operators are searched."),defArg("算子", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Operators whose slot 'keyword' contains the keyword.")};
defARGINFO __arg_segment_characters [] = {defArg("区域", dataTypeObj, 0, 0, "Area in the image where the text lines are located."),defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像前景", dataTypeObj, 0, AS_RECEIVE_VAR, "Image used for the segmentation."),defArg("区域前景", dataTypeObj, 0, AS_RECEIVE_VAR, "Region of characters."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to segment the characters."),defArg("消除线类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Eliminate horizontal and vertical lines?"),defArg("点打印", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should dot print characters be detected?"),defArg("笔画宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stroke width of a character."),defArg("字符宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of a character."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of a character."),defArg("阈值偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value to adjust the segmentation."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum gray value difference between text and background."),defArg("使用的阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Threshold used to segment the characters.")};
defARGINFO __arg_segment_contours_xld [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Contours to be segmented."),defArg("分割后轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented contours."),defArg("分割模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode for the segmentation of the contours."),defArg("平滑像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points used for smoothing the contours."),defArg("一次距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between a contour and the approximating line (first iteration)."),defArg("二次距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance between a contour and the approximating line (second iteration).")};
defARGINFO __arg_segment_contour_attrib_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contour to be segmented."),defArg("轮廓部分", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented contour parts."),defArg("属性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Contour attributes to be checked."),defArg("操作类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Linkage type of the individual attributes."),defArg("属性最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limits of the attribute values."),defArg("属性最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limits of the attribute values.")};
defARGINFO __arg_select_characters [] = {defArg("区域", dataTypeObj, 0, 0, "Region of text lines in which to select the characters."),defArg("选择的字符", dataTypeObj, 0, AS_RECEIVE_VAR, "Selected characters."),defArg("点打印", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should dot print characters be detected?"),defArg("笔画宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stroke width of a character."),defArg("字符宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of a character."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of a character."),defArg("是否加标点符号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Add punctuation?"),defArg("是否存在区分标志", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Exist diacritic marks?"),defArg("分区方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to partition neighbored characters."),defArg("分割线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should lines be partitioned?"),defArg("片段距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance of fragments."),defArg("是否连接片段", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Connect fragments?"),defArg("杂波最大尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum size of clutter."),defArg("停止后", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stop execution after this step.")};
defARGINFO __arg_select_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("选择轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Feature to select contours with."),defArg("下限1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold."),defArg("上限1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold."),defArg("下限2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold."),defArg("上限2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold.")};
defARGINFO __arg_select_feature_set_gmm [] = {defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the classifier."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the classifier."),defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A trained GMM classifier using only the selected features."),defArg("选择的特征指标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The selected feature set, contains indices or names."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The achieved score using two-fold cross-validation.")};
defARGINFO __arg_select_feature_set_knn [] = {defArg("分类器训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("k最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A trained k-NN classifier using only the selected features."),defArg("选择的特征指标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The selected feature set, contains indices or names."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The achieved score using two-fold cross-validation.")};
defARGINFO __arg_select_feature_set_mlp [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A trained MLP classifier using only the selected features."),defArg("选择的特征指标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The selected feature set, contains indices referring."),defArg("得分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The achieved score using two-fold cross-validation.")};
defARGINFO __arg_select_feature_set_svm [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("通用参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A trained SVM classifier using only the selected features."),defArg("选择的特征索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The selected feature set, contains indices."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The achieved score using two-fold cross-validation.")};
defARGINFO __arg_select_gray [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("选定区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions having features within the limits."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the features."),defArg("特征连接", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Logical connection of features."),defArg("特征下限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limit(s) of features."),defArg("特征上限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limit(s) of features.")};
defARGINFO __arg_select_grayvalues_from_channels [] = {defArg("多通道图像", dataTypeObj, 0, 0, "Multi-channel gray value image."),defArg("索引图像", dataTypeObj, 0, 0, "Image, where pixel values are interpreted as channel index."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting image.")};
defARGINFO __arg_select_lines [] = {defArg("行开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points of the input lines."),defArg("列开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("行结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the ending points of the input lines."),defArg("列结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Features to be used for selection."),defArg("操作", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired combination of the features."),defArg("最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limits of the features or 'min'."),defArg("最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limits of the features or 'max'."),defArg("行开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the starting points of the output lines."),defArg("列开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the starting points of the output lines."),defArg("行结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the ending points of the output lines."),defArg("列结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the ending points of the output lines.")};
defARGINFO __arg_select_lines_longest [] = {defArg("行开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the starting points of the input lines."),defArg("列开始输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the starting points of the input lines."),defArg("行结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the ending points of the input lines."),defArg("列结束输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the ending points of the input lines."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "(Maximum) desired number of output lines."),defArg("行开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the starting points of the output lines."),defArg("列开始输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the starting points of the output lines."),defArg("行结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the ending points of the output lines."),defArg("列结束输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the ending points of the output lines.")};
defARGINFO __arg_select_matching_lines [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the lines are to be matched."),defArg("区域线", dataTypeObj, 0, AS_RECEIVE_VAR, "Region array containing the matched lines."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Angles (in radians) of the normal vectors of the input lines."),defArg("输入距离", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distances of the input lines form the origin."),defArg("输入线宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Widths of the lines."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold value for the number of line points in the region."),defArg("输出角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angles (in radians) of the normal vectors of the selected lines."),defArg("输出距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distances of the selected lines from the origin.")};
defARGINFO __arg_select_obj [] = {defArg("对象", dataTypeObj, 0, 0, "Input objects."),defArg("选定对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Selected objects."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indices of the objects to be selected.")};
defARGINFO __arg_select_region_point [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("选择区域", dataTypeObj, 0, AS_RECEIVE_VAR, "All regions containing the test pixel."),defArg("像素点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line index of the test pixel."),defArg("像素点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the test pixel.")};
defARGINFO __arg_select_region_spatial [] = {defArg("区域1", dataTypeObj, 0, 0, "Starting regions"),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions"),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired neighboring relation."),defArg("区域索引1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices in the input tuples (Regions1 or Regions2), respectively."),defArg("区域索引2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices in the input tuples (Regions1 or Regions2), respectively.")};
defARGINFO __arg_select_shape [] = {defArg("输入区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("选择区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions fulfilling the condition."),defArg("形状特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape features to be checked."),defArg("连接模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Linkage type of the individual features."),defArg("特征下限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limits of the features or 'min'."),defArg("特征上限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limits of the features or 'max'.")};
defARGINFO __arg_select_shape_proto [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("模式", dataTypeObj, 0, 0, "Region compared to Regions."),defArg("选定区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions fulfilling the condition."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape features to be checked."),defArg("最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower border of feature."),defArg("最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper border of the feature.")};
defARGINFO __arg_select_shape_std [] = {defArg("输入区域", dataTypeObj, 0, 0, "Input regions to be selected."),defArg("选择区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions with desired shape."),defArg("指定特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape features to be checked."),defArg("相似度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Similarity measure.")};
defARGINFO __arg_select_shape_xld [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("选择轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours or polygons fulfilling the condition(s)."),defArg("形状特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shape features to be checked."),defArg("连接模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Operation type between the individual features."),defArg("特征下限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower limits of the features or 'min'."),defArg("特征上限", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper limits of the features or 'max'.")};
defARGINFO __arg_select_sub_feature_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("子特征指标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices or names to select the subfeatures or columns."),defArg("选中训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the reduced training data.")};
defARGINFO __arg_select_xld_point [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("选择轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "All contours or polygons containing the test point."),defArg("像素点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line coordinate of the test point."),defArg("像素点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the test point.")};
defARGINFO __arg_send_data [] = {defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Specification how to convert the data."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Value (or tuple of values) holding the data to send."),defArg("通信", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "IP address or hostname and network port of the communication partner.")};
defARGINFO __arg_send_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be sent."),defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_send_region [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be sent."),defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_send_serialized_item [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item.")};
defARGINFO __arg_send_tuple [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple to be sent.")};
defARGINFO __arg_send_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "XLD object to be sent."),defArg("接口", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number.")};
defARGINFO __arg_sensor_kalman [] = {defArg("维度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "null"),defArg("测量输入", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "null"),defArg("测量输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "null")};
defARGINFO __arg_serialize_cam_par [] = {defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_distance_transform_xld [] = {defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized XLD distance transform.")};
defARGINFO __arg_serialize_fft_optimization_data [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_hom_mat2d [] = {defArg("2d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_hom_mat3d [] = {defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix."),defArg("序列化句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_object [] = {defArg("对象", dataTypeObj, 0, 0, "Iconic object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_pose [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_quat [] = {defArg("四元数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Quaternion."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_tuple [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "XLD object."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_aop_info [] = {defArg("算子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Operator to set information to"),defArg("索引名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further specific index"),defArg("索引值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Further specific address"),defArg("信息名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scope of information"),defArg("信息值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "AOP information value")};
defARGINFO __arg_set_bg_esti_params [] = {defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set."),defArg("系统矩阵参数1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "1. system matrix parameter."),defArg("系统矩阵参数2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "2. system matrix parameter."),defArg("增益模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gain type."),defArg("增益1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kalman gain / foreground adaptation time."),defArg("增益2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kalman gain / background adaptation time."),defArg("适应模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold adaptation."),defArg("最小差异", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Foreground/background threshold."),defArg("数据集数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of statistic data sets."),defArg("置信度C", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Confidence constant."),defArg("衰减时间C", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Constant for decay time.")};
defARGINFO __arg_set_check [] = {defArg("控制模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired control mode.")};
defARGINFO __arg_set_class_box_param [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("标志", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the wanted parameter."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the parameter.")};
defARGINFO __arg_set_color [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("颜色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Output color names.")};
defARGINFO __arg_set_colored [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("输出颜色数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of output colors.")};
defARGINFO __arg_set_comprise [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping mode for gray value output.")};
defARGINFO __arg_set_compute_device_param [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Compute device handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter to set."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "New parameter value.")};
defARGINFO __arg_set_current_dir [] = {defArg("目录名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of current working directory to be set.")};
defARGINFO __arg_set_diagonal_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("向量ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle containing the diagonal elements to be set."),defArg("对角线位置", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Position of the diagonal.")};
defARGINFO __arg_set_distance_transform_xld_param [] = {defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_draw [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fill mode for region output.")};
defARGINFO __arg_set_drawing_object_callback [] = {defArg("绘图对象句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object."),defArg("绘图对象事件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Events to be captured."),defArg("回调函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Callback functions.")};
defARGINFO __arg_set_drawing_object_params [] = {defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object."),defArg("参数名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter names of the drawing object."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter values.")};
defARGINFO __arg_set_drawing_object_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contour."),defArg("绘图对象ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the drawing object.")};
defARGINFO __arg_set_feature_lengths_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data that should be partitioned into subfeatures."),defArg("子特征长度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the subfeatures."),defArg("名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the subfeatures.")};
defARGINFO __arg_set_fix [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of fixing.")};
defARGINFO __arg_set_fixed_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of fixing.")};
defARGINFO __arg_set_font [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("字体", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of new font.")};
defARGINFO __arg_set_framegrabber_callback [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("应答类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Callback type."),defArg("回调函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to the callback function to be set."),defArg("用户数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pointer to user-specific context data.")};
defARGINFO __arg_set_framegrabber_lut [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("灰度值红", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Red level of the LUT entries."),defArg("灰度值绿", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Green level of the LUT entries."),defArg("灰度值蓝", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Blue level of the LUT entries.")};
defARGINFO __arg_set_framegrabber_param [] = {defArg("设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the acquisition device to be used."),defArg("指定参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter name."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter value to be set.")};
defARGINFO __arg_set_full_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values to be set.")};
defARGINFO __arg_set_gray [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray values for region output.")};
defARGINFO __arg_set_grayval [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be modified."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the pixels to be modified."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the pixels to be modified."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray values to be used.")};
defARGINFO __arg_set_hsi [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("色调", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Hue for region output."),defArg("饱和", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Saturation for region output."),defArg("亮度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Intensity for region output.")};
defARGINFO __arg_set_icon [] = {defArg("图标", dataTypeObj, 0, 0, "Icon for center of gravity."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id.")};
defARGINFO __arg_set_insert [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the display function.")};
defARGINFO __arg_set_io_channel_param [] = {defArg("输入输出通道句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter values to set.")};
defARGINFO __arg_set_io_device_param [] = {defArg("输入输出设备句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the opened I/O device."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter values to set.")};
defARGINFO __arg_set_line_approx [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("最大近似偏差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum deviation from the original contour.")};
defARGINFO __arg_set_line_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("样式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Contour pattern.")};
defARGINFO __arg_set_line_width [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line width for region output in contour mode.")};
defARGINFO __arg_set_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("查找表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of look-up-table, values of look-up-table (RGB) or file name.")};
defARGINFO __arg_set_lut_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("色调", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Modification of color value."),defArg("饱和", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Modification of saturation."),defArg("亮度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Modification of intensity.")};
defARGINFO __arg_set_message_obj [] = {defArg("对象数据", dataTypeObj, 0, 0, "Object to be associated with the key."),defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Key string.")};
defARGINFO __arg_set_message_param [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the message parameters or action commands."),defArg("消息键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message keys the parameter/command should be applied to."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the message parameters or action commands.")};
defARGINFO __arg_set_message_queue_param [] = {defArg("队列句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message queue handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the queue parameters or action commands."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the queue parameters or action commands.")};
defARGINFO __arg_set_message_tuple [] = {defArg("消息句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Message handle."),defArg("键", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Key string."),defArg("元组数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple value to be associated with the key.")};
defARGINFO __arg_set_mshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("光标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mouse pointer name.")};
defARGINFO __arg_set_origin_pose [] = {defArg("输入姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "original 3D pose."),defArg("x轴方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "translation of the origin in x-direction."),defArg("y轴方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "translation of the origin in y-direction."),defArg("Z轴方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "translation of the origin in z-direction."),defArg("新的姿势", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "new 3D pose after applying the translation.")};
defARGINFO __arg_set_paint [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Output mode. Additional parameters possible.")};
defARGINFO __arg_set_params_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the k-NN classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the k-NN classifier.")};
defARGINFO __arg_set_part [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of the upper left corner of the chosen image part."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of the upper left corner of the chosen image part."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of the lower right corner of the chosen image part."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of the lower right corner of the chosen image part.")};
defARGINFO __arg_set_part_style [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("风格", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation method for image output: 0 (fast, low quality) to 2 (slow, high quality).")};
defARGINFO __arg_set_pixel [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Color lookup table index.")};
defARGINFO __arg_set_regularization_params_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the regularization parameter to set."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the regularization parameter.")};
defARGINFO __arg_set_rejection_params_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_rgb [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("红色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Red component of the color."),defArg("绿色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Green component of the color."),defArg("蓝色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Blue component of the color.")};
defARGINFO __arg_set_serial_param [] = {defArg("串口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle."),defArg("波特率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Speed of the serial interface."),defArg("数据位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of data bits of the serial interface."),defArg("流量控制类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of flow control of the serial interface."),defArg("奇偶校验", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parity of the serial interface."),defArg("停止位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of stop bits of the serial interface."),defArg("总超时时间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Total timeout of the serial interface in ms."),defArg("字符间超时时间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Inter-character timeout of the serial interface in ms.")};
defARGINFO __arg_set_shape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window_id."),defArg("形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Region output mode.")};
defARGINFO __arg_set_socket_param [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the socket parameter."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the socket parameter.")};
defARGINFO __arg_set_socket_timeout [] = {defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number."),defArg("超时时间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Socket timeout.")};
defARGINFO __arg_set_spy [] = {defArg("控制模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Control mode"),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "State of the control mode to be set.")};
defARGINFO __arg_set_sub_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("子矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input sub-matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper row position of the sub-matrix in the matrix."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Left column position of the sub-matrix in the matrix.")};
defARGINFO __arg_set_system [] = {defArg("系统参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the system parameter to be changed."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "New value of the system parameter.")};
defARGINFO __arg_set_tposition [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of text cursor position."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of text cursor position.")};
defARGINFO __arg_set_tshape [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("光标形状名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of cursor shape.")};
defARGINFO __arg_set_value_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row numbers of the matrix elements to be modified."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column numbers of the matrix elements to be modified."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values to be set in the indicated matrix elements.")};
defARGINFO __arg_set_window_attr [] = {defArg("属性名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the attribute that should be modified."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Value of the attribute that should be set.")};
defARGINFO __arg_set_window_dc [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("设备上下文", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "device context of WINHWnd.")};
defARGINFO __arg_set_window_extents [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of upper left corner in target position."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of upper left corner in target position."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the window."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the window.")};
defARGINFO __arg_set_window_param [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value to be set.")};
defARGINFO __arg_set_window_type [] = {defArg("窗口类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the window type which has to be set.")};
defARGINFO __arg_shade_height_field [] = {defArg("图像高度", dataTypeObj, 0, 0, "Height field to be shaded."),defArg("阴影图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Shaded image."),defArg("z夹角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the positive z-axis (in degrees)."),defArg("x夹角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees)."),defArg("反射率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of light reflected by the surface."),defArg("环境光量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of ambient light."),defArg("计算阴影吗", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should shadows be calculated?")};
defARGINFO __arg_shape_histo_all [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the features are to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Feature to be examined."),defArg("绝对分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute distribution of the feature."),defArg("相对分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative distribution of the feature.")};
defARGINFO __arg_shape_histo_point [] = {defArg("区域", dataTypeObj, 0, 0, "Region in which the features are to be examined."),defArg("图像", dataTypeObj, 0, 0, "Gray value image."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Feature to be examined."),defArg("Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row of the pixel which the region must contain."),defArg("X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column of the pixel which the region must contain."),defArg("绝对分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute distribution of the feature."),defArg("相对分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative distribution of the feature.")};
defARGINFO __arg_shape_trans [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be transformed."),defArg("变换后区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed regions."),defArg("变换类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of transformation.")};
defARGINFO __arg_shape_trans_xld [] = {defArg("要变换轮廓", dataTypeObj, 0, 0, "Contours or polygons to be transformed."),defArg("变换后轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed contours respectively polygons."),defArg("变换类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of transformation.")};
defARGINFO __arg_shock_filter [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像锐化", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("时间步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Time step."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of edge detector."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing of edge detector.")};
defARGINFO __arg_sigma_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the mask (number of lines)."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the mask (number of columns)."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Max. deviation to the average.")};
defARGINFO __arg_signal_condition [] = {defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Condition synchronization object.")};
defARGINFO __arg_signal_event [] = {defArg("事件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Event synchronization object.")};
defARGINFO __arg_simulate_defocus [] = {defArg("图像", dataTypeObj, 0, 0, "Image to blur."),defArg("模糊图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Blurred image."),defArg("模糊度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Degree of blurring.")};
defARGINFO __arg_simulate_motion [] = {defArg("图像", dataTypeObj, 0, 0, "image to be blurred."),defArg("动态图像", dataTypeObj, 0, AS_RECEIVE_VAR, "motion blurred image."),defArg("模糊", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "extent of blurring."),defArg("夹角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between direction of motion and x-axis (anticlockwise)."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "impulse response of motion blur.")};
defARGINFO __arg_sin_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("正弦图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_skeleton [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be thinned."),defArg("骨架", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting skeleton.")};
defARGINFO __arg_slide_image [] = {defArg("源窗口句柄1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Logical window number of the \"upper window\"."),defArg("源窗口句柄2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Logical window number of the \"lower window\"."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier.")};
defARGINFO __arg_smallest_circle [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of the center."),defArg("圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radius of the surrounding circle.")};
defARGINFO __arg_smallest_circle_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("圆心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the enclosing circle."),defArg("圆心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the enclosing circle."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radius of the enclosing circle.")};
defARGINFO __arg_smallest_rectangle1 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("左上角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of upper left corner point."),defArg("左上角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of upper left corner point."),defArg("右下角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of lower right corner point."),defArg("右下角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of lower right corner point.")};
defARGINFO __arg_smallest_rectangle1_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("左上角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of upper left corner point of the enclosing rectangle."),defArg("左上角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of upper left corner point of the enclosing rectangle."),defArg("右下角Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of lower right corner point of the enclosing rectangle."),defArg("右下角X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of lower right corner point of the enclosing rectangle.")};
defARGINFO __arg_smallest_rectangle2 [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be examined."),defArg("中心Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Line index of the center."),defArg("中心X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center."),defArg("角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the surrounding rectangle (arc measure)"),defArg("主半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First radius (half length) of the surrounding rectangle."),defArg("次半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second radius (half width) of the surrounding rectangle.")};
defARGINFO __arg_smallest_rectangle2_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Contours or polygons to be examined."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center point of the enclosing rectangle."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center point of the enclosing rectangle."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the enclosing rectangle (arc measure)"),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First radius (half length) of the enclosing rectangle."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second radius (half width) of the enclosing rectangle.")};
defARGINFO __arg_smooth_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contour to be smoothed."),defArg("平滑轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed contour."),defArg("回归线点数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of points used to calculate the regression line.")};
defARGINFO __arg_smooth_funct_1d_gauss [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Function to be smoothed."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("平滑函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smoothed function.")};
defARGINFO __arg_smooth_funct_1d_mean [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "1D function."),defArg("平滑掩码大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the averaging mask."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations for the smoothing."),defArg("平滑函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smoothed function.")};
defARGINFO __arg_smooth_image [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be smoothed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Smoothed image."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter."),defArg("阿尔法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filterparameter: small values cause strong smoothing (vice versa by using bei 'gauss').")};
defARGINFO __arg_sobel_amp [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("过滤器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter type."),defArg("尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of filter mask.")};
defARGINFO __arg_sobel_dir [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘幅度", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge amplitude (gradient magnitude) image."),defArg("边缘角度", dataTypeObj, 0, AS_RECEIVE_VAR, "Edge direction image."),defArg("过滤器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter type."),defArg("尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of filter mask.")};
defARGINFO __arg_socket_accept_connect [] = {defArg("接受中的套接字号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Socket number of the accepting socket."),defArg("是否等待数据", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the operator wait until a connection request arrives?"),defArg("套接字号", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Socket number.")};
defARGINFO __arg_solve_matrix [] = {defArg("左矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix of the left hand side."),defArg("左矩阵类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the input matrix of the left hand side."),defArg("E", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of solving and limitation to set singular values to be 0."),defArg("右矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix of right hand side."),defArg("结果右矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "New matrix handle with the solution.")};
defARGINFO __arg_sort_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be sorted."),defArg("排序后轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Sorted contours."),defArg("排序模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of sorting."),defArg("排序顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Increasing or decreasing sorting order."),defArg("行排或列排", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sorting first with respect to row, then to column.")};
defARGINFO __arg_sort_region [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be sorted."),defArg("排序后区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Sorted regions."),defArg("排序模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of sorting."),defArg("顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Increasing or decreasing sorting order."),defArg("行排或列排", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sorting first with respect to row, then to column.")};
defARGINFO __arg_spatial_relation [] = {defArg("区域1", dataTypeObj, 0, 0, "Starting regions."),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions."),defArg("百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage of the area of the comparative region which must be located left/right or above/below the region margins of the starting region."),defArg("区域索引1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the regions in the tuple of the input regions which fulfill the pose relation."),defArg("区域索引2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the regions in the tuple of the input regions which fulfill the pose relation."),defArg("联系1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Horizontal pose relation in which RegionIndex2[n] stands with RegionIndex1[n]."),defArg("联系2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Vertical pose relation in which RegionIndex2[n] stands with RegionIndex1[n].")};
defARGINFO __arg_split_contours_xld [] = {defArg("多边形", dataTypeObj, 0, 0, "Polygons for which the corresponding contours are to be split."),defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Split contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode for the splitting of the contours."),defArg("权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight for the sensitiveness."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the smoothing mask.")};
defARGINFO __arg_split_skeleton_lines [] = {defArg("骨架区线", dataTypeObj, 0, 0, "Input lines (represented by 1 pixel wide, non-branching regions)."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the line points to the line segment connecting both end points."),defArg("起点的行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the start points of the output lines."),defArg("起点的列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the start points of the output lines."),defArg("终点的行坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the end points of the output lines."),defArg("终点的列坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the end points of the output lines.")};
defARGINFO __arg_split_skeleton_region [] = {defArg("骨架区线", dataTypeObj, 0, 0, "Input lines (represented by 1 pixel wide, non-branching regions)."),defArg("区域分割线", dataTypeObj, 0, AS_RECEIVE_VAR, "Split lines."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the line points to the line segment connecting both end points.")};
defARGINFO __arg_sp_distribution [] = {defArg("白噪声百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage of salt (white noise pixels)."),defArg("黑噪声百分比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Percentage of pepper (black noise pixels)."),defArg("分布", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Resulting noise distribution.")};
defARGINFO __arg_sqrt_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image"),defArg("平方根图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image")};
defARGINFO __arg_sqrt_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the square root values of the input matrix.")};
defARGINFO __arg_sqrt_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix.")};
defARGINFO __arg_store_par_knowledge [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of parallelization knowledge file.")};
defARGINFO __arg_sub_image [] = {defArg("被减数图像", dataTypeObj, 0, 0, "Minuend(s)."),defArg("减数图像", dataTypeObj, 0, 0, "Subtrahend(s)."),defArg("图像作差", dataTypeObj, 0, AS_RECEIVE_VAR, "Result image(s) by the subtraction."),defArg("乘数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Correction factor."),defArg("加数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Correction value.")};
defARGINFO __arg_sub_matrix [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the difference of the input matrices.")};
defARGINFO __arg_sub_matrix_mod [] = {defArg("A矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix A."),defArg("B矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix B.")};
defARGINFO __arg_sum_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("总和类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of summation."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the sum of the input matrix.")};
defARGINFO __arg_svd_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("svd类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of computation."),defArg("计算奇异向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Computation of singular values."),defArg("U矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the left singular vectors."),defArg("S矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with singular values."),defArg("V矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the right singular vectors.")};
defARGINFO __arg_symmetry [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("对称图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Symmetry image."),defArg("掩码大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extension of search area."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of test direction."),defArg("指数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Exponent for weighting.")};
defARGINFO __arg_symm_difference [] = {defArg("区域1", dataTypeObj, 0, 0, "Input region 1."),defArg("区域2", dataTypeObj, 0, 0, "Input region 2."),defArg("对称差区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting region.")};
defARGINFO __arg_symm_difference_closed_contours_xld [] = {defArg("轮廓1", dataTypeObj, 0, 0, "Contours enclosing the first region."),defArg("轮廓2", dataTypeObj, 0, 0, "Contours enclosing the second region."),defArg("对称差轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours enclosing the symmetric difference.")};
defARGINFO __arg_symm_difference_closed_polygons_xld [] = {defArg("多边形1", dataTypeObj, 0, 0, "Polygons enclosing the first region."),defArg("多边形2", dataTypeObj, 0, 0, "Polygons enclosing the second region."),defArg("对称差多边形", dataTypeObj, 0, AS_RECEIVE_VAR, "Polygons enclosing the symmetric difference.")};
defARGINFO __arg_system_call [] = {defArg("命令", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Command to be called by the system.")};
defARGINFO __arg_tan_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("正弦图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image.")};
defARGINFO __arg_test_access [] = {defArg("对象", dataTypeObj, 0, 0, "null"),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "null"),defArg("读次数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "null"),defArg("对象复制次数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "null"),defArg("写次数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "null")};
defARGINFO __arg_test_closed_xld [] = {defArg("XLD轮廓或多边形", dataTypeObj, 0, 0, "Contours or polygons to be tested."),defArg("判断关闭", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with boolean numbers.")};
defARGINFO __arg_test_equal_obj [] = {defArg("对象1", dataTypeObj, 0, 0, "Test objects."),defArg("对象2", dataTypeObj, 0, 0, "Comparative objects."),defArg("是否相等", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "boolean result value.")};
defARGINFO __arg_test_equal_region [] = {defArg("区域1", dataTypeObj, 0, 0, "Test regions."),defArg("区域2", dataTypeObj, 0, 0, "Comparative regions."),defArg("是否相等", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "boolean result value.")};
defARGINFO __arg_test_obj_def [] = {defArg("对象", dataTypeObj, 0, 0, "null"),defArg("是否定义", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "null")};
defARGINFO __arg_test_region_point [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be examined."),defArg("像素点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the test pixel(s)."),defArg("像素点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the test pixel(s)."),defArg("是否包含", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Boolean result value.")};
defARGINFO __arg_test_sampset_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("样本的关键特征", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Key of the test data."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Error during the assignment.")};
defARGINFO __arg_test_self_intersection_xld [] = {defArg("XLD", dataTypeObj, 0, 0, "Input contours or polygons."),defArg("闭合XLD轮廓", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the input contours or polygons be closed first?"),defArg("不相交", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "1 for contours or polygons with self intersection and 0 otherwise.")};
defARGINFO __arg_test_subset_region [] = {defArg("区域1", dataTypeObj, 0, 0, "Test region."),defArg("区域2", dataTypeObj, 0, 0, "Region for comparison."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Is Region1 contained in Region2?")};
defARGINFO __arg_test_xld_point [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Contours or polygons to be tested."),defArg("像素点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the points to be tested."),defArg("像素点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the points to be tested."),defArg("是否包含", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with boolean numbers.")};
defARGINFO __arg_texture_laws [] = {defArg("图像", dataTypeObj, 0, 0, "Images to which the texture transformation is to be applied."),defArg("图像纹理", dataTypeObj, 0, AS_RECEIVE_VAR, "Texture images."),defArg("滤波器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired filter."),defArg("平移量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Shift to reduce the gray value dynamics."),defArg("滤镜尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the filter kernel.")};
defARGINFO __arg_text_line_orientation [] = {defArg("区域", dataTypeObj, 0, 0, "Area of text lines."),defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the text lines."),defArg("最小旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum rotation of the text lines."),defArg("最大旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum rotation of the text lines."),defArg("方位角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated rotation angle of the text lines.")};
defARGINFO __arg_text_line_slant [] = {defArg("区域", dataTypeObj, 0, 0, "Area of text lines."),defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the text lines."),defArg("字符最小倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum slant of the characters"),defArg("字符最大倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum slant of the characters"),defArg("倾斜的角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated slant of the characters in the region")};
defARGINFO __arg_thickening [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素1", dataTypeObj, 0, 0, "Structuring element for the foreground."),defArg("结构元素2", dataTypeObj, 0, 0, "Structuring element for the background."),defArg("加厚的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thickening operator."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_thickening_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thickening operator."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_thickening_seq [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thickening operator."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_thinning [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素1", dataTypeObj, 0, 0, "Structuring element for the foreground."),defArg("结构元素2", dataTypeObj, 0, 0, "Structuring element for the background."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thinning operator."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_thinning_golay [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("细化结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thinning operator."),defArg("格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("旋转后的格雷元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation of the Golay element. Depending on the element, not all rotations are valid.")};
defARGINFO __arg_thinning_seq [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("细化后结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the thinning operator."),defArg("格雷字母结构元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Structuring element from the Golay alphabet."),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations. For 'f', 'f2', 'h' and 'i' the only useful value is 1.")};
defARGINFO __arg_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("结果区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented region."),defArg("最小灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the gray values."),defArg("最大灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the gray values.")};
defARGINFO __arg_tile_channels [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("拼接图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Tiled output image."),defArg("水平数量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns to use for the output image."),defArg("输出次序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of the input images in the output image.")};
defARGINFO __arg_tile_images [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("拼接图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Tiled output image."),defArg("水平数量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of columns to use for the output image."),defArg("输出次序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Order of the input images in the output image.")};
defARGINFO __arg_tile_images_offset [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("拼接图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Tiled output image."),defArg("起点Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the upper left corner of the input images in the output image."),defArg("起点X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the upper left corner of the input images in the output image."),defArg("左上角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the upper left corner of the copied part of the respective input image."),defArg("左上角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the upper left corner of the copied part of the respective input image."),defArg("右下角Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the lower right corner of the copied part of the respective input image."),defArg("右下角X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the lower right corner of the copied part of the respective input image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the output image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the output image.")};
defARGINFO __arg_timed_wait_condition [] = {defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Condition synchronization object."),defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object."),defArg("超时时间", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Timeout in micro seconds.")};
defARGINFO __arg_topographic_sketch [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the topographic primal sketch is to be computed."),defArg("素描图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Label image containing the 11 classes.")};
defARGINFO __arg_top_hat [] = {defArg("区域", dataTypeObj, 0, 0, "Regions to be processed."),defArg("结构元素", dataTypeObj, 0, 0, "Structuring element (position independent)."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Result of the top hat operator.")};
defARGINFO __arg_train_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("最大迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations of the expectation maximization algorithm"),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for relative change of the error for the expectation maximization algorithm to terminate."),defArg("先验概率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode to determine the a-priori probabilities of the classes"),defArg("规范", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regularization value for preventing covariance matrix singularity."),defArg("中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of found centers per class"),defArg("迭代次数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of executed iterations per class")};
defARGINFO __arg_train_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the k-NN classifier creation."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the k-NN classifier creation.")};
defARGINFO __arg_train_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("最大迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations of the optimization algorithm."),defArg("公差权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm."),defArg("容错误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data."),defArg("错误日志", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.")};
defARGINFO __arg_train_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stop parameter for training."),defArg("训练模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of training. For normal operation: 'default'. If SVs already included in the SVM should be used for training: 'add_sv_to_train_set'. For alpha seeding: the respective SVM handle.")};
defARGINFO __arg_transform_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation parameters between the functions."),defArg("变换函数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformed function.")};
defARGINFO __arg_transpose_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("结果矩阵ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matrix handle with the transpose of the input matrix.")};
defARGINFO __arg_transpose_matrix_mod [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix.")};
defARGINFO __arg_transpose_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be reflected."),defArg("转置后结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Transposed region."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the reference point.")};
defARGINFO __arg_trans_from_rgb [] = {defArg("红色通道", dataTypeObj, 0, 0, "Input image (red channel)."),defArg("绿色通道", dataTypeObj, 0, 0, "Input image (green channel)."),defArg("蓝色通道", dataTypeObj, 0, 0, "Input image (blue channel)."),defArg("输出通道1", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 1)."),defArg("输出通道2", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 1)."),defArg("输出通道3", dataTypeObj, 0, AS_RECEIVE_VAR, "Color-transformed output image (channel 1)."),defArg("颜色空间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Color space of the output image.")};
defARGINFO __arg_trans_to_rgb [] = {defArg("图像输入1", dataTypeObj, 0, 0, "Input image (channel 1)."),defArg("图像输入2", dataTypeObj, 0, 0, "Input image (channel 2)."),defArg("图像输入3", dataTypeObj, 0, 0, "Input image (channel 3)."),defArg("红色通道", dataTypeObj, 0, AS_RECEIVE_VAR, "Red channel."),defArg("绿色通道", dataTypeObj, 0, AS_RECEIVE_VAR, "Green channel."),defArg("蓝通道", dataTypeObj, 0, AS_RECEIVE_VAR, "Blue channel."),defArg("颜色空间", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Color space of the input image.")};
defARGINFO __arg_trimmed_mean [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be filtered."),defArg("掩码", dataTypeObj, 0, 0, "Image whose region serves as filter mask."),defArg("结果", dataTypeObj, 0, AS_RECEIVE_VAR, "Filtered output image."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of averaged pixels. Typical value: Surface(Mask) / 2."),defArg("边界", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Border treatment.")};
defARGINFO __arg_try_lock_mutex [] = {defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object."),defArg("是否已锁定", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mutex already locked?")};
defARGINFO __arg_try_wait_event [] = {defArg("事件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Event synchronization object."),defArg("是否已锁定", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Object already locked?")};
defARGINFO __arg_tuple_abs [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute value of the input tuple.")};
defARGINFO __arg_tuple_acos [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("反余弦", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Arccosine of the input tuple.")};
defARGINFO __arg_tuple_add [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sum of the input tuples.")};
defARGINFO __arg_tuple_and [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Logical and of the input tuples.")};
defARGINFO __arg_tuple_asin [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("反正弦", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Arcsine of the input tuple.")};
defARGINFO __arg_tuple_atan [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("反正切结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Arctangent of the input tuple.")};
defARGINFO __arg_tuple_atan2 [] = {defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple of the y-values."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple of the x-values."),defArg("反正切结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Arctangent of the input tuple.")};
defARGINFO __arg_tuple_band [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary and of the input tuples.")};
defARGINFO __arg_tuple_bnot [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary not of the input tuple.")};
defARGINFO __arg_tuple_bor [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary or of the input tuples.")};
defARGINFO __arg_tuple_bxor [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary exclusive or of the input tuples.")};
defARGINFO __arg_tuple_ceil [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ceiling function of the input tuple.")};
defARGINFO __arg_tuple_chr [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Strings corresponding to the ASCII code of the input tuple.")};
defARGINFO __arg_tuple_chrt [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Strings corresponding to the ASCII code of the input tuple.")};
defARGINFO __arg_tuple_concat [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("连接后", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Concatenation of input tuples.")};
defARGINFO __arg_tuple_cos [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("余弦", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cosine of the input tuple.")};
defARGINFO __arg_tuple_cosh [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("双曲余弦", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hyperbolic cosine of the input tuple.")};
defARGINFO __arg_tuple_cumul [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果累加和", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative sum of the corresponding tuple elements.")};
defARGINFO __arg_tuple_deg [] = {defArg("弧度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input tuple in degrees.")};
defARGINFO __arg_tuple_deviation [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("标准差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Standard deviation of tuple elements.")};
defARGINFO __arg_tuple_difference [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("差集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The difference set of two input tuples.")};
defARGINFO __arg_tuple_div [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Quotient of the input tuples.")};
defARGINFO __arg_tuple_environment [] = {defArg("名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple containing name(s) of the environment variable(s)."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Content of the environment variable(s).")};
defARGINFO __arg_tuple_equal [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_equal_elem [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_exp [] = {defArg("输入元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果幂函数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Exponential of the input tuple.")};
defARGINFO __arg_tuple_fabs [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Absolute value of the input tuple.")};
defARGINFO __arg_tuple_find [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple to examine."),defArg("查找的值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with values to find."),defArg("出现的元素索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the occurrences of the values to find in the tuple to examine.")};
defARGINFO __arg_tuple_find_first [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple to examine."),defArg("查找的值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with values to find."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the first occurrence of the values to find.")};
defARGINFO __arg_tuple_find_last [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple to examine."),defArg("查找的值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with values to find."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the last occurrence of the values to find.")};
defARGINFO __arg_tuple_first_n [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the last element to select."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple elements.")};
defARGINFO __arg_tuple_floor [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Floor function of the input tuple.")};
defARGINFO __arg_tuple_fmod [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Remainder of the division of the input tuples.")};
defARGINFO __arg_tuple_gen_const [] = {defArg("长度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of tuple to generate."),defArg("常数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Constant for initializing the tuple elements."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "New Tuple.")};
defARGINFO __arg_tuple_gen_sequence [] = {defArg("开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Start value of the tuple."),defArg("结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Maximum value for the last entry."),defArg("步进", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Increment value."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The resulting sequence.")};
defARGINFO __arg_tuple_greater [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_greater_elem [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_greater_equal [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_greater_equal_elem [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_histo_range [] = {defArg("直方图分布值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("最小值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Minimum value."),defArg("最大值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Maximum value."),defArg("bin的个数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of bins."),defArg("输出的直方图", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Histogram to be calculated."),defArg("输出bin的大小", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Bin size.")};
defARGINFO __arg_tuple_insert [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Start index of elements to be inserted."),defArg("插入的元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Element(s) to insert at index."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with inserted elements.")};
defARGINFO __arg_tuple_int [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the conversion into integer numbers.")};
defARGINFO __arg_tuple_intersection [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("交集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The intersection set of two input tuples.")};
defARGINFO __arg_tuple_inverse [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("反转", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Inverted input tuple.")};
defARGINFO __arg_tuple_is_int [] = {defArg("输入元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是int", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Is the input tuple of type integer?")};
defARGINFO __arg_tuple_is_int_elem [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是否为整数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Are the elements of the input tuple of type integer?")};
defARGINFO __arg_tuple_is_mixed [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是否为混合元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Is the input tuple of type mixed?")};
defARGINFO __arg_tuple_is_number [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是否为数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with boolean numbers.")};
defARGINFO __arg_tuple_is_real [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是否为实数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Is the input tuple of type real?")};
defARGINFO __arg_tuple_is_real_elem [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是实数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Are the elements of the input tuple of type real?")};
defARGINFO __arg_tuple_is_string [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是否为字符串元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Is the input tuple of type string?")};
defARGINFO __arg_tuple_is_string_elem [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("是字符串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Are the elements of the input tuple of type string?")};
defARGINFO __arg_tuple_last_n [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the first element to select."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple elements.")};
defARGINFO __arg_tuple_ldexp [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ldexp function of the input tuples.")};
defARGINFO __arg_tuple_length [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of elements of input tuple.")};
defARGINFO __arg_tuple_less [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_less_elem [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_less_equal [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_less_equal_elem [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("比较结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_log [] = {defArg("T", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("自然对数结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Natural logarithm of the input tuple.")};
defARGINFO __arg_tuple_log10 [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Base 10 logarithm of the input tuple.")};
defARGINFO __arg_tuple_lsh [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("位移量", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of places to shift the input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Shifted input tuple.")};
defARGINFO __arg_tuple_max [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("最大值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximal element of the input tuple elements.")};
defARGINFO __arg_tuple_max2 [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("最大值2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Elementwise maximum of the input tuples.")};
defARGINFO __arg_tuple_mean [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("平均值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean value of tuple elements.")};
defARGINFO __arg_tuple_median [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("中值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Median of the tuple elements.")};
defARGINFO __arg_tuple_min [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimal element of the input tuple elements.")};
defARGINFO __arg_tuple_min2 [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Elementwise minimum of the input tuples.")};
defARGINFO __arg_tuple_mod [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Remainder of the division of the input tuples.")};
defARGINFO __arg_tuple_mult [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Product of the input tuples.")};
defARGINFO __arg_tuple_neg [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Negation of the input tuple.")};
defARGINFO __arg_tuple_not [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary not of the input tuple.")};
defARGINFO __arg_tuple_not_equal [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_not_equal_elem [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the comparison of the input tuples.")};
defARGINFO __arg_tuple_number [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input tuple as numbers.")};
defARGINFO __arg_tuple_or [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Logical or of the input tuples.")};
defARGINFO __arg_tuple_ord [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ASCII code of the input tuple.")};
defARGINFO __arg_tuple_ords [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ASCII code of the input tuple.")};
defARGINFO __arg_tuple_pow [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Power function of the input tuples.")};
defARGINFO __arg_tuple_rad [] = {defArg("角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("输出弧度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input tuple in radians.")};
defARGINFO __arg_tuple_rand [] = {defArg("元素个数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of tuple to generate."),defArg("结果随机数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple of random numbers.")};
defARGINFO __arg_tuple_real [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input tuple as floating point numbers.")};
defARGINFO __arg_tuple_regexp_match [] = {defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input strings to match."),defArg("正则表达式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regular expression."),defArg("匹配结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Found matches.")};
defARGINFO __arg_tuple_regexp_replace [] = {defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input strings to process."),defArg("正则表达式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regular expression."),defArg("替换的表达式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Replacement expression."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Processed strings.")};
defARGINFO __arg_tuple_regexp_select [] = {defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input strings to match."),defArg("正则表达式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regular expression."),defArg("匹配的结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Matching strings")};
defARGINFO __arg_tuple_regexp_test [] = {defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input strings to match."),defArg("正则表达式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regular expression."),defArg("匹配的字符串数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of matching strings")};
defARGINFO __arg_tuple_remove [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the elements to remove."),defArg("删除后的元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Reduced tuple.")};
defARGINFO __arg_tuple_replace [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index/Indices of elements to be replaced."),defArg("替换的元素", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Element(s) to replace."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with replaced elements.")};
defARGINFO __arg_tuple_round [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the rounding.")};
defARGINFO __arg_tuple_rsh [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("位移量", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of places to shift the input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Shifted input tuple.")};
defARGINFO __arg_tuple_select [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the elements to select."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple element.")};
defARGINFO __arg_tuple_select_mask [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("掩码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "> 0 specifies the elements to select."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple elements.")};
defARGINFO __arg_tuple_select_range [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("起点索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of first element to select."),defArg("结束索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of last element to select."),defArg("结果元组", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple elements.")};
defARGINFO __arg_tuple_select_rank [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("等级指数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rank of the element to select."),defArg("挑选出来的", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected tuple element.")};
defARGINFO __arg_tuple_sgn [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果符号", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Signs of the input tuple as integer numbers.")};
defARGINFO __arg_tuple_sin [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sine of the input tuple.")};
defARGINFO __arg_tuple_sinh [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("双曲正弦", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hyperbolic sine of the input tuple.")};
defARGINFO __arg_tuple_sort [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sorted tuple.")};
defARGINFO __arg_tuple_sort_index [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sorted tuple.")};
defARGINFO __arg_tuple_split [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to split."),defArg("分隔符", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with separator symbol(s)."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Substrings after splitting the input strings.")};
defARGINFO __arg_tuple_sqrt [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Square root of the input tuple.")};
defARGINFO __arg_tuple_strchr [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("查找内容", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with character(s) to search."),defArg("所在位置", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of searched character(s) within the string(s).")};
defARGINFO __arg_tuple_string [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("格式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Format string."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Input tuple converted to strings.")};
defARGINFO __arg_tuple_strlen [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("长度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Lengths of the single strings of the input tuple.")};
defARGINFO __arg_tuple_strrchr [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("查找内容", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with character(s) to search."),defArg("所在位置", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of searched character(s) within the string(s).")};
defARGINFO __arg_tuple_strrstr [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("查找内容", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to search."),defArg("所在位置", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of searched string(s) within the examined string(s).")};
defARGINFO __arg_tuple_strstr [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("查找内容", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to search."),defArg("所在位置", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of searched string(s) within the examined string(s).")};
defARGINFO __arg_tuple_str_bit_select [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Position of character or bit to select."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple containing the selected characters and bits.")};
defARGINFO __arg_tuple_str_first_n [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("位置", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with position(s) \"n\"."),defArg("子串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The first characters of the string(s) up to position \"n\".")};
defARGINFO __arg_tuple_str_last_n [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("位置", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with position(s) \"n\"."),defArg("子串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The last characters of the string(s) starting at position \"n\".")};
defARGINFO __arg_tuple_sub [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Difference of the input tuples.")};
defARGINFO __arg_tuple_substr [] = {defArg("字符串", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with string(s) to examine."),defArg("起点", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with start position(s) \"n1\"."),defArg("终点", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple with end position(s) \"n2\"."),defArg("子字符串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Characters of the string(s) from position \"n1\" to \"n2\".")};
defARGINFO __arg_tuple_sum [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("总和", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Sum of tuple elements.")};
defARGINFO __arg_tuple_symmdiff [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("对称差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The symmetric difference set of two input tuples.")};
defARGINFO __arg_tuple_tan [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("正切", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tangent of the input tuple.")};
defARGINFO __arg_tuple_tanh [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Hyperbolic tangent of the input tuple.")};
defARGINFO __arg_tuple_type [] = {defArg("输入元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of the input tuple as an integer number.")};
defARGINFO __arg_tuple_type_elem [] = {defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Types of the elements of the input tuple as integer values.")};
defARGINFO __arg_tuple_union [] = {defArg("元组1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("元组2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The union set of two input tuples.")};
defARGINFO __arg_tuple_uniq [] = {defArg("元组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple."),defArg("删重复元素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple without successive identical elements.")};
defARGINFO __arg_tuple_xor [] = {defArg("值1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 1."),defArg("值2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input tuple 2."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Binary exclusive or of the input tuples.")};
defARGINFO __arg_union1 [] = {defArg("输入区域", dataTypeObj, 0, 0, "Regions of which the union is to be computed."),defArg("并集", dataTypeObj, 0, AS_RECEIVE_VAR, "Union of all input regions.")};
defARGINFO __arg_union2 [] = {defArg("区域1", dataTypeObj, 0, 0, "Region for which the union with all regions in Region2 is to be computed."),defArg("区域2", dataTypeObj, 0, 0, "Regions which should be added to Region1."),defArg("并集", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting regions.")};
defARGINFO __arg_union2_closed_contours_xld [] = {defArg("轮廓1", dataTypeObj, 0, 0, "Contours enclosing the first region."),defArg("轮廓2", dataTypeObj, 0, 0, "Contours enclosing the second region."),defArg("并集轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours enclosing the union.")};
defARGINFO __arg_union2_closed_polygons_xld [] = {defArg("多边形1", dataTypeObj, 0, 0, "Polygons enclosing the first region."),defArg("多边形2", dataTypeObj, 0, 0, "Polygons enclosing the second region."),defArg("并集轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Polygons enclosing the union.")};
defARGINFO __arg_union_adjacent_contours_xld [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("输出轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points."),defArg("长度系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points in relation to the length of the longer contour."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode describing the treatment of the contours' attributes.")};
defARGINFO __arg_union_cocircular_contours_xld [] = {defArg("被合并轮廓", dataTypeObj, 0, 0, "Contours to be merged."),defArg("合并后轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Merged contours."),defArg("最大弧度差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angular distance of two circular arcs."),defArg("最大重叠角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of two circular arcs."),defArg("最大切角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle between the connecting line and the tangents of circular arcs."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum length of the gap between two circular arcs in pixels."),defArg("最大半径差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum radius difference of the circles fitted to two arcs."),defArg("最大中心距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum center distance of the circles fitted to two arcs."),defArg("合并小轮廓", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Determine whether small contours without fitted circles should also be merged."),defArg("迭代", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations.")};
defARGINFO __arg_union_collinear_contours_ext_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("组合的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("最大绝对距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points in the direction of the reference regression line."),defArg("最大关系距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points in the direction of the reference regression line in relation to the length of the contour which is to be elongated."),defArg("最大偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contour from the reference regression line (i.e., perpendicular to the line)."),defArg("最大角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle difference between the two contours."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum range of the overlap."),defArg("最大回归误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum regression error of the resulting contours (NOT USED). "),defArg("最大的成本", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for reducing the total costs of unification."),defArg("距离权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the distance in the line direction on the total costs."),defArg("偏移权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the distance from the regression line on the total costs."),defArg("角度权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the angle difference on the total costs."),defArg("连接权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the line disturbance by the linking segment (overlap and angle difference) on the total costs."),defArg("回归权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Influence of the regression error on the total costs (NOT USED)."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode describing the treatment of the contours' attributes")};
defARGINFO __arg_union_collinear_contours_xld [] = {defArg("输入轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("输出轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum length of the gap between two contours, measured along the regression line of the reference contour."),defArg("最大距离系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum length of the gap between two contours, relative to the length of the reference contour, both measured along the regression line of the reference contour."),defArg("最大垂直距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the second contour from the regression line of the reference contour."),defArg("最大角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle between the regression lines of two contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode that defines the treatment of contour attributes, i.e., if the contour attributes are kept or discarded.")};
defARGINFO __arg_union_cotangential_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("连接后的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("合适的裁切长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the part of a contour to skip for the determination of tangents."),defArg("合适的长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the part of a contour to use for the determination of tangents."),defArg("最大正切角度差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum angle difference between two contours' tangents."),defArg("最大端点距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points."),defArg("最大切线垂直距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' end points perpendicular to their tangents."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of two contours."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode describing the treatment of the contours' attributes.")};
defARGINFO __arg_union_straight_contours_histo_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("组合的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("选择轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("参考线开始行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "y coordinate of the starting point of the reference line."),defArg("参考线开始列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "x coordinate of the starting point of the reference line."),defArg("参考线结束行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "y coordinate of the endpoint of the reference line."),defArg("参考线结束列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "x coordinate of the endpoint of the reference line."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance."),defArg("最大宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum Width between two minimas."),defArg("滤镜尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of Smoothfilter"),defArg("直方图", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output Values of Histogram.")};
defARGINFO __arg_union_straight_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input XLD contours."),defArg("组合的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Output XLD contours."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the contours' endpoints."),defArg("最大的差异", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum difference in direction."),defArg("权重系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting factor for the two selection criteria."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should parallel contours be taken into account?"),defArg("迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of iterations or 'maximum'.")};
defARGINFO __arg_unlock_mutex [] = {defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object.")};
defARGINFO __arg_unproject_coordinates [] = {defArg("图像", dataTypeObj, 0, 0, "Displayed image."),defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate in the window."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate in the window."),defArg("图像行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate in the image."),defArg("图像列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate in the image."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height value.")};
defARGINFO __arg_unwarp_image_vector_field [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("向量场", dataTypeObj, 0, 0, "Input vector field."),defArg("弯曲图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Unwarped image.")};
defARGINFO __arg_update_bg_esti [] = {defArg("目前的图像", dataTypeObj, 0, 0, "Current image."),defArg("更新区域", dataTypeObj, 0, 0, "Region describing areas to change."),defArg("背景估计句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the BgEsti data set.")};
defARGINFO __arg_update_kalman [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Update file for a Kalman filter."),defArg("维度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The dimensions of the state vector, measurement vector and controller vector."),defArg("输入模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The lined up matrices A,C,Q, possibly G and u, and if necessary L which all have been stored in row-major order."),defArg("输入测量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The matrix R stored in row-major order."),defArg("输出尺寸", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The dimensions of the state vector, measurement vector and controller vector."),defArg("输出模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The lined up matrices A,C,Q, possibly G and u, and if necessary L which all have been stored in row-major order."),defArg("输出测量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The matrix R stored in row-major order.")};
defARGINFO __arg_update_window_pose [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("最后一行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the first point."),defArg("最后一列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the first point."),defArg("当前行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the second point."),defArg("当前列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the second point."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Navigation mode.")};
defARGINFO __arg_var_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented regions."),defArg("掩膜宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mask width for mean and deviation calculation."),defArg("掩模高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mask height for mean and deviation calculation."),defArg("标准差表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor for the standard deviation of the gray values."),defArg("绝对阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum gray value difference from the mean."),defArg("亮暗", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold type.")};
defARGINFO __arg_vector_angle_to_rigid [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the original point."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the original point."),defArg("角度1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Angle of the original point."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the transformed point."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the transformed point."),defArg("角度2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Angle of the transformed point."),defArg("2d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_field_length [] = {defArg("向量场", dataTypeObj, 0, 0, "Input vector field"),defArg("长度", dataTypeObj, 0, AS_RECEIVE_VAR, "Length of the vectors of the vector field."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode for computing the length of the vectors.")};
defARGINFO __arg_vector_field_to_hom_mat2d [] = {defArg("向量场", dataTypeObj, 0, 0, "Input image."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_field_to_real [] = {defArg("矢量域", dataTypeObj, 0, 0, "Vector field."),defArg("矢量Y", dataTypeObj, 0, AS_RECEIVE_VAR, "Vector component in the row direction."),defArg("矢量X", dataTypeObj, 0, AS_RECEIVE_VAR, "Vector component in the column direction.")};
defARGINFO __arg_vector_to_aniso [] = {defArg("X坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("Y点坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("X的变换坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the transformed points."),defArg("Y的变换坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the transformed points."),defArg("齐次二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_to_hom_mat2d [] = {defArg("原点x", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("原点y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("变换后的点x", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the transformed points."),defArg("变换后的点y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the transformed points."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_to_hom_mat3d [] = {defArg("变换类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the transformation to compute."),defArg("px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("pz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinates of the original points."),defArg("qx", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the transformed points."),defArg("qy", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the transformed points."),defArg("qz", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinates of the transformed points."),defArg("3d变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_to_rigid [] = {defArg("相对原点的X坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("相对原点的Y坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("变换点的X坐标。", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the transformed points."),defArg("变换点的Y坐标。", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the transformed points."),defArg("齐次二维矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_vector_to_similarity [] = {defArg("X点的坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the original points."),defArg("Y点的坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the original points."),defArg("X点的变换坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the transformed points."),defArg("Y点的变换坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the transformed points."),defArg("齐次二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Output transformation matrix.")};
defARGINFO __arg_wait_barrier [] = {defArg("障碍句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Barrier synchronization object.")};
defARGINFO __arg_wait_condition [] = {defArg("条件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Condition synchronization object."),defArg("互斥体句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Mutex synchronization object.")};
defARGINFO __arg_wait_event [] = {defArg("事件句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Event synchronization object.")};
defARGINFO __arg_wait_seconds [] = {defArg("秒", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of seconds by which the execution of the program will be delayed.")};
defARGINFO __arg_watersheds [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("盆地", dataTypeObj, 0, AS_RECEIVE_VAR, "Segmented basins."),defArg("流域", dataTypeObj, 0, AS_RECEIVE_VAR, "Watersheds between the basins.")};
defARGINFO __arg_watersheds_threshold [] = {defArg("图像", dataTypeObj, 0, 0, "Image to be segmented."),defArg("盆地", dataTypeObj, 0, AS_RECEIVE_VAR, "Segments found (dark basins)."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the watersheds.")};
defARGINFO __arg_wiener_filter [] = {defArg("图像", dataTypeObj, 0, 0, "Corrupted image."),defArg("PSF", dataTypeObj, 0, 0, "impulse response (PSF) of degradation (in spatial domain)."),defArg("滤波后的图像", dataTypeObj, 0, 0, "Smoothed version of corrupted image."),defArg("图像复原", dataTypeObj, 0, AS_RECEIVE_VAR, "Restored image.")};
defARGINFO __arg_wiener_filter_ni [] = {defArg("图像", dataTypeObj, 0, 0, "Corrupted image."),defArg("脉冲响应函数", dataTypeObj, 0, 0, "impulse response (PSF) of degradation (in spatial domain)."),defArg("噪声区域", dataTypeObj, 0, 0, "Region for noise estimation."),defArg("复原图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Restored image."),defArg("掩膜宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of filter mask."),defArg("掩模高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of filter mask.")};
defARGINFO __arg_write_aop_knowledge [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of knowledge file"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name"),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value")};
defARGINFO __arg_write_cam_par [] = {defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("相机文件参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of internal camera parameters.")};
defARGINFO __arg_write_class_box [] = {defArg("分类器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the classifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file which contains the written data.")};
defARGINFO __arg_write_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_class_knn [] = {defArg("最近邻句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file in which the classifier will be written.")};
defARGINFO __arg_write_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_class_train_data [] = {defArg("训练数据句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training data."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file in which the training data will be written.")};
defARGINFO __arg_write_contour_xld_arc_info [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contours to be written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the ARC/INFO file.")};
defARGINFO __arg_write_contour_xld_dxf [] = {defArg("轮廓", dataTypeObj, 0, 0, "XLD contours to be written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the DXF file.")};
defARGINFO __arg_write_distance_transform_xld [] = {defArg("距离变换ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the XLD distance transform."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file.")};
defARGINFO __arg_write_fft_optimization_data [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the optimization data.")};
defARGINFO __arg_write_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Function to be written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file to be written.")};
defARGINFO __arg_write_image [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Graphic format."),defArg("填充颜色", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fill gray value for pixels not belonging to the image domain (region)."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of image file.")};
defARGINFO __arg_write_io_channel [] = {defArg("输入输出通道句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the opened I/O channels."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Write values."),defArg("状态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status of written values.")};
defARGINFO __arg_write_lut [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name (of file containing the look-up-table).")};
defARGINFO __arg_write_matrix [] = {defArg("矩阵ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Matrix handle of the input matrix."),defArg("文件格式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Format of the file."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_object [] = {defArg("对象", dataTypeObj, 0, 0, "Iconic object."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of file.")};
defARGINFO __arg_write_polygon_xld_arc_info [] = {defArg("多边形", dataTypeObj, 0, 0, "XLD polygons to be written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the ARC/INFO file.")};
defARGINFO __arg_write_polygon_xld_dxf [] = {defArg("多边形", dataTypeObj, 0, 0, "XLD polygons to be written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the DXF file.")};
defARGINFO __arg_write_pose [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the external camera parameters.")};
defARGINFO __arg_write_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region of the images which are returned."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of region file.")};
defARGINFO __arg_write_samples_class_gmm [] = {defArg("高斯模型句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "GMM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_samples_class_mlp [] = {defArg("多层感知器句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "MLP handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_samples_class_svm [] = {defArg("支持向量机句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "SVM handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_serial [] = {defArg("串行句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Serial interface handle."),defArg("数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Characters to write (as tuple of integers).")};
defARGINFO __arg_write_string [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("字符串", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tuple of output values (all types).")};
defARGINFO __arg_write_tuple [] = {defArg("数组", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple with any kind of data."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file to be written.")};
defARGINFO __arg_x_range_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("x最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest x value."),defArg("x最大值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Largest x value.")};
defARGINFO __arg_y_range_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function."),defArg("y最小值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest y value."),defArg("y最大值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Largest y value.")};
defARGINFO __arg_zero_crossing [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("零点交叉点区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Zero crossings.")};
defARGINFO __arg_zero_crossings_funct_1d [] = {defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input function"),defArg("零点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Zero crossings of the input function")};
defARGINFO __arg_zoom_image_factor [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像缩放", dataTypeObj, 0, AS_RECEIVE_VAR, "Scaled image."),defArg("规模的宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor for the width of the image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor for the height of the image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation.")};
defARGINFO __arg_zoom_image_size [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("图像的缩放", dataTypeObj, 0, AS_RECEIVE_VAR, "Scaled image."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the resulting image."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the resulting image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation.")};
defARGINFO __arg_zoom_region [] = {defArg("区域", dataTypeObj, 0, 0, "Region(s) to be zoomed."),defArg("缩放后的区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Zoomed region(s)."),defArg("宽度缩放比例", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor in x-direction."),defArg("高度缩放比例", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale factor in y-direction.")};
defARGINFO __arg_calibrate_cameras [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Back projection root mean square error (RMSE) of the optimization.")};
defARGINFO __arg_calibrate_hand_eye [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average residual error of the optimization.")};
defARGINFO __arg_camera_calibration [] = {defArg("X坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all x coordinates of the calibration marks (in meters)."),defArg("Y坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all y coordinates of the calibration marks (in meters)."),defArg("Z坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all z coordinates of the calibration marks (in meters)."),defArg("行坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all row coordinates of the extracted calibration marks (in pixels)."),defArg("列坐标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all column coordinates of the extracted calibration marks (in pixels)."),defArg("相机参数初始值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial values for the internal camera parameters."),defArg("初始姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all initial values for the external camera parameters."),defArg("参数估计", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters to be estimated."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters."),defArg("输出姿势", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ordered tuple with all external camera parameters."),defArg("误差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average error distance in pixels.")};
defARGINFO __arg_cam_mat_to_cam_par [] = {defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3x3 projective camera matrix that determines the internal camera parameters."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Kappa."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images that correspond to CameraMatrix."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images that correspond to CameraMatrix."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters.")};
defARGINFO __arg_cam_par_to_cam_mat [] = {defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3x3 projective camera matrix that corresponds to CameraParam."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the images that correspond to CameraMatrix."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the images that correspond to CameraMatrix.")};
defARGINFO __arg_change_radial_distortion_cam_par [] = {defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode"),defArg("输入相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters (original)."),defArg("畸变多项式系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Desired radial distortions."),defArg("输出相机内参", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters (modified).")};
defARGINFO __arg_change_radial_distortion_contours_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Original contours."),defArg("轮廓校正", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting contours with modified radial distortion."),defArg("输入相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameter for Contours."),defArg("输出相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameter for ContoursRectified.")};
defARGINFO __arg_change_radial_distortion_image [] = {defArg("图像", dataTypeObj, 0, 0, "Original image."),defArg("区域", dataTypeObj, 0, 0, "Region of interest in ImageRectified."),defArg("图像纠正", dataTypeObj, 0, AS_RECEIVE_VAR, "Resulting image with modified radial distortion."),defArg("输入相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameter for Image."),defArg("输出相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameter for Image.")};
defARGINFO __arg_change_radial_distortion_points [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Original row component of pixel coordinates."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Original column component of pixel coordinates."),defArg("输入相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The inner camera parameters of the camera used to create the input pixel coordinates."),defArg("输出相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The inner camera parameters of a camera."),defArg("行变化", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row component of pixel coordinates after changing the radial distortion."),defArg("列变化", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column component of pixel coordinates after changing the radial distortion.")};


defARGINFO __arg_clear_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model.")};
defARGINFO __arg_clear_camera_setup_model [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the camera setup model.")};
defARGINFO __arg_connect_grid_points [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("连接线", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contours."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the grid points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the grid points."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the applied Gaussians."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of the connecting lines from the grid points.")};
defARGINFO __arg_contour_to_world_plane_xld [] = {defArg("XLD轮廓", dataTypeObj, 0, 0, "Input XLD contours to be transformed in image coordinates."),defArg("转换的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed XLD contours in world coordinates."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("在世界坐标系的姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("测量单位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale or dimension")};
defARGINFO __arg_create_calib_data [] = {defArg("设定校准", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the calibration setup."),defArg("相机数量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of cameras in the calibration setup."),defArg("校准对象数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of calibration objects."),defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the created calibration data model.")};
defARGINFO __arg_create_camera_setup_model [] = {defArg("个数Cameras", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of cameras in the setup."),defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle to the camera setup model.")};
defARGINFO __arg_deserialize_calib_data [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of a calibration data model.")};
defARGINFO __arg_deserialize_camera_setup_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle to the camera setup model.")};
defARGINFO __arg_find_calib_object [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the calibration object."),defArg("校准目标姿态索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters to be set."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters to be set.")};
defARGINFO __arg_find_rectification_grid [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("网格区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Output region containing the rectification grid."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast."),defArg("半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circular structuring element.")};
defARGINFO __arg_gen_arbitrary_distortion_map [] = {defArg("映射图", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data."),defArg("网格间距", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distance of the grid points in the rectified image."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the grid points in the distorted image."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the grid points in the distorted image."),defArg("网格宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the point grid (number of grid points)."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images to be rectified."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images to be rectified."),defArg("映射类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of mapping.")};
defARGINFO __arg_gen_grid_rectification_map [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("连接线", dataTypeObj, 0, 0, "Input contours."),defArg("映射图", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data."),defArg("网格", dataTypeObj, 0, AS_RECEIVE_VAR, "Output contours."),defArg("网格间距", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distance of the grid points in the rectified image."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation to be applied to the point grid."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the grid points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the grid points."),defArg("映射类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of mapping.")};
defARGINFO __arg_gen_image_to_world_plane_map [] = {defArg("映射数据", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("在世界坐标系的姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images to be transformed."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images to be transformed."),defArg("宽度映射", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the resulting mapped images in pixels."),defArg("高度映射", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the resulting mapped images in pixels."),defArg("测量单位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale or unit."),defArg("映射类型。", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the mapping.")};
defARGINFO __arg_gen_radial_distortion_map [] = {defArg("映射图", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data."),defArg("输入相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Old camera parameters."),defArg("输出相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "New camera parameters."),defArg("映射类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the mapping.")};
defARGINFO __arg_get_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("项目类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of calibration data item."),defArg("项目索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the affected item (depending on the selected ItemType)."),defArg("数据名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The name of the inspected data."),defArg("数据的值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Requested data.")};
defARGINFO __arg_get_calib_data_observ_contours [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour-based result(s)."),defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("轮廓的名字", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of contour objects to be returned."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("校准目标姿态索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object pose.")};
defARGINFO __arg_get_calib_data_observ_points [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("校准目标姿态索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object pose."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the detected points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the detected points."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Correspondence of the detected points to the points of the observed calibration object."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Roughly estimated pose of the observed calibration object relative to the observing camera.")};
defARGINFO __arg_get_calib_data_observ_pose [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("校准目标姿态索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object pose."),defArg("相机姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Stored observed calibration object pose relative to the observing camera.")};
defARGINFO __arg_get_camera_setup_param [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera in the setup."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters to be queried."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters to be queried.")};
defARGINFO __arg_get_line_of_sight [] = {defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the pixel."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the pixel."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("Px", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the first point on the line of sight in the camera coordinate system"),defArg("py", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the first point on the line of sight in the camera coordinate system"),defArg("Pz", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the first point on the line of sight in the camera coordinate system"),defArg("Qx", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the second point on the line of sight in the camera coordinate system"),defArg("Qy", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the second point on the line of sight in the camera coordinate system"),defArg("QZ", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the second point on the line of sight in the camera coordinate system")};
defARGINFO __arg_hand_eye_calibration [] = {defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Linear list containing all the x coordinates of the calibration points (in the order of the images)."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Linear list containing all the y coordinates of the calibration points (in the order of the images)."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Linear list containing all the z coordinates of the calibration points (in the order of the images)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Linear list containing all row coordinates of the calibration points (in the order of the images)."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Linear list containing all the column coordinates of the calibration points (in the order of the images)."),defArg("个数点", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of the calibration points for each image."),defArg("机器人的姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Known 3D pose of the robot for each image (moving camera: robot base in robot tool coordinates; stationary camera: robot tool in robot base coordinates)."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method of hand-eye calibration."),defArg("质量型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of quality assessment."),defArg("相机的姿势", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed relative camera pose: 3D pose of the robot tool (moving camera) or robot base (stationary camera), respectively, in camera coordinates."),defArg("校准姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed 3D pose of the calibration points in robot base coordinates (moving camera) or in robot tool coordinates (stationary camera), respectively."),defArg("质量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Quality assessment of the result.")};
defARGINFO __arg_hom_vector_to_proj_hom_mat2d [] = {defArg("Px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 1 (x coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 1 (y coordinate)."),defArg("Pw", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 1 (w coordinate)."),defArg("Qx", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 2 (x coordinate)."),defArg("Qy", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 2 (y coordinate)."),defArg("Qw", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points 2 (w coordinate)."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix.")};
defARGINFO __arg_image_points_to_world_plane [] = {defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("在世界坐标系姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the points to be transformed."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the points to be transformed."),defArg("测量尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale or dimension"),defArg("X坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the points in the world coordinate system."),defArg("Y坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the points in the world coordinate system.")};
defARGINFO __arg_image_to_world_plane [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("变换后的图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Transformed image."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("在世界坐标系的姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the resulting image in pixels."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the resulting image in pixels."),defArg("测量单位", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale or unit"),defArg("插值方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation.")};
defARGINFO __arg_project_3d_point [] = {defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinates of the 3D points to be projected in the camera coordinate system."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinates of the 3D points to be projected in the camera coordinate system."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinates of the 3D points to be projected in the camera coordinate system."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the projected points (in pixels)."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the projected points (in pixels).")};
defARGINFO __arg_proj_hom_mat2d_to_pose [] = {defArg("单应性", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The homography from world- to image coordinates."),defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The camera calibration matrix K."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of pose computation."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose of the 2D object.")};
defARGINFO __arg_query_calib_data_observ_indices [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("项目类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of referred object."),defArg("项目索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera index or calibration object index (depending on the selected ItemType)."),defArg("索引1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of calibration object indices or list of camera indices (depending on ItemType)."),defArg("索引2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calibration object numbers.")};
defARGINFO __arg_radial_distortion_self_calibration [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours that are available for the calibration."),defArg("选择轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours that were used for the calibration"),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the images from which the contours were extracted."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the images from which the contours were extracted."),defArg("内阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the classification of outliers."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed value for the random number generator."),defArg("畸变模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Determines the distortion model."),defArg("畸变中心", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Determines how the distortion center will be estimated."),defArg("主点无功", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Controls the deviation of the distortion center from the image center; larger values allow larger deviations from the image center; 0 switches the penalty term off."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal camera parameters.")};
defARGINFO __arg_radiometric_self_calibration [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("曝光率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Ratio of the exposure energies of successive image pairs."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Features that are used to compute the inverse response function of the camera."),defArg("函数类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the inverse response function of the camera."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothness of the inverse response function of the camera."),defArg("多项式的次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Degree of the polynomial if FunctionType = 'polynomial'."),defArg("逆反应", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Inverse response function of the camera.")};
defARGINFO __arg_read_calib_data [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The path and file name of the model file."),defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of a calibration data model.")};
defARGINFO __arg_read_camera_setup_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The path and file name of the model file."),defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle to the camera setup model.")};
defARGINFO __arg_remove_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("项目类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the calibration data item."),defArg("项目索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the affected item.")};
defARGINFO __arg_remove_calib_data_observ [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("校准目标姿态索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object pose.")};
defARGINFO __arg_serialize_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_camera_setup_model [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("项目类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of calibration data item."),defArg("项目索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the affected item (depending on the selected ItemType)."),defArg("数据名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter(s) to set."),defArg("数据的价值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "New value(s).")};
defARGINFO __arg_set_calib_data_calib_object [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Calibration object index."),defArg("校准目标描述文件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D point coordinates or a description file name.")};
defARGINFO __arg_set_calib_data_cam_param [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera index."),defArg("相机类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the camera."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial camera internal parameters.")};
defARGINFO __arg_set_calib_data_observ_points [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the calibration object."),defArg("校准目标姿态ID", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the extracted points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the extracted points."),defArg("索引点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Correspondence of the extracted points to the calibration marks of the observed calibration object."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Roughly estimated pose of the observed calibration object relative to the observing camera.")};
defARGINFO __arg_set_calib_data_observ_pose [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observing camera."),defArg("校准对象编号", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the calibration object."),defArg("校准目标姿态ID", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the observed calibration object."),defArg("摄像机姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the observed calibration object relative to the observing camera.")};
defARGINFO __arg_set_camera_setup_cam_param [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera in the setup."),defArg("相机类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the camera."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("相机的姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the camera relative to the setup's coordinate system.")};
defARGINFO __arg_set_camera_setup_param [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("相机索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Unique index of the camera in the setup."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters to be set."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters to be set.")};
defARGINFO __arg_sim_caltab [] = {defArg("模拟图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Simulated calibration image."),defArg("卡尔板介绍", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "File name of the calibration plate description."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("卡尔板姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "External camera parameters (3D pose of the calibration plate in camera coordinates)."),defArg("灰色的背景", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value of image background."),defArg("灰板", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value of calibration plate."),defArg("灰色的痕迹", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value of calibration marks."),defArg("比例因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scaling factor to reduce oversampling.")};
defARGINFO __arg_stationary_camera_self_calibration [] = {defArg("图像数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of different images that are used for the calibration."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images from which the points were extracted."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images from which the points were extracted."),defArg("参考图像", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the reference image."),defArg("映射源", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the source images of the transformations."),defArg("映射目标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the target images of the transformations."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3x3 projective transformation matrices."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of corresponding points in the respective source images."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of corresponding points in the respective source images."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of corresponding points in the respective destination images."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of corresponding points in the respective destination images."),defArg("对应角点数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of point correspondences in the respective image pair."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm for the calibration."),defArg("相机模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera model to be used."),defArg("固定的摄像机参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Are the camera parameters identical for all images?"),defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "(Array of) 3x3 projective camera matrices that determine the internal camera parameters."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radial distortion of the camera."),defArg("旋转矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Array of 3x3 transformation matrices that determine rotation of the camera in the respective image."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X-Component of the direction vector of each point if EstimationMethod = 'gold_standard' is used."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y-Component of the direction vector of each point if EstimationMethod = 'gold_standard' is used."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z-Component of the direction vector of each point if EstimationMethod = 'gold_standard' is used."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average error per reconstructed point if EstimationMethod = 'gold_standard' is used.")};
defARGINFO __arg_vector_to_pose [] = {defArg("世界X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X-Component of world coordinates."),defArg("世界Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y-Component of world coordinates."),defArg("世界Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z-Component of world coordinates."),defArg("图像行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row-Component of image coordinates."),defArg("图像列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column-Component of image coordinates."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The inner camera parameters from camera calibration."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of algorithm"),defArg("质量类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of pose quality to be returned in Quality."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose."),defArg("质量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose quality.")};
defARGINFO __arg_vector_to_proj_hom_mat2d [] = {defArg("Px", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("py", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("Qx", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("Qy", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix."),defArg("协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9covariance matrix of the projective transformation matrix.")};
defARGINFO __arg_vector_to_proj_hom_mat2d_distortion [] = {defArg("点1行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("点1列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("点2行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("点2列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行坐标方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列坐标方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行坐标方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列坐标方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images from which the points were extracted."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images from which the points were extracted."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed radial distortion coefficient."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square transformation error.")};
defARGINFO __arg_write_calib_data [] = {defArg("校准数据ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a calibration data model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The file name of the model to be saved.")};
defARGINFO __arg_write_camera_setup_model [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The file name of the model to be saved.")};

defARGINFO __arg_close_measure [] = {defArg("测量对象句柄。", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle.")};
defARGINFO __arg_deserialize_measure [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure object handle.")};
defARGINFO __arg_fuzzy_measure_pairing [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of Gaussian smoothing."),defArg("最小边缘振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("模糊阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum fuzzy value."),defArg("过渡", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select the first gray value transition of the edge pairs."),defArg("配对约束", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Constraint of pairing."),defArg("边缘对数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of edge pairs."),defArg("第一行边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the first edge."),defArg("第一列边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the first edge."),defArg("第一振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the first edge (with sign)."),defArg("第二行边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the second edge."),defArg("第二列边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the second edge."),defArg("第二边缘振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the second edge (with sign)."),defArg("行对中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the edge pair."),defArg("列对中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the edge pair."),defArg("模糊积分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Fuzzy evaluation of the edge pair."),defArg("内的距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between the edges of the edge pair.")};
defARGINFO __arg_fuzzy_measure_pairs [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of Gaussian smoothing."),defArg("最小边缘振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("模糊阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum fuzzy value."),defArg("过渡", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select the first gray value transition of the edge pairs."),defArg("第一行边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the first edge point."),defArg("第一列边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the first edge point."),defArg("第一振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the first edge (with sign)."),defArg("第二行边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the second edge point."),defArg("第二列边缘", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the second edge point."),defArg("第二边缘振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the second edge (with sign)."),defArg("行边中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the edge pair."),defArg("边柱的中心", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the edge pair."),defArg("模糊积分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Fuzzy evaluation of the edge pair."),defArg("内的距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between edges of an edge pair."),defArg("间的距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between consecutive edge pairs.")};
defARGINFO __arg_fuzzy_measure_pos [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of Gaussian smoothing."),defArg("最小边缘振幅", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("模糊阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum fuzzy value."),defArg("过渡", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select light/dark or dark/light edges."),defArg("边缘行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the edge point."),defArg("边缘列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the edge point."),defArg("振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the edge (with sign)."),defArg("模糊积分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Fuzzy evaluation of the edges."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between consecutive edges.")};
defARGINFO __arg_gen_measure_arc [] = {defArg("圆弧中心y坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the arc."),defArg("圆弧中心行x坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the arc."),defArg("圆弧半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius of the arc."),defArg("圆弧的起始角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Start angle of the arc in radians."),defArg("圆弧的角度范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angular extent of the arc in radians."),defArg("环形带的半径", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Radius (half width) of the annulus."),defArg("图像的宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image to be processed subsequently."),defArg("图像的高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image to be processed subsequently."),defArg("插值类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation to be used."),defArg("测量对象句柄。", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure object handle.")};
defARGINFO __arg_gen_measure_rectangle2 [] = {defArg("矩形中心的y坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the center of the rectangle."),defArg("矩形中心的x坐标", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the center of the rectangle."),defArg("角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of longitudinal axis of the rectangle to horizontal (radians)."),defArg("矩形半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of the rectangle."),defArg("矩形半高。", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of the rectangle."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image to be processed subsequently."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image to be processed subsequently."),defArg("插值类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpolation to be used."),defArg("测量对象句柄。", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure object handle.")};
defARGINFO __arg_gray_projections [] = {defArg("区域", dataTypeObj, 0, 0, "Region to be processed."),defArg("图像", dataTypeObj, 0, 0, "Grayvalues for projections."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to compute the projections."),defArg("水平分布值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Horizontal projection."),defArg("垂直分布值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Vertical projection.")};
defARGINFO __arg_measure_pairs [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of gaussian smoothing."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("边缘幅度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of gray value transition that determines how edges are grouped to edge pairs."),defArg("选取的边缘对", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of edge pairs."),defArg("第一个边缘中心y坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the first edge."),defArg("第一个边缘中心x坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the first edge."),defArg("第一个边缘幅度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the first edge (with sign)."),defArg("第二行边缘中心y坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the second edge."),defArg("第二第一个边缘中心x坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the second edge."),defArg("第二个边缘振幅", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the second edge (with sign)."),defArg("边缘之间的距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between edges of an edge pair."),defArg("相邻边缘间的距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between consecutive edge pairs.")};
defARGINFO __arg_measure_pos [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of gaussian smoothing."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("极性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Light/dark or dark/light edge."),defArg("选择边缘点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of end points."),defArg("边缘中心的y坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the edge."),defArg("边缘中心的x坐标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the center of the edge."),defArg("边缘幅度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Edge amplitude of the edge (with sign)."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between consecutive edges.")};
defARGINFO __arg_measure_projection [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("灰度值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Gray value profile.")};
defARGINFO __arg_measure_thresh [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of gaussian smoothing."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold."),defArg("选择", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of points."),defArg("行阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of points with threshold value."),defArg("列阈值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of points with threshold value."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance between consecutive points.")};
defARGINFO __arg_read_measure [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure object handle.")};
defARGINFO __arg_reset_fuzzy_measure [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("集合类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of the fuzzy set.")};
defARGINFO __arg_serialize_measure [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_fuzzy_measure [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("集合类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of the fuzzy set."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Fuzzy function.")};
defARGINFO __arg_set_fuzzy_measure_norm_pair [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("对大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Favored width of edge pairs."),defArg("集合类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selection of the fuzzy set."),defArg("函数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Fuzzy function.")};
defARGINFO __arg_translate_measure [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the new reference point."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the new reference point.")};
defARGINFO __arg_write_measure [] = {defArg("测量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Measure object handle."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_add_metrology_object_circle_measure [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate (or Y) of the center of the circle or circular arc."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column (or X) coordinate of the center of the circle or circular arc."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle or circular arc."),defArg("测量长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions perpendicular to the boundary."),defArg("测量长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions tangetial to the boundary."),defArg("测量西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("测量阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the created metrology object.")};
defARGINFO __arg_add_metrology_object_ellipse_measure [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row (or Y) coordinate of the center of the ellipse."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column (or X) coordinate of the center of the ellipse."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis [rad]."),defArg("半径1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half axis."),defArg("半径2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half axis."),defArg("测量长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions perpendicular to the boundary."),defArg("测量长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions tangetial to the boundary."),defArg("测量西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("测量阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the created metrology object.")};
defARGINFO __arg_add_metrology_object_generic [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("形状", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the metrology object to be added."),defArg("形状参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the metrology object to be added."),defArg("测量长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions perpendicular to the boundary."),defArg("测量长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions tangetial to the boundary."),defArg("测量西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("测量阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the created metrology object.")};
defARGINFO __arg_add_metrology_object_line_measure [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("行开始", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row (or Y) coordinate of the start of the line."),defArg("起始列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column (or X) coordinate of the start of the line."),defArg("行结束", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row (or Y) coordinate of the end of the line."),defArg("结束列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column (or X) coordinate of the end of the line."),defArg("测量长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions perpendicular to the boundary."),defArg("测量长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions tangetial to the boundary."),defArg("测量西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("测量阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the created metrology object.")};
defARGINFO __arg_add_metrology_object_rectangle2_measure [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row (or Y) coordinate of the center of the rectangle."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column (or X) coordinate of the center of the rectangle."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of the main axis [rad]."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the larger half edge of the rectangle."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Length of the smaller half edge of the rectangle."),defArg("测量长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions perpendicular to the boundary."),defArg("测量长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half length of the measure regions tangetial to the boundary."),defArg("测量西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sigma of the Gaussian function for the smoothing."),defArg("测量阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum edge amplitude."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the created metrology object.")};
defARGINFO __arg_align_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the alignment."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the alignment."),defArg("角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle of the alignment.")};
defARGINFO __arg_apply_bead_inspection_model [] = {defArg("图像", dataTypeObj, 0, 0, "Image to apply bead inspection on."),defArg("留下的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "The detected left contour of the beads."),defArg("正确的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "The detected right contour of the beads."),defArg("错误段", dataTypeObj, 0, AS_RECEIVE_VAR, "Detected error segments"),defArg("焊缝检验模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bead inspection model to be used."),defArg("错误类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Types of detected errors.")};
defARGINFO __arg_apply_metrology_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model.")};

defARGINFO __arg_clear_bead_inspection_model [] = {defArg("焊缝检验模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bead inspection model.")};
defARGINFO __arg_clear_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model.")};
defARGINFO __arg_clear_metrology_object [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects.")};
defARGINFO __arg_copy_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("Copied度量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the copied metrology model.")};
defARGINFO __arg_copy_metrology_object [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("复制指标", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the copied metrology objects.")};
defARGINFO __arg_create_bead_inspection_model [] = {defArg("珠轮廓", dataTypeObj, 0, 0, "XLD contour specifying the expected bead's shape and position."),defArg("目标厚度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Optimal bead thickness."),defArg("厚度公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tolerance of bead's thickness with respect to TargetThickness."),defArg("位置公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tolerance of the bead's center position."),defArg("极性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The bead's polarity."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the bead inspection model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the bead inspection model."),defArg("焊缝检验模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle for using and accessing the bead inspection model.")};
defARGINFO __arg_create_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the metrology model.")};
defARGINFO __arg_deserialize_metrology_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the metrology model.")};
defARGINFO __arg_edges_color_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted edges."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Edge operator to be applied."),defArg("阿尔法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny')."),defArg("低的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation."),defArg("高的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation.")};
defARGINFO __arg_edges_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边缘", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted edges."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Edge operator to be applied."),defArg("平滑系数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter parameter: small values result in strong smoothing, and thus less detail (opposite for 'canny')."),defArg("低阀值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation."),defArg("高阀值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation.")};
defARGINFO __arg_get_bead_inspection_param [] = {defArg("焊缝检验模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bead inspection model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the model parameter that is queried."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the queried model parameter.")};
defARGINFO __arg_get_metrology_model_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the generic parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the generic parameter.")};
defARGINFO __arg_get_metrology_object_fuzzy_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_metrology_object_indices [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("指数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the metrology objects.")};
defARGINFO __arg_get_metrology_object_measures [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Rectangular XLD Contours of measure regions."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("过渡", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Select light/dark or dark/light edges."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the measured edges."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the measured edges.")};
defARGINFO __arg_get_metrology_object_model_contour [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Model contour."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology object."),defArg("分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance between neighboring contour points.")};
defARGINFO __arg_get_metrology_object_num_instances [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("实例个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of Instances of the metrology objects.")};
defARGINFO __arg_get_metrology_object_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_metrology_object_result [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology object."),defArg("实例", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Instance of the metrology object."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the generic parameter."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the generic parameter."),defArg("参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result values.")};
defARGINFO __arg_get_metrology_object_result_contour [] = {defArg("轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Result contour for the given metrology object."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology object."),defArg("实例", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Instance of the metrology object."),defArg("分辨率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance between neighboring contour points.")};
defARGINFO __arg_lines_color [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("线", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted lines."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of Gaussian smoothing to be applied."),defArg("低的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation."),defArg("高的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation."),defArg("提取宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the line width be extracted?"),defArg("完全交叉", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should junctions be added where they cannot be extracted?")};
defARGINFO __arg_lines_facet [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("线", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted lines."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of the facet model mask."),defArg("低的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation."),defArg("高的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation."),defArg("光暗", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extract bright or dark lines.")};
defARGINFO __arg_lines_gauss [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("线", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted lines."),defArg("西格玛", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of Gaussian smoothing to be applied."),defArg("低的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower threshold for the hysteresis threshold operation."),defArg("高的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper threshold for the hysteresis threshold operation."),defArg("光暗", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extract bright or dark lines."),defArg("提取宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the line width be extracted?"),defArg("线模型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Line model used to correct the line position and width."),defArg("完全交叉", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should junctions be added where they cannot be extracted?")};
defARGINFO __arg_read_metrology_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the metrology model.")};
defARGINFO __arg_reset_metrology_object_fuzzy_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects.")};
defARGINFO __arg_reset_metrology_object_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects.")};
defARGINFO __arg_serialize_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_bead_inspection_param [] = {defArg("焊缝检验模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bead inspection model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the model parameter that shall be adjusted for the specified bead inspection model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the model parameter that shall be adjusted for the specified bead inspection model.")};
defARGINFO __arg_set_metrology_model_image_size [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the image to be processed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the image to be processed.")};
defARGINFO __arg_set_metrology_model_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the generic parameter."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the generic parameter.")};
defARGINFO __arg_set_metrology_object_fuzzy_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_metrology_object_param [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_threshold_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("边界", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted level crossings."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the level crossings.")};
defARGINFO __arg_transform_metrology_object [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the metrology objects."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Translation in row direction."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Translation in column direction."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of the transformation.")};
defARGINFO __arg_write_metrology_model [] = {defArg("度量句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the metrology model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_zero_crossing_sub_pix [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("零点", dataTypeObj, 0, AS_RECEIVE_VAR, "Extracted zero crossings.")};
defARGINFO __arg_add_deformable_surface_model_reference_point [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("参考点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "x-coordinates of a reference point."),defArg("参考点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "x-coordinates of a reference point."),defArg("参考点Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "x-coordinates of a reference point."),defArg("参考点指数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the new reference point.")};
defARGINFO __arg_add_deformable_surface_model_sample [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformed 3D object model.")};
defARGINFO __arg_add_scene_3d_camera [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the new camera."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the new camera in the 3D scene.")};
defARGINFO __arg_add_scene_3d_instance [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the 3D object model."),defArg("实例索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the new instance in the 3D scene.")};
defARGINFO __arg_add_scene_3d_light [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("光源的位置", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Position of the new light source."),defArg("光源类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the new light source."),defArg("光源索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the new light source in the 3D scene.")};
defARGINFO __arg_affine_trans_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the 3D object models."),defArg("变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrices."),defArg("输出模型矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of the transformed 3D object models.")};
defARGINFO __arg_apply_sheet_of_light_calibration [] = {defArg("视差图", dataTypeObj, 0, 0, "Height or range image to be calibrated."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model.")};
defARGINFO __arg_area_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("面积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated area.")};
defARGINFO __arg_binocular_calibration [] = {defArg("NX", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all X-coordinates of the calibration marks (in meters)."),defArg("NY", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all Y-coordinates of the calibration marks (in meters)."),defArg("NZ", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all Z-coordinates of the calibration marks (in meters)."),defArg("N行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all row-coordinates of the extracted calibration marks of camera 1 (in pixels)."),defArg("N列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all column-coordinates of the extracted calibration marks of camera 1 (in pixels)."),defArg("N行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all row-coordinates of the extracted calibration marks of camera 2 (in pixels)."),defArg("N列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered Tuple with all column-coordinates of the extracted calibration marks of camera 2 (in pixels)."),defArg("相机1内参初始值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial values for the internal projective parameters of the projective camera 1."),defArg("相机2内参初始值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial values for the internal projective parameters of the projective camera 2."),defArg("相机1初始姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all initial values for the poses of the calibration model in relation to camera 1."),defArg("相机2初始姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Ordered tuple with all initial values for the poses of the calibration model in relation to camera 2."),defArg("估计参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters to be estimated."),defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal Parameters of the projective camera 1."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Internal parameters of the projective camera 2."),defArg("相机1持久姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ordered tuple with all poses of the calibration model in relation to camera 1."),defArg("相机2持久姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ordered tuple with all poses of the calibration model in relation to camera 2."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose of camera 2 in relation to camera 1."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average error distances in pixels.")};
defARGINFO __arg_binocular_disparity [] = {defArg("图像区域1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像区域2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("视差图", dataTypeObj, 0, AS_RECEIVE_VAR, "Disparity map."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Evaluation of the disparity values."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Matching function."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the correlation window."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the correlation window."),defArg("纹理脱粒", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Variance threshold of textured image regions."),defArg("最小视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum of the expected disparities."),defArg("最大视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum of the expected disparities."),defArg("金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels."),defArg("得分阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold of the correlation function."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Downstream filters."),defArg("亚像素插值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel interpolation of disparities.")};
defARGINFO __arg_binocular_disparity_mg [] = {defArg("图像区域1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像区域2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("视差图", dataTypeObj, 0, AS_RECEIVE_VAR, "Disparity map."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Score of the calculated disparity if CalculateScore is set to 'true'."),defArg("灰度常量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the gray value constancy in the data term."),defArg("梯度常量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the gradient constancy in the data term."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the smoothness term in relation to the data term."),defArg("初始猜测", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Initial guess of the disparity."),defArg("计算得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the quality measure should be returned in Score?"),defArg("MG参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the multigrid algorithm."),defArg("MG参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the multigrid algorithm.")};
defARGINFO __arg_binocular_disparity_ms [] = {defArg("图像区域1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像区域2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("视差图", dataTypeObj, 0, AS_RECEIVE_VAR, "Disparity map."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Score of the calculated disparity."),defArg("最小视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum of the expected disparities."),defArg("最大视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum of the expected disparities."),defArg("表面平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing of surfaces."),defArg("边缘平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing of edges."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the multi-scanline algorithm."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the multi-scanline algorithm.")};
defARGINFO __arg_binocular_distance [] = {defArg("图像1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("距离", dataTypeObj, 0, AS_RECEIVE_VAR, "Distance image."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Evaluation of a distance value."),defArg("相机1的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 1."),defArg("相机2的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 2."),defArg("精准位姿", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from the rectified camera 2 to the rectified camera 1."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Matching function."),defArg("掩码宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the correlation window."),defArg("掩码高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the correlation window."),defArg("纹理阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Variance threshold of textured image regions."),defArg("最小视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum of the expected disparities."),defArg("最大视差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum of the expected disparities."),defArg("级数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels."),defArg("得分阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold of the correlation function."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Downstream filters."),defArg("距离差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Distance interpolation.")};
defARGINFO __arg_binocular_distance_mg [] = {defArg("图像1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("距离", dataTypeObj, 0, AS_RECEIVE_VAR, "Distance image."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Score of the calculated disparity if CalculateScore is set to 'true'."),defArg("相机1的参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 1."),defArg("相机2的参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 2."),defArg("精准的位姿", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from the rectified camera 2 to the rectified camera 1."),defArg("恒定灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the gray value constancy in the data term."),defArg("恒定梯度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the gradient constancy in the data term."),defArg("平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weight of the smoothness term in relation to the data term."),defArg("初始猜测", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Initial guess of the disparity."),defArg("计算得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the quality measure be returned in Score?"),defArg("多重网格算法的参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the multigrid algorithm."),defArg("多重网格算法的参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the multigrid algorithm.")};
defARGINFO __arg_binocular_distance_ms [] = {defArg("图像1", dataTypeObj, 0, 0, "Rectified image of camera 1."),defArg("图像2", dataTypeObj, 0, 0, "Rectified image of camera 2."),defArg("距离", dataTypeObj, 0, AS_RECEIVE_VAR, "Distance image."),defArg("分数", dataTypeObj, 0, AS_RECEIVE_VAR, "Score of the calculated disparity."),defArg("相机1的参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 1."),defArg("相机2的参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 2."),defArg("相机的精准位置", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from the rectified camera 2 to the rectified camera 1."),defArg("最小的期望差距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum of the expected disparities."),defArg("最大的期望差距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum of the expected disparities."),defArg("表面平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing of surfaces."),defArg("边缘平滑", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing of edges."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name(s) for the multi-scanline algorithm."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value(s) for the multi-scanline algorithm.")};
defARGINFO __arg_calibrate_sheet_of_light [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average back projection error of the optimization.")};






defARGINFO __arg_clear_deformable_surface_matching_result [] = {defArg("变形表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface matching result.")};
defARGINFO __arg_clear_deformable_surface_model [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model.")};
defARGINFO __arg_clear_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model.")};
defARGINFO __arg_clear_scene_3d [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene.")};
defARGINFO __arg_clear_shape_model_3d [] = {defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model.")};
defARGINFO __arg_clear_sheet_of_light_model [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model.")};
defARGINFO __arg_clear_stereo_model [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model.")};
defARGINFO __arg_clear_surface_matching_result [] = {defArg("表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface matching result.")};
defARGINFO __arg_clear_surface_model [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model.")};
defARGINFO __arg_connection_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Attribute used to calculate the connected components."),defArg("值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum value for the distance between two connected components."),defArg("连接三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object models that represent the connected components.")};
defARGINFO __arg_convert_point_3d_cart_to_spher [] = {defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinate of the 3D point."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinate of the 3D point."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinate of the 3D point."),defArg("赤道平面法线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normal vector of the equatorial plane (points to the north pole)."),defArg("零子午线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Coordinate axis in the equatorial plane that points to the zero meridian."),defArg("经度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Longitude of the 3D point."),defArg("纬度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Latitude of the 3D point."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Radius of the 3D point.")};
defARGINFO __arg_convert_point_3d_spher_to_cart [] = {defArg("经度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Longitude of the 3D point."),defArg("纬度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Latitude of the 3D point."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the 3D point."),defArg("赤道平面法线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normal vector of the equatorial plane (points to the north pole)."),defArg("零子午线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Coordinate axis in the equatorial plane that points to the zero meridian."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the 3D point."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the 3D point."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the 3D point.")};
defARGINFO __arg_convex_hull_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("凸包三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model that describes the convex hull.")};
defARGINFO __arg_copy_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the input 3D object model."),defArg("属性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Attributes to be copyied."),defArg("复制对象模型D", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the copied 3D object model.")};
defARGINFO __arg_create_cam_pose_look_at_point [] = {defArg("相机姿态X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinate of the optical center of the camera."),defArg("相机姿态Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinate of the optical center of the camera."),defArg("相机姿态Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinate of the optical center of the camera."),defArg("视点X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "X coordinate of the 3D point to which the camera is directed."),defArg("视点Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Y coordinate of the 3D point to which the camera is directed."),defArg("视点Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Z coordinate of the 3D point to which the camera is directed."),defArg("参考平面法线", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normal vector of the reference plane (points up)."),defArg("相机转角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera roll angle."),defArg("相机姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D camera pose.")};
defARGINFO __arg_create_deformable_surface_model [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("相对采样距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sampling distance relative to the object's diameter"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the deformable surface model.")};
defARGINFO __arg_create_scene_3d [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D scene.")};
defARGINFO __arg_create_shape_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("参考方向X", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Reference orientation: Rotation around x-axis or x component of the Rodriguez vector (in radians or without unit)."),defArg("参考方向Y", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Reference orientation: Rotation around y-axis or y component of the Rodriguez vector (in radians or without unit)."),defArg("参考方向Z", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Reference orientation: Rotation around z-axis or z component of the Rodriguez vector (in radians or without unit)."),defArg("旋转顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Meaning of the rotation values of the reference orientation."),defArg("最小经度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum longitude of the model views."),defArg("最大经度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum longitude of the model views."),defArg("最小纬度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum latitude of the model views."),defArg("最大纬度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum latitude of the model views."),defArg("相机最小倾角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum camera roll angle of the model views."),defArg("相机最大倾角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum camera roll angle of the model views."),defArg("最小距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum camera-object-distance of the model views."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum camera-object-distance of the model views."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of (optional) parameters for controlling the behavior of the operator."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the optional generic parameters."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D shape model.")};
defARGINFO __arg_create_sheet_of_light_calib_object [] = {defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the object."),defArg("长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Length of the object."),defArg("最小高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum height of the ramp."),defArg("最大高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum height of the ramp."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filename of the model of the calibration object.")};
defARGINFO __arg_create_sheet_of_light_model [] = {defArg("区域", dataTypeObj, 0, 0, "Region of the images containing the profiles to be processed. If the provided region is not rectangular, its smallest enclosing rectangle will be used."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the sheet-of-light model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the sheet-of-light model."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle for using and accessing the sheet-of-light model.")};
defARGINFO __arg_create_stereo_model [] = {defArg("相机设置模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle to the camera setup model."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Reconstruction method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the model parameter to be set."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the model parameter to be set."),defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the stereo model.")};
defARGINFO __arg_create_surface_model [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("相对采样距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sampling distance relative to the object's diameter"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the surface model.")};
defARGINFO __arg_depth_from_focus [] = {defArg("多聚焦图像", dataTypeObj, 0, 0, "Multichannel gray image consisting of multiple focus levels."),defArg("深度", dataTypeObj, 0, AS_RECEIVE_VAR, "Depth image."),defArg("置信度", dataTypeObj, 0, AS_RECEIVE_VAR, "Confidence of depth estimation."),defArg("滤波器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Filter used to find sharp pixels."),defArg("选择", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method used to find sharp pixels.")};
defARGINFO __arg_deserialize_deformable_surface_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the deformable surface model.")};
defARGINFO __arg_deserialize_object_model_3d [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model.")};
defARGINFO __arg_deserialize_shape_model_3d [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D shape model.")};
defARGINFO __arg_deserialize_sheet_of_light_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the sheet-of-light model.")};
defARGINFO __arg_deserialize_surface_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the surface model.")};
defARGINFO __arg_disparity_image_to_xyz [] = {defArg("视差图", dataTypeObj, 0, 0, "Disparity image."),defArg("X", dataTypeObj, 0, AS_RECEIVE_VAR, "X coordinates of the points in the rectified camera system 1."),defArg("Y", dataTypeObj, 0, AS_RECEIVE_VAR, "Y coordinates of the points in the rectified camera system 1."),defArg("Z", dataTypeObj, 0, AS_RECEIVE_VAR, "Z coordinates of the points in the rectified camera system 1."),defArg("相机1内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 1."),defArg("相机2内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters of the rectified camera 2."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the rectified camera 2 in relation to the rectified camera 1.")};
defARGINFO __arg_disparity_to_distance [] = {defArg("相机1的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rectified internal camera parameters of the projective camera 1."),defArg("相机2的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rectified internal camera parameters of the projective camera 2."),defArg("精准姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from the rectified camera 2 to the rectified camera 1."),defArg("视差图", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Disparity between the images of the world point."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of a world point to the rectified camera system.")};
defARGINFO __arg_disparity_to_point_3d [] = {defArg("相机1内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rectified internal camera parameters of the projective camera 1."),defArg("相机2内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rectified internal camera parameters of the projective camera 2."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the rectified camera 2 in relation to the rectified camera 1."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of a point in the rectified image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of a point in the rectified image 1."),defArg("视差图", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Disparity of the images of the world point."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the 3D point."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the 3D point."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the 3D point.")};
defARGINFO __arg_display_scene_3d [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera used to display the scene.")};
defARGINFO __arg_disp_object_model_3d [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the 3D object models."),defArg("相机内参", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters of the scene."),defArg("姿态", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "3D poses of the objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_distance_object_model_3d [] = {defArg("3D对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the source 3D object model."),defArg("3D目标模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the target 3D object model."),defArg("姿态", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pose of the source 3D object model in the target 3D object model."),defArg("最大距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum distance of interest."),defArg("通用参数名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic input parameters."),defArg("通用的参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic input parameters.")};
defARGINFO __arg_distance_to_disparity [] = {defArg("相机1的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "rectified internal camera parameters of the projective camera 1."),defArg("相机2的精准参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "rectified internal camera parameters of the projective camera 2."),defArg("精准位姿", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from the rectified camera 2 to the rectified camera 1."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Distance of a world point to camera 1."),defArg("视差图", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Disparity between the images of the point.")};
defARGINFO __arg_essential_to_fundamental_matrix [] = {defArg("本质矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Essential matrix."),defArg("本质矩阵协方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "9x9 covariance matrix of the essential matrix."),defArg("相机1矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 1. camera."),defArg("相机2矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 2. camera."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the fundamental matrix.")};
defARGINFO __arg_estimate_al_am [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which albedo and ambient are to be estimated."),defArg("反照率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Amount of light reflected by the surface."),defArg("环境光", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Amount of ambient light.")};
defARGINFO __arg_estimate_sl_al_lr [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which slant and albedo are to be estimated."),defArg("倾斜", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the light sources and the positive z-axis (in degrees)."),defArg("反照率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Amount of light reflected by the surface.")};
defARGINFO __arg_estimate_sl_al_zc [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which slant and albedo are to be estimated."),defArg("倾斜", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle of the light sources and the positive z-axis (in degrees)."),defArg("反照率", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Amount of light reflected by the surface.")};
defARGINFO __arg_estimate_tilt_lr [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the tilt is to be estimated."),defArg("倾斜", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees).")};
defARGINFO __arg_estimate_tilt_zc [] = {defArg("图像", dataTypeObj, 0, 0, "Image for which the tilt is to be estimated."),defArg("倾斜", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees).")};
defARGINFO __arg_find_deformable_surface_model [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing the scene."),defArg("相对采样距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scene sampling distance relative to the diameter of the surface model."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the returned match."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the surface model."),defArg("变形表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, " Handle of the matching result.")};
defARGINFO __arg_find_shape_model_3d [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the model to be found."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of (optional) parameters for controlling the behavior of the operator."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the optional generic parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the 3D shape model."),defArg("姿态协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "6 standard deviations or 36 covariances of the pose parameters."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the 3D shape model.")};
defARGINFO __arg_find_surface_model [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing the scene."),defArg("相对采样距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scene sampling distance relative to the diameter of the surface model."),defArg("关键分数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Fraction of sampled scene points used as key points."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the returned poses."),defArg("返回结果句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable returning a result handle in SurfaceMatchingResultID."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the surface model in the scene."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the surface model."),defArg("表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the matching result, if enabled in ReturnResultHandle.")};
defARGINFO __arg_fit_primitives_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the input 3D object model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("对象模型的输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the output 3D object model.")};
defARGINFO __arg_gen_binocular_proj_rectification [] = {defArg("图1编码", dataTypeObj, 0, AS_RECEIVE_VAR, "Image coding the rectification of the 1. image."),defArg("图2编码", dataTypeObj, 0, AS_RECEIVE_VAR, "Image coding the rectification of the 2. image."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "9x9 covariance matrix of the fundamental matrix."),defArg("图像1宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the 1. image."),defArg("图像1高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the 1. image."),defArg("图像2宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the 2. image."),defArg("图像2高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the 2. image."),defArg("下采样因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subsampling factor."),defArg("映射", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of mapping."),defArg("修正基本矩阵协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the rectified fundamental matrix."),defArg("H1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Projective transformation of the 1. image."),defArg("H2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Projective transformation of the 2. image.")};
defARGINFO __arg_gen_binocular_rectification_map [] = {defArg("图像1映射数据", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data of camera 1."),defArg("图像2映射数据", dataTypeObj, 0, AS_RECEIVE_VAR, "Image containing the mapping data of camera 2."),defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal parameters of the projective camera 1."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal parameters of the projective camera 2."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from camera 2 to camera 1."),defArg("下采样因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Factor of sub sampling."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of rectification."),defArg("映射类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of mapping."),defArg("相机1内参", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rectified internal parameters of the projective camera 1."),defArg("相机2内参", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rectified internal parameters of the projective camera 2."),defArg("相机1姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Point transformation from the rectified camera 1 to 			the original camera 1."),defArg("相机2姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Point transformation from the rectified camera 1 to 			the original camera 1."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Point transformation from the rectified camera 2 to 			the rectified camera 1.")};
defARGINFO __arg_gen_box_object_model_3d [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The pose that describes the position and orientation of the box. The pose has its origin in the center of the box."),defArg("沿X轴长度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The length of the box along the x-axis."),defArg("沿Y轴长度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The length of the box along the y-axis."),defArg("沿Z轴长度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The length of the box along the z-axis."),defArg("对象3D模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_gen_cylinder_object_model_3d [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The pose that describes the position and orientation of the cylinder."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The radius of the cylinder."),defArg("最小范围", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The length of the cylinder in negative direction of the rotation axis."),defArg("最大范围", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The length of the cylinder in positive direction of the rotation axis."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_gen_empty_object_model_3d [] = {defArg("空三维模型对象", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the new 3D object model.")};
defARGINFO __arg_gen_object_model_3d_from_points [] = {defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The x-coodinates of the points in the 3D point cloud."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The y-coodinates of the points in the 3D point cloud."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The z-coodinates of the points in the 3D point cloud."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_gen_plane_object_model_3d [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The center and the rotation of the plane."),defArg("x范围", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "x coordinates specifying the extent of the plane."),defArg("y范围", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "y coordinates specifying the extent of the plane."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_gen_sphere_object_model_3d [] = {defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The pose that describes the position of the sphere."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The radius of the sphere."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_gen_sphere_object_model_3d_center [] = {defArg("X", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The x-coodinate of the center point of the sphere."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The y-coodinate of the center point of the sphere."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The z-coodinate of the center point of the sphere."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The radius of the sphere."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_get_circle_pose [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contours to be examined."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Radius of the circle in object space."),defArg("输出类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of output parameters."),defArg("姿态1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the first circle."),defArg("姿态2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the second circle.")};
defARGINFO __arg_get_deformable_surface_matching_result [] = {defArg("变形表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface matching result."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the result property."),defArg("结果索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the result property."),defArg("结果值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the result property.")};
defARGINFO __arg_get_deformable_surface_model_param [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the parameter.")};
defARGINFO __arg_get_display_scene_3d_info [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates."),defArg("信息", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Information."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices or the depth of the objects at (Row,Column).")};
defARGINFO __arg_get_disp_object_model_3d_info [] = {defArg("窗口句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Window identifier."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates."),defArg("信息", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Information."),defArg("值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices or the depth of the objects at (Row,Column).")};
defARGINFO __arg_get_object_model_3d_params [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic attributes that are queried for the 3D object model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_rectangle_pose [] = {defArg("轮廓", dataTypeObj, 0, 0, "Contour(s) to be examined."),defArg("相机参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle in meters."),defArg("高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle in meters."),defArg("加权模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Weighting mode for the optimization phase."),defArg("裁剪因子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Clipping factor for the elimination of outliers (typical: 1.0 for 'huber' and 3.0 for 'tukey')."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the rectangle."),defArg("姿态协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariances of the pose values."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-mean-square value of the final residual error.")};
defARGINFO __arg_get_shape_model_3d_contours [] = {defArg("模型的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour representation of the model view."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pyramid level for which the contour representation should be returned."),defArg("视图", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "View for which the contour representation should be returned."),defArg("视图姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the 3D shape model at the current view.")};
defARGINFO __arg_get_shape_model_3d_params [] = {defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that are to be queried for the 3D shape model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_sheet_of_light_param [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the generic parameter that shall be queried."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the model parameter that shall be queried.")};
defARGINFO __arg_get_sheet_of_light_result [] = {defArg("结果值", dataTypeObj, 0, AS_RECEIVE_VAR, "Desired measurement result."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model to be used."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Specify which result of the measurement shall be provided.")};
defARGINFO __arg_get_sheet_of_light_result_object_model_3d [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle for accessing the sheet-of-light model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_get_stereo_model_image_pairs [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("从", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Camera indices for the from cameras in the image pairs."),defArg("到", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Camera indices for the to cameras in the image pairs.")};
defARGINFO __arg_get_stereo_model_object [] = {defArg("对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Iconic result."),defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("对指数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera indices of the pair ([From, To])."),defArg("对象名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the iconic result to be returned.")};
defARGINFO __arg_get_stereo_model_param [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the parameters to be set."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the parameters to be set.")};
defARGINFO __arg_get_surface_matching_result [] = {defArg("表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface matching result."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the result property."),defArg("结果索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the matching result, starting with 0."),defArg("结果值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the result property.")};
defARGINFO __arg_get_surface_model_param [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the parameter.")};
defARGINFO __arg_intersect_lines_of_sight [] = {defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal parameters of the projective camera 1."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal parameters of the projective camera 2."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Point transformation from camera 2 to camera 1."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of a point in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of a point in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the corresponding point in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the corresponding point in image 2."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinate of the 3D point."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinate of the 3D point."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinate of the 3D point."),defArg("距离", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Distance of the 3D point to the lines of sight.")};
defARGINFO __arg_intersect_plane_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("平面", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pose of the plane."),defArg("交叉三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model that describes the intersection as a set of lines.")};
defARGINFO __arg_match_essential_matrix_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 2."),defArg("相机1矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 1st camera."),defArg("相机2矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 2nd camera."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value comparison metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate shift of corresponding points."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate shift of corresponding points."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimate of the relative orientation of the right image with respect to the left image."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the essential matrix and for special camera orientations."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal deviation of a point from its epipolar line."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("本质矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed essential matrix."),defArg("本质矩阵协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the essential matrix."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_match_fundamental_matrix_distortion_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value match metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate offset of corresponding points."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate offset of corresponding points."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimate of the relative rotation of the second image with respect to the first image."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the fundamental matrix and for special camera orientations."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal deviation of a point from its epipolar line."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed radial distortion coefficient."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square epipolar distance error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_match_fundamental_matrix_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 2."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value comparison metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate shift of corresponding points."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate shift of corresponding points."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimate of the relative orientation of the right image with respect to the left image."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the fundamental matrix and for special camera orientations."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal deviation of a point from its epipolar line."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the fundamental matrix."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_match_rel_pose_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 2."),defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the 1st camera."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the 2nd camera."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value comparison metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate shift of corresponding points."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate shift of corresponding points."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimate of the relative orientation of the right image with respect to the left image."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the relative pose and for special pose types."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal deviation of a point from its epipolar line."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed relative orientation of the cameras (3D pose)."),defArg("协方差相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "6x6 covariance matrix of the relative orientation."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_max_diameter_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("直径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated diameter.")};
defARGINFO __arg_measure_profile_sheet_of_light [] = {defArg("轮廓图像", dataTypeObj, 0, 0, "Input image."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("运动姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose describing the movement of the scene under measurement between the previously processed profile image and the current profile image.")};
defARGINFO __arg_moments_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("矩的计算", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Moment to calculate."),defArg("几何矩", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated moment.")};
defARGINFO __arg_object_model_3d_to_xyz [] = {defArg("X", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with the X-Coordinates of the 3D points."),defArg("Y", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with the Y-Coordinates of the 3D points."),defArg("Z", dataTypeObj, 0, AS_RECEIVE_VAR, "Image with the Z-Coordinates of the 3D points."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the conversion."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the 3D object model.")};
defARGINFO __arg_photometric_stereo [] = {defArg("图像", dataTypeObj, 0, 0, "Array with at least three input images with different directions of illumination."),defArg("高度场", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("梯度", dataTypeObj, 0, AS_RECEIVE_VAR, "The gradient field of the surface."),defArg("反照率", dataTypeObj, 0, AS_RECEIVE_VAR, "The albedo of the surface."),defArg("偏", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the object plane and the direction of illumination (in degrees)."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle of the direction of illumination within the object plane (in degrees)."),defArg("结果类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Types of the requested results."),defArg("重建方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the reconstruction method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_phot_stereo [] = {defArg("图像", dataTypeObj, 0, 0, "Shaded input image with at least three channels."),defArg("高度", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("偏", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light sources and the positive z-axis (in degrees)."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees).")};
defARGINFO __arg_prepare_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("目的", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Purpose of the 3D object model."),defArg("重写数据", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Specify if already existing data should be overwritten."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_projective_trans_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the 3D object models."),defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Homogeneous projective transformation matrix."),defArg("结果三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of the transformed 3D object models.")};
defARGINFO __arg_project_object_model_3d [] = {defArg("模型的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Projected model contours."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the generic parameter."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the generic parameter.")};
defARGINFO __arg_project_shape_model_3d [] = {defArg("模型的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour representation of the model view."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the 3D shape model in the world coordinate system."),defArg("隐藏表面去除", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Remove hidden surfaces?"),defArg("最小的面角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest face angle for which the edge is displayed")};
defARGINFO __arg_query_sheet_of_light_params [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("查询名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter group."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List containing the names of the supported generic parameters.")};
defARGINFO __arg_read_deformable_surface_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file to read."),defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the read deformable surface model.")};
defARGINFO __arg_read_object_model_3d [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Filename of the file to be read."),defArg("规模", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale of the data in the file."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model."),defArg("地位", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status information.")};
defARGINFO __arg_read_object_model_3d_dxf [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the DXF file"),defArg("规模", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale or unit."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the DXF input."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the DXF input."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the read 3D object model."),defArg("DXF文件的状态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Status information.")};
defARGINFO __arg_read_shape_model_3d [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D shape model.")};
defARGINFO __arg_read_sheet_of_light_model [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the sheet-of-light model file."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the sheet-of-light model.")};
defARGINFO __arg_read_surface_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the SFM file."),defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the read surface model.")};
defARGINFO __arg_reconst3d_from_fundamental_matrix [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "9x9 covariance matrix of the fundamental matrix."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed points in projective 3D space."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed points in projective 3D space."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed points in projective 3D space."),defArg("W", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "W coordinates of the reconstructed points in projective 3D space."),defArg("重建点的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrices of the reconstructed points.")};
defARGINFO __arg_reconstruct_height_field_from_gradient [] = {defArg("梯度", dataTypeObj, 0, 0, "The gradient field of the image."),defArg("高度场", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("重建方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the reconstruction method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_reconstruct_points_stereo [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of the detected points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of the detected points."),defArg("点协方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance matrices of the detected points."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the observing cameras."),defArg("点编号", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the observed world points."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed 3D points."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed 3D points."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed 3D points."),defArg("结果三位点协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrices of the reconstructed 3D points."),defArg("三维点索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of the reconstructed 3D points.")};
defARGINFO __arg_reconstruct_surface_stereo [] = {defArg("图像", dataTypeObj, 0, 0, "An image array acquired by the camera setup associated to the stereo model."),defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle to the resulting surface.")};
defARGINFO __arg_reduce_object_model_3d_by_view [] = {defArg("区域", dataTypeObj, 0, 0, "Region in the image plane."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Internal camera parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D pose of the world coordinate system in camera coordinates."),defArg("减少三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the reduced 3D object model.")};
defARGINFO __arg_refine_deformable_surface_model [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing the scene."),defArg("相对采样距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Relative sampling distance of the scene."),defArg("初始变形对象模型D", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial deformation of the 3D object model"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the refined model."),defArg("变形表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the matching result.")};
defARGINFO __arg_refine_surface_model_pose [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing the scene."),defArg("初始姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Initial pose of the surface model in the scene."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the returned poses."),defArg("返回结果句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Enable returning a result handle in SurfaceMatchingResultID."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the surface model in the scene."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model."),defArg("表面匹配结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the matching result, if enabled in ReturnResultHandle.")};
defARGINFO __arg_register_object_model_3d_global [] = {defArg("对象模型D", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of several 3D object models."),defArg("三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Approximate relative transformations between the 3D object models."),defArg("从", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of interpretation for the transformations."),defArg("到", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Target indices of the transformations if From specifies the source indices, otherwise the parameter must be empty."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the global 3D object model registration."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the global 3D object model registration."),defArg("输出三维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Resulting Transformations."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of overlapping neighbors for each 3D object model.")};
defARGINFO __arg_register_object_model_3d_pair [] = {defArg("对象模型D1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the first 3D object model."),defArg("对象模型D2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the second 3D object model."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method for the registration."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose to transform ObjectModel3D1 in the reference frame of ObjectModel3D2."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Overlapping of the two 3D object models.")};
defARGINFO __arg_rel_pose_to_fundamental_matrix [] = {defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Relative orientation of the cameras (3D pose)."),defArg("协方差相对姿态", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "6x6 covariance matrix of relative pose."),defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the 1. camera."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameters of the 2. camera."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the fundamental matrix.")};
defARGINFO __arg_remove_scene_3d_camera [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera to remove.")};
defARGINFO __arg_remove_scene_3d_instance [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("实例索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the instance to remove.")};
defARGINFO __arg_remove_scene_3d_light [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("光源索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Light to remove.")};
defARGINFO __arg_render_object_model_3d [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Rendered scene."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the 3D object models."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters of the scene."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "3D poses of the objects."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_render_scene_3d [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Rendered 3D scene."),defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera used to display the scene.")};
defARGINFO __arg_reset_sheet_of_light_model [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model.")};
defARGINFO __arg_rigid_trans_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the 3D object models."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Poses."),defArg("结果三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of the transformed 3D object models.")};
defARGINFO __arg_sample_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model to be sampled."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Selects between the different subsampling methods."),defArg("样品的距离", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Sampling distance."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted."),defArg("采样对象模型D", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model that contains the sampled points.")};
defARGINFO __arg_segment_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the input 3D object model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("对象模型的输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the output 3D object model.")};
defARGINFO __arg_select_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handles of the available 3D object models to select."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features a test is performed on."),defArg("操作", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Logical operation to combine the features given in Feature."),defArg("最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum value for the given feature."),defArg("最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum value for the given feature."),defArg("选择器三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "A subset of ObjectModel3D fulfilling the given conditions.")};
defARGINFO __arg_select_points_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object models."),defArg("属性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Attributes the threshold is applied to."),defArg("最小值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum value for the attributes specified by Attrib."),defArg("最大值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum value for the attributes specified by Attrib."),defArg("结果三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the reduced 3D object models.")};
defARGINFO __arg_serialize_deformable_surface_model [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_shape_model_3d [] = {defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_sheet_of_light_model [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_surface_model [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_object_model_3d_attrib [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the input 3D object model."),defArg("属性名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the attributes."),defArg("附加扩展属性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Defines where extended attributes are attached to."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Attribute values."),defArg("对象模型的输出", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_set_object_model_3d_attrib_mod [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("属性名称", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the attributes."),defArg("附加扩展属性", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Defines where extended attributes are attached to."),defArg("属性值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Attribute values.")};
defARGINFO __arg_set_profile_sheet_of_light [] = {defArg("简介视差图像", dataTypeObj, 0, 0, "Disparity image that contains several profiles."),defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("运动的姿势", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Poses describing the movement of the scene under measurement between the previously processed profile image and the current profile image.")};
defARGINFO __arg_set_scene_3d_camera_pose [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("相机索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the camera."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "New pose of the camera.")};
defARGINFO __arg_set_scene_3d_instance_param [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("实例索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the instance."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_scene_3d_instance_pose [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("实例索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the instance."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "New pose of the instance.")};
defARGINFO __arg_set_scene_3d_light_param [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("光源索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the light source."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_scene_3d_param [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_set_scene_3d_to_world_pose [] = {defArg("三维场景", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D scene."),defArg("世界的姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "New pose of the 3D scene.")};
defARGINFO __arg_set_sheet_of_light_param [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the model parameter that shall be adjusted for the sheet-of-light model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the model parameter that shall be adjusted for the sheet-of-light model.")};
defARGINFO __arg_set_stereo_model_image_pairs [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("从", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera indices for the from cameras in the image pairs."),defArg("到", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera indices for the to cameras in the image pairs.")};
defARGINFO __arg_set_stereo_model_param [] = {defArg("立体模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the stereo model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the parameters to be set."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Values of the parameters to be set.")};
defARGINFO __arg_sfs_mod_lr [] = {defArg("图像", dataTypeObj, 0, 0, "Shaded input image."),defArg("高度", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the positive z-axis (in degrees)."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees)."),defArg("反照率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of light reflected by the surface."),defArg("环境", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of ambient light.")};
defARGINFO __arg_sfs_orig_lr [] = {defArg("图像", dataTypeObj, 0, 0, "Shaded input image."),defArg("高度", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the positive z-axis (in degrees)."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees)."),defArg("反照率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of light reflected by the surface."),defArg("环境", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of ambient light.")};
defARGINFO __arg_sfs_pentland [] = {defArg("图像", dataTypeObj, 0, 0, "Shaded input image."),defArg("高度", dataTypeObj, 0, AS_RECEIVE_VAR, "Reconstructed height field."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the positive z-axis (in degrees)."),defArg("倾斜", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle between the light source and the x-axis after projection into the xy-plane (in degrees)."),defArg("反照率", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of light reflected by the surface."),defArg("环境", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Amount of ambient light.")};
defARGINFO __arg_simplify_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model that should be simplified."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method that should be used for simplification."),defArg("数量", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Degree of simplification (default: percentage of remaining model points)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("简化的对象模型D", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the simplified 3D object model.")};
defARGINFO __arg_smallest_bounding_box_object_model_3d [] = {defArg("对象3D模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The method that is used to estimate the smallest box."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The pose that describes the position and orientation of the box that is generated. The pose has its origin in the center of the box and is oriented such that the x-axis is aligned with the longest side of the box."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The length of the longest side of the box."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The length of the second longest side of the box."),defArg("长度3", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The length of the third longest side of the box.")};
defARGINFO __arg_smallest_sphere_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("中心点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "x-, y-, and z-coordinates describing the center point of the sphere."),defArg("半径", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The estimated radius of the sphere.")};
defARGINFO __arg_smooth_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing 3D point data."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smoothing method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic smoothing parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic smoothing parameters."),defArg("光滑物体模型D", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model with the smoothed 3D point data.")};
defARGINFO __arg_surface_normals_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing 3D point data."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Normals calculation method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic smoothing parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic smoothing parameters."),defArg("三维对象模型法线", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model with calculated 3D normals.")};
defARGINFO __arg_trans_pose_shape_model_3d [] = {defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("输入姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose to be transformed in the source system."),defArg("转化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Direction of the transformation."),defArg("输出姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Transformed 3D pose in the target system.")};
defARGINFO __arg_triangulate_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model containing 3D point data."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Triangulation method."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic triangulation parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic triangulation parameters."),defArg("三角化三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model with the triangulated surface."),defArg("信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Additional information about the triangulation process.")};
defARGINFO __arg_union_object_model_3d [] = {defArg("对象模型D", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of input 3D object models."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method used for the union."),defArg("联盟对象模型D", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the resulting 3D object model.")};
defARGINFO __arg_vector_to_essential_matrix [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("相机1矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 1st camera."),defArg("相机2矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera matrix of the 2nd camera."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the essential matrix and for special camera orientations."),defArg("本质矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed essential matrix."),defArg("本质矩阵协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the essential matrix."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed 3D points."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed 3D points."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed 3D points."),defArg("重建点的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrices of the reconstructed 3D points.")};
defARGINFO __arg_vector_to_fundamental_matrix [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("基本矩阵的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "9x9 covariance matrix of the fundamental matrix."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed points in projective 3D space."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed points in projective 3D space."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed points in projective 3D space."),defArg("W", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "W coordinates of the reconstructed points in projective 3D space."),defArg("重建点的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrices of the reconstructed 3D points.")};
defARGINFO __arg_vector_to_fundamental_matrix_distortion [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("图像宽度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Width of the images from which the points were extracted."),defArg("图像高度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Height of the images from which the points were extracted."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimation algorithm."),defArg("基本矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed fundamental matrix."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed radial distortion coefficient."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square epipolar distance error."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed points in projective 3D space."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed points in projective 3D space."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed points in projective 3D space."),defArg("W", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "W coordinates of the reconstructed points in projective 3D space.")};
defARGINFO __arg_vector_to_rel_pose [] = {defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("行1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 1."),defArg("协方差1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 1."),defArg("列1方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 1."),defArg("行2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate variance of the points in image 2."),defArg("协方差2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Covariance of the points in image 2."),defArg("列2方差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate variance of the points in image 2."),defArg("相机1参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters of the 1st camera."),defArg("相机2参数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera parameters of the 2nd camera."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the relative pose and for special pose types."),defArg("相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed relative orientation of the cameras (3D pose)."),defArg("协方差相对姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "6x6 covariance matrix of the relative camera orientation."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square of the epipolar distance error."),defArg("X", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "X coordinates of the reconstructed 3D points."),defArg("Y", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Y coordinates of the reconstructed 3D points."),defArg("Z", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Z coordinates of the reconstructed 3D points."),defArg("重建点的协方差矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Covariance matrices of the reconstructed 3D points.")};
defARGINFO __arg_volume_object_model_3d_relative_to_plane [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("平面", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pose of the plane."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to combine volumes laying above and below the reference plane."),defArg("使用表面方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Decides whether the orientation of a face should affect the resulting sign of the underlying volume."),defArg("体积", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Calculated volume.")};
defARGINFO __arg_write_deformable_surface_model [] = {defArg("可变形表面模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the deformable surface model to write."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name to write to.")};
defARGINFO __arg_write_object_model_3d [] = {defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D object model."),defArg("文件类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the file that is written."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Name of the file that is written."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters.")};
defARGINFO __arg_write_shape_model_3d [] = {defArg("三维形状模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 3D shape model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_sheet_of_light_model [] = {defArg("光模型标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sheet-of-light model."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the sheet-of-light model file.")};
defARGINFO __arg_write_surface_model [] = {defArg("表面模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the surface model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_xyz_to_object_model_3d [] = {defArg("X", dataTypeObj, 0, 0, "Image with the X-Coordinates and the ROI of the 3D points."),defArg("Y", dataTypeObj, 0, 0, "Image with the Y-Coordinates of the 3D points."),defArg("Z", dataTypeObj, 0, 0, "Image with the Z-Coordinates of the 3D points."),defArg("三维对象模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 3D object model.")};

defARGINFO __arg_clear_bar_code_model [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model.")};
defARGINFO __arg_create_bar_code_model [] = {defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the bar code model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the bar code model."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle for using and accessing the bar code model.")};
defARGINFO __arg_decode_1d_bar_code [] = {defArg("条形码元素", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Widths of the elements of the bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Decoded characters in standard interpretation."),defArg("参考", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Decoded characters as numbers."),defArg("是正确的", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information whether the bar code is correct.")};
defARGINFO __arg_decode_bar_code_rectangle2 [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("代码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the searched bar code."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Row index of the center."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Column index of the center."),defArg("方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Orientation of rectangle in radians."),defArg("长度1", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half of the length of the rectangle along the reading direction of the bar code."),defArg("长度2", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half of the length of the rectangle perpendicular to the reading direction of the bar code."),defArg("解码数据串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Data strings of all successfully decoded bar codes.")};
defARGINFO __arg_deserialize_bar_code_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the bar code model.")};
defARGINFO __arg_discrete_1d_bar_code [] = {defArg("元素", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "List of elements widths of the bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("离散的条形码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Widths of elements as multiple of modules.")};
defARGINFO __arg_find_1d_bar_code [] = {defArg("图像", dataTypeObj, 0, 0, "Image with bar code inside."),defArg("编码区", dataTypeObj, 0, AS_RECEIVE_VAR, "Region of bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional control parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional control parameters."),defArg("条码发现", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information whether the bar code was found."),defArg("条形码元素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Widths of elements."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of bar code.")};
defARGINFO __arg_find_1d_bar_code_region [] = {defArg("图像", dataTypeObj, 0, 0, "Image with bar codes inside."),defArg("编码区", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions of bar codes."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional parameters."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of bar code.")};
defARGINFO __arg_find_1d_bar_code_scanline [] = {defArg("图像", dataTypeObj, 0, 0, "Image with bar code inside."),defArg("编码区", dataTypeObj, 0, AS_RECEIVE_VAR, "Region of bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional control parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional control parameters."),defArg("如果发现停止", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Leave operator as soon as the bar code has been decoded?."),defArg("条码发现", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information whether the bar code was found."),defArg("条形码元素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Widths of elements."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of bar code."),defArg("扫描线点数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of points belonging to that scanline."),defArg("扫描解码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information whether the bar code could be decoded with that scanline."),defArg("扫描线点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row - coordinates of the points of the scanline."),defArg("扫描线点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column - coordinates of the points of the scanline.")};
defARGINFO __arg_find_bar_code [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("标志区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions of the successfully decoded bar code symbols."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("代码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the searched bar code."),defArg("解码数据串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Data strings of all successfully decoded bar codes.")};
defARGINFO __arg_gen_1d_bar_code_descr [] = {defArg("代码名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of bar code."),defArg("最小字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum number of characters (if not fixed)."),defArg("最大的特点", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of characters (if not fixed)."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Description of a bar code class.")};
defARGINFO __arg_gen_1d_bar_code_descr_gen [] = {defArg("最小码长", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum length of the code in modules (including start and stop elements)."),defArg("最大编码长度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum length of the code in modules (including start and stop elements)."),defArg("元素的大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of different element sizes."),defArg("起始元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of elements of the start sequence. The width of an element is given as the number of modules. Gaps are given as negative values."),defArg("停止元素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of elements of the stop sequence. The width of an element is given as the number of modules. Gaps are given as negative values."),defArg("最大尺寸比", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum ratio length to height."),defArg("离散编码", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Discrete code (ignore white elements)."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Description of a bar code class.")};
defARGINFO __arg_get_1d_bar_code [] = {defArg("条码区域", dataTypeObj, 0, 0, "Region of bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional parameters."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of bar code."),defArg("条形码元素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Widths of elements.")};
defARGINFO __arg_get_1d_bar_code_scanline [] = {defArg("条码区域", dataTypeObj, 0, 0, "Region of bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a bar code class."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional parameters."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Orientation of bar code."),defArg("如果发现停止", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Leave operator as soon as the bar code has been decoded?."),defArg("条形码元素", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Widths of elements."),defArg("扫描行点数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of points belonging to that scanline."),defArg("扫描解码", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information whether the bar code could be decoded with that scanline."),defArg("扫描线点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row - coordinates of the points of the scanline."),defArg("扫描线点列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column - coordinates of the points of the scanline.")};
defARGINFO __arg_get_bar_code_object [] = {defArg("条形码对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Objects that are created as intermediate results during the detection or evaluation of bar codes."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("候选句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indicating the bar code results respectively candidates for which the data is required."),defArg("对象名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the iconic object to return.")};
defARGINFO __arg_get_bar_code_param [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that are to be queried for the bar code model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_bar_code_param_specific [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("代码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the bar code types for which parameters should be queried."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that are to be queried for the bar code model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_bar_code_result [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("候选句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indicating the bar code results respectively candidates for which the data is required."),defArg("结果名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the resulting data to return."),defArg("条形码的结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List with the results.")};
defARGINFO __arg_query_bar_code_params [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("性能", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Properties of the parameters."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the generic parameters.")};
defARGINFO __arg_read_bar_code_model [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the bar code model file."),defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the bar code model.")};
defARGINFO __arg_serialize_bar_code_model [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_bar_code_param [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that shall be adjusted for finding and decoding bar codes."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that are adjusted for finding and decoding bar codes.")};
defARGINFO __arg_set_bar_code_param_specific [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("代码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the bar code types for which parameters should be set."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that shall be adjusted for finding and decoding bar codes."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that are adjusted for finding and decoding bar codes.")};
defARGINFO __arg_write_bar_code_model [] = {defArg("条码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the bar code model."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the bar code model file.")};

defARGINFO __arg_clear_data_code_2d_model [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model.")};
defARGINFO __arg_create_data_code_2d_model [] = {defArg("符号类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the 2D data code."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the 2D data code model."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the 2D data code model."),defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle for using and accessing the 2D data code model.")};
defARGINFO __arg_decode_2d_bar_code [] = {defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of the bar code class."),defArg("条码尺寸", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple with the dimension of the examined symbol. In the case of ECC 200: width, height, symbol code."),defArg("条码数据", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Tuple with the data values of the examined symbol."),defArg("符号字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Data and error codewords of the symbol."),defArg("正确的符号数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Corrected data codewords of the symbol."),defArg("解码后的数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Decoded data characters as numbers."),defArg("解码错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of errors during the decoding process."),defArg("结构化的追加", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "If the symbol belongs to a group (\"structured append\"): position in the group, total symbol number, group (\"file\") id.")};
defARGINFO __arg_deserialize_data_code_2d_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the 2D data code model.")};
defARGINFO __arg_find_2d_bar_code [] = {defArg("图像", dataTypeObj, 0, 0, "Image of one or more bar codes."),defArg("编码区", dataTypeObj, 0, AS_RECEIVE_VAR, "Regions that might contain a bar code."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of a 2D bar code class to look for."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of names of (optional) generic parameters controlling the image processing."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of values of generic parameters controlling the image processing."),defArg("代码注册说明", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Additional parameters describing the bar code regions. They can be used for extracting the data (see decode_2d_bar_code).")};
defARGINFO __arg_find_data_code_2d [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("符号xlds", dataTypeObj, 0, AS_RECEIVE_VAR, "XLD contours that surround the successfully decoded data code symbols."),defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of (optional) parameters for controlling the behavior of the operator."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the optional generic parameters."),defArg("结果处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of all successfully decoded 2D data code symbols."),defArg("解码数据串", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Decoded data strings of all detected 2D data code symbols in the image.")};
defARGINFO __arg_gen_2d_bar_code_descr [] = {defArg("代码类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the 2D bar code."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of names of generic parameters describing the 2D bar code class."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of values of the generic parameters describing the 2D bar code class."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Description of the 2D bar code class.")};
defARGINFO __arg_get_2d_bar_code [] = {defArg("条码区域", dataTypeObj, 0, 0, "Region that might contain a 2D bar code."),defArg("图像", dataTypeObj, 0, 0, "Corresponding image."),defArg("条形码的说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of the bar code class."),defArg("代码注册说明", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Additional parameters describing the bar code region. They can be used for extracting the data"),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of names of (optional) generic control parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of values of the generic parameters."),defArg("条码尺寸", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the dimension of the extracted symbol. In the case of ECC 200: data field width, height, symbol index."),defArg("条码数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the data values of the extracted symbol. value > 0: logical 1, value < 0: logical 0, value = 0: module could not be classified.")};
defARGINFO __arg_get_2d_bar_code_pos [] = {defArg("条码区域", dataTypeObj, 0, 0, "Region that might contain a bar code."),defArg("图像", dataTypeObj, 0, 0, "Corresponding image."),defArg("条码描述", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Description of the 2D bar code class."),defArg("代码注册描述", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Additional parameters describing the bar code region. They can be used for extracting the data."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of names of (optional) generic control parameters."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of values of the generic parameters."),defArg("条码尺寸", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the dimension of the extracted symbol. In the case of ECC 200: data field width, height, symbol index."),defArg("条码数据", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the data values of the extracted symbol. value > 0: logical 1, value < 0: logical 0, value = 0: module could not be classified."),defArg("数据元素的行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the row positions of the data elements of the extracted symbol in the image."),defArg("数据元关口", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Tuple with the column positions of the data elements of the extracted symbol in the image.")};
defARGINFO __arg_get_data_code_2d_objects [] = {defArg("数据编码对象", dataTypeObj, 0, AS_RECEIVE_VAR, "Objects that are created as intermediate results during the detection or evaluation of 2D data codes."),defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("候选句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code candidate or name of a group of candidates for which the iconic data is requested."),defArg("对象名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the iconic object to return.")};
defARGINFO __arg_get_data_code_2d_param [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that are to be queried for the 2D data code model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_data_code_2d_results [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("候选句柄", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code candidate or name of a group of candidates for which the data is required."),defArg("结果名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the results of the 2D data code to return."),defArg("结果值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List with the results.")};
defARGINFO __arg_query_data_code_2d_params [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("查询名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the parameter group."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List containing the names of the supported generic parameters.")};
defARGINFO __arg_read_data_code_2d_model [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the 2D data code model file."),defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the created 2D data code model.")};
defARGINFO __arg_serialize_data_code_2d_model [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_data_code_2d_param [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that shall be adjusted for the 2D data code."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that are adjusted for the 2D data code.")};
defARGINFO __arg_write_data_code_2d_model [] = {defArg("数据码句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the 2D data code model."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the 2D data code model file.")};
defARGINFO __arg_append_ocr_trainf [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be trained."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class (name) of the characters."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the training file.")};





defARGINFO __arg_clear_lexicon [] = {defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the lexicon.")};
defARGINFO __arg_clear_ocr_class_knn [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier.")};
defARGINFO __arg_clear_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier.")};
defARGINFO __arg_clear_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier.")};
defARGINFO __arg_clear_text_model [] = {defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text model to be cleared.")};


defARGINFO __arg_close_ocr [] = {defArg("处理OCR", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier to be deleted.")};
defARGINFO __arg_close_ocv [] = {defArg("OCV句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCV tool which has to be freed.")};
defARGINFO __arg_concat_ocr_trainf [] = {defArg("单文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the single training files."),defArg("由文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the composed training file.")};
defARGINFO __arg_create_lexicon [] = {defArg("名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Unique name for the new lexicon."),defArg("单词列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Word list for the new lexicon."),defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the lexicon.")};
defARGINFO __arg_create_ocr_class_box [] = {defArg("宽度模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the input layer of the network."),defArg("高度模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the input layer of the network."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation mode concerning scaling of characters."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Additional features."),defArg("字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All characters of a set."),defArg("ocr句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the created OCR classifier.")};
defARGINFO __arg_create_ocr_class_knn [] = {defArg("字符宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All characters of the character set to be read."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "This parameter is not yet supported."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "This parameter is not yet supported."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the k-NN classifier.")};
defARGINFO __arg_create_ocr_class_mlp [] = {defArg("字符宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All characters of the character set to be read."),defArg("隐层个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of hidden units of the MLP."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization')."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed value of the random number generator that is used to initialize the MLP with random values."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_create_ocr_class_svm [] = {defArg("字符宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "All characters of the character set to be read."),defArg("核类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The kernel type."),defArg("核参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Additional parameter for the kernel function."),defArg("正则化常量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Regularization constant of the SVM."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The mode of the SVM."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization')."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_create_ocv_proj [] = {defArg("模式的名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of names for patterns to be trained."),defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the created OCV tool.")};
defARGINFO __arg_create_text_model [] = {defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "New text model.")};
defARGINFO __arg_create_text_model_reader [] = {defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The Mode of the text model."),defArg("OCR多层感知器分类器", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "OCR Classifier."),defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "New text model.")};
defARGINFO __arg_deserialize_ocr [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the OCR classifier.")};
defARGINFO __arg_deserialize_ocr_class_knn [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_deserialize_ocr_class_mlp [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_deserialize_ocr_class_svm [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_deserialize_ocv [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCV tool.")};
defARGINFO __arg_do_ocr_multi [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values for the characters."),defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Class (name) of the characters."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence values of the characters.")};
defARGINFO __arg_do_ocr_multi_class_knn [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the k-NN."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence of the class of the characters.")};
defARGINFO __arg_do_ocr_multi_class_mlp [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the MLP."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence of the class of the characters.")};
defARGINFO __arg_do_ocr_multi_class_svm [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the SVM.")};
defARGINFO __arg_do_ocr_single [] = {defArg("字符", dataTypeObj, 0, 0, "Character to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier."),defArg("类", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Classes (names) of the characters."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence values of the characters.")};
defARGINFO __arg_do_ocr_single_class_knn [] = {defArg("字符", dataTypeObj, 0, 0, "Character to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("类别个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of maximal classes to determine."),defArg("最近邻个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of neighbors to consider."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Results of classifying the character with the k-NN."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence(s) of the class(es) of the character.")};
defARGINFO __arg_do_ocr_single_class_mlp [] = {defArg("字符", dataTypeObj, 0, 0, "Character to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("类别数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of best classes to determine."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the character with the MLP."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence(s) of the class(es) of the character.")};
defARGINFO __arg_do_ocr_single_class_svm [] = {defArg("字符", dataTypeObj, 0, 0, "Character to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of best classes to determine."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the character with the SVM.")};
defARGINFO __arg_do_ocr_word_knn [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("表达式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Expression describing the allowed word structure."),defArg("选择个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes per character considered for the internal word correction."),defArg("修正个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of corrected characters."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the k-NN."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence of the class of the characters."),defArg("文字", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Word text after classification and correction."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure of similarity between corrected word and uncorrected classification results.")};
defARGINFO __arg_do_ocr_word_mlp [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("表达式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Expression describing the allowed word structure."),defArg("矫正数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes per character considered for the internal word correction."),defArg("修正数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of corrected characters."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the MLP."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence of the class of the characters."),defArg("结果文字", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Word text after classification and correction."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure of similarity between corrected word and uncorrected classification results.")};
defARGINFO __arg_do_ocr_word_svm [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be recognized."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("表达式", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Expression describing the allowed word structure."),defArg("矫正数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of classes per character considered for the internal word correction."),defArg("修正数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of corrected characters."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of classifying the characters with the SVM."),defArg("结果文字", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Word text after classification and correction."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Measure of similarity between corrected word and uncorrected classification results.")};
defARGINFO __arg_do_ocv_simple [] = {defArg("模式", dataTypeObj, 0, 0, "Characters to be verified."),defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCV tool."),defArg("模式名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the character."),defArg("适应位置", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adaption to vertical and horizontal translation."),defArg("适应大小", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adaption to vertical and horizontal scaling of the size."),defArg("适应角度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adaption to changes of the orientation (not implemented)."),defArg("适应灰度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Adaption to additive and scaling gray value changes."),defArg("阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum difference between objects."),defArg("质量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Evaluation of the character.")};
defARGINFO __arg_find_text [] = {defArg("图像", dataTypeObj, 0, 0, "Input image."),defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text model specifying the text to be segmented."),defArg("结果ID文本", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the segmentation.")};
defARGINFO __arg_get_features_ocr_class_knn [] = {defArg("字符", dataTypeObj, 0, 0, "Input character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("转化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the feature vector be transformed with the preprocessing?"),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the character.")};
defARGINFO __arg_get_features_ocr_class_mlp [] = {defArg("字符", dataTypeObj, 0, 0, "Input character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("转化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the feature vector be transformed with the preprocessing?"),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the character.")};
defARGINFO __arg_get_features_ocr_class_svm [] = {defArg("字符", dataTypeObj, 0, 0, "Input character."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("转化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the feature vector be transformed with the preprocessing?"),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector of the character.")};
defARGINFO __arg_get_params_ocr_class_knn [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("字符宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值方式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Characters of the character set to be read."),defArg("预处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of preprocessing used to transform the feature vectors."),defArg("树个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of different trees used during the classifcation.")};
defARGINFO __arg_get_params_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("字符宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值方式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Characters of the character set to be read."),defArg("隐层个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of hidden units of the MLP."),defArg("预处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Preprocessing parameter: Number of transformed features.")};
defARGINFO __arg_get_params_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("字符宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("字符高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("插值方式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolation mode for the zooming of the characters."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Features to be used for classification."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Characters of the character set to be read."),defArg("核类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The kernel type."),defArg("核参数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Additional parameters for the kernel function."),defArg("正则化常量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Regularization constant of the SVM."),defArg("模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The mode of the SVM."),defArg("预处理", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Type of preprocessing used to transform the feature vectors."),defArg("元组个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Preprocessing parameter: Number of transformed features (ignored for Preprocessing = 'none' and Preprocessing = 'normalization').")};
defARGINFO __arg_get_prep_info_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("信息内容", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative information content of the transformed feature vectors."),defArg("累积信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative information content of the transformed feature vectors.")};
defARGINFO __arg_get_prep_info_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("预处理", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of preprocessing used to transform the feature vectors."),defArg("信息内容", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Relative information content of the transformed feature vectors."),defArg("累积信息", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Cumulative information content of the transformed feature vectors.")};
defARGINFO __arg_get_regularization_params_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the regularization parameter to return."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the regularization parameter.")};
defARGINFO __arg_get_rejection_params_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the general parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the general parameter.")};
defARGINFO __arg_get_support_vector_num_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "OCR handle."),defArg("支持向量个数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Total number of support vectors."),defArg("支持向量子向量数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of SV of each sub-SVM.")};
defARGINFO __arg_get_support_vector_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "OCR handle."),defArg("支持向量索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of stored support vectors."),defArg("索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the support vector in the training set.")};
defARGINFO __arg_get_text_model_param [] = {defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameters to be queried."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of Parameters.")};
defARGINFO __arg_import_lexicon [] = {defArg("名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Unique name for the new lexicon."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of a text file containing words for the new lexicon."),defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the lexicon.")};
defARGINFO __arg_info_ocr_class_box [] = {defArg("Ocr句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier."),defArg("宽度模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the scaled characters."),defArg("高度模式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the scaled characters."),defArg("插值方式", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Interpolation mode for scaling the characters."),defArg("最大字符宽度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Width of the largest trained character."),defArg("最大字符高度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Height of the largest trained character."),defArg("特征", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Used features."),defArg("字符", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "All characters of the set.")};
defARGINFO __arg_inspect_lexicon [] = {defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the lexicon."),defArg("单词列表", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "List of all words.")};
defARGINFO __arg_lookup_lexicon [] = {defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the lexicon."),defArg("结果文字", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Word to be looked up."),defArg("建立", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Result of the search.")};
defARGINFO __arg_ocr_change_char [] = {defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR-network to be changed."),defArg("字符", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "New assign of characters.")};
defARGINFO __arg_ocr_get_features [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be trained."),defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the desired OCR-classifier."),defArg("特征向量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Feature vector.")};
defARGINFO __arg_protect_ocr_trainf [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protecting the training files."),defArg("训练文件保护", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Names of the protected training files.")};
defARGINFO __arg_read_ocr [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the OCR classifier file."),defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the read OCR classifier.")};
defARGINFO __arg_read_ocr_class_knn [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_read_ocr_class_mlp [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_read_ocr_class_svm [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the OCR classifier.")};
defARGINFO __arg_read_ocr_trainf [] = {defArg("字符", dataTypeObj, 0, AS_RECEIVE_VAR, "Images read from file."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("字符名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the read characters.")};
defARGINFO __arg_read_ocr_trainf_names [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("字符名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the read characters."),defArg("字符数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of characters.")};
defARGINFO __arg_read_ocr_trainf_names_protected [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protected training files."),defArg("字符名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the read characters."),defArg("字符数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of characters.")};
defARGINFO __arg_read_ocr_trainf_select [] = {defArg("字符", dataTypeObj, 0, AS_RECEIVE_VAR, "Images read from file."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("搜索的名字", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the characters to be extracted."),defArg("找到的名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Names of the read characters.")};
defARGINFO __arg_read_ocv [] = {defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the file which has to be read."),defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of read OCV tool.")};
defARGINFO __arg_reduce_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Original handle of SVM-based OCR-classifier."),defArg("方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of postprocessing to reduce number of SVs."),defArg("最小剩余支持向量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum number of remaining SVs."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum allowed error of reduction."),defArg("减少后的支持向量句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "SVMHandle of reduced OCR classifier.")};
defARGINFO __arg_select_feature_set_trainf_knn [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features that should be considered for selection."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Trained OCR-k-NN classifier."),defArg("特征集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected feature set, contains only entries from FeatureList."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Achieved score using tow-fold cross-validation.")};
defARGINFO __arg_select_feature_set_trainf_mlp [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features that should be considered for selection."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Trained OCR-MLP classifier."),defArg("特征集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected feature set, contains only entries from FeatureList."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Achieved score using tow-fold cross-validation.")};
defARGINFO __arg_select_feature_set_trainf_mlp_protected [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protected training files."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features that should be considered for selection."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Trained OCR-MLP classifier."),defArg("特征集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected feature set, contains only entries from FeatureList."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Achieved score using tow-fold cross-validation.")};
defARGINFO __arg_select_feature_set_trainf_svm [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features that should be considered for selection."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Trained OCR-SVM Classifier."),defArg("特征集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected feature set, contains only entries from FeatureList."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Achieved score using tow-fold cross-validation.")};
defARGINFO __arg_select_feature_set_trainf_svm_protected [] = {defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protected training files."),defArg("特征列表", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "List of features that should be considered for selection."),defArg("选择方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method to perform the selection."),defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the rectangle to which the gray values of the segmented character are zoomed."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the rectangle to which the gray values of the segmented character are zoomed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of generic parameters to configure the selection process and the classifier."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of generic parameters to configure the selection process and the classifier."),defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Trained OCR-SVM Classifier."),defArg("特征集", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Selected feature set, contains only entries from FeatureList."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Achieved score using tow-fold cross-validation.")};
defARGINFO __arg_serialize_ocr [] = {defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_ocr_class_knn [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_ocv [] = {defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCV tool."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_regularization_params_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the regularization parameter to return."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the regularization parameter.")};
defARGINFO __arg_set_rejection_params_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the general parameter."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Value of the general parameter.")};
defARGINFO __arg_set_text_model_param [] = {defArg("文本模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Text model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the parameters to be set."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the parameters to be set.")};
defARGINFO __arg_suggest_lexicon [] = {defArg("字典句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the lexicon."),defArg("结果文字", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Word to be looked up."),defArg("建议", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Most similar word found in the lexicon."),defArg("修正数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Difference between the words in edit operations.")};
defARGINFO __arg_testd_ocr_class_box [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be tested."),defArg("图像", dataTypeObj, 0, 0, "Gray values for the characters."),defArg("ocr句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the desired OCR-classifier."),defArg("类别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Class (name) of the characters."),defArg("置信度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Confidence for the character to belong to the class.")};
defARGINFO __arg_traind_ocr_class_box [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be trained."),defArg("图像", dataTypeObj, 0, 0, "Gray values for the characters."),defArg("ocr句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the desired OCR-classifier."),defArg("类别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Class (name) of the characters."),defArg("置信度均值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average confidence during a re-classification of the trained characters.")};
defARGINFO __arg_traind_ocv_proj [] = {defArg("模式", dataTypeObj, 0, 0, "Pattern to be trained."),defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCV tool to be trained."),defArg("名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name(s) of the object(s) to analyse."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode for training (only one mode implemented).")};
defARGINFO __arg_trainf_ocr_class_box [] = {defArg("ocr句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the desired OCR-network."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("置信度均值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average confidence during a re-classification of the trained characters.")};
defARGINFO __arg_trainf_ocr_class_knn [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that can be adjusted for the k-NN classifier creation."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters that can be adjusted for the k-NN classifier creation.")};
defARGINFO __arg_trainf_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("最大迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations of the optimization algorithm."),defArg("公差权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm."),defArg("容错", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data."),defArg("错误日志", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.")};
defARGINFO __arg_trainf_ocr_class_mlp_protected [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protected training files."),defArg("最大迭代次数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of iterations of the optimization algorithm."),defArg("公差权重", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the weights of the MLP between two iterations of the optimization algorithm."),defArg("容错", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the difference of the mean error of the MLP on the training data between two iterations of the optimization algorithm."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data."),defArg("错误日志", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Mean error of the MLP on the training data as a function of the number of iterations of the optimization algorithm.")};
defARGINFO __arg_trainf_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stop parameter for training."),defArg("训练模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of training.")};
defARGINFO __arg_trainf_ocr_class_svm_protected [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the training files."),defArg("密码", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Passwords for protected training files."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stop parameter for training."),defArg("训练模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of training.")};
defARGINFO __arg_write_ocr [] = {defArg("光学字符句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the OCR classifier."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the file for the OCR classifier (without extension).")};
defARGINFO __arg_write_ocr_class_knn [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the k-NN classifier for an OCR task."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_ocr_class_mlp [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_ocr_class_svm [] = {defArg("光学字符识别句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCR classifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_ocr_trainf [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be trained."),defArg("图像", dataTypeObj, 0, 0, "Gray values of the characters."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class (name) of the characters."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the training file.")};
defARGINFO __arg_write_ocr_trainf_image [] = {defArg("字符", dataTypeObj, 0, 0, "Characters to be trained."),defArg("结果类别", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Class (name) of the characters."),defArg("训练文件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the training file.")};
defARGINFO __arg_write_ocv [] = {defArg("光学字符验证句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the OCV tool to be written."),defArg("文件名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the file where the tool has to be saved.")};
defARGINFO __arg_adapt_template [] = {defArg("图像", dataTypeObj, 0, 0, "Image which determines the size of the later matching."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number.")};
defARGINFO __arg_add_sample_identifier_preparation_data [] = {defArg("样本图像", dataTypeObj, 0, 0, "Image that shows an object."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Index of the object visible in the SampleImage."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter value."),defArg("对象样本索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the object sample.")};
defARGINFO __arg_add_sample_identifier_training_data [] = {defArg("样本图像", dataTypeObj, 0, 0, "Image that shows an object."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the object visible in the SampleImage."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter value."),defArg("对象样本索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the object sample.")};
defARGINFO __arg_apply_sample_identifier [] = {defArg("图像", dataTypeObj, 0, 0, "Image showing the object to be identified."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("结果数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of suggested object indices."),defArg("评级阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Rating threshold."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter value."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the identified object."),defArg("评级", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rating value of the identified object.")};
defARGINFO __arg_best_match [] = {defArg("输入图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum average difference of the grayvalues."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy in case of 'true'."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row position of the best match."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column position of the best match."),defArg("误差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average divergence of the grayvalues of the best match.")};
defARGINFO __arg_best_match_mg [] = {defArg("图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal average difference of the grayvalues."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Exactness in subpixels in case of 'true'."),defArg("数量级", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of the used resolution levels."),defArg("这水平", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Resolution level up to which the method \"best match\" is used."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row position of the best match."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column position of the best match."),defArg("误差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average divergence of the grayvalues in the best match.")};
defARGINFO __arg_best_match_pre_mg [] = {defArg("图像金字塔", dataTypeObj, 0, 0, "Image pyramid inside of which the pattern has to be found."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal average difference of the grayvalues."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Exactness in subpixels in case of 'true'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of the used resolution levels."),defArg("这水平", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Resolution level up to which the method \"best match\" is used."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row position of the best match."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column position of the best match."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average divergence of the grayvalues in the best match.")};
defARGINFO __arg_best_match_rot [] = {defArg("图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest Rotation of the pattern."),defArg("角度扩展", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum positive Extension of AngleStart."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum average difference of the grayvalues."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy in case of 'true'."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row position of the best match."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column position of the best match."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of pattern."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average divergence of the grayvalues of the best match.")};
defARGINFO __arg_best_match_rot_mg [] = {defArg("图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest Rotation of the pattern."),defArg("角度扩展", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum positive Extension of AngleStart."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum average difference of the grayvalues."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy in case of 'true'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of the used resolution levels."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row position of the best match."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column position of the best match."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of pattern."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average divergence of the grayvalues of the best match.")};
defARGINFO __arg_bundle_adjust_mosaic [] = {defArg("图像数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of different images that are used for the calibration."),defArg("参考图像", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the reference image."),defArg("映射源", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the source images of the transformations."),defArg("映射目标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the target images of the transformations."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3projective transformation matrices."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of corresponding points in the respective source images."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of corresponding points in the respective source images."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of corresponding points in the respective destination images."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of corresponding points in the respective destination images."),defArg("对应角点数", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Number of point correspondences in the respective image pair."),defArg("转化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Transformation class to be used."),defArg("二维拼接矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Array of 3projective transformation matrices that determine the position of the images in the mosaic."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the points reconstructed by the bundle adjustment."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the points reconstructed by the bundle adjustment."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Average error per reconstructed point.")};









defARGINFO __arg_clear_component_model [] = {defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model.")};
defARGINFO __arg_clear_deformable_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model.")};
defARGINFO __arg_clear_descriptor_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the desicriptor model.")};
defARGINFO __arg_clear_ncc_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model.")};
defARGINFO __arg_clear_sample_identifier [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier.")};
defARGINFO __arg_clear_shape_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model.")};
defARGINFO __arg_clear_template [] = {defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number.")};
defARGINFO __arg_clear_training_components [] = {defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result.")};
defARGINFO __arg_clear_train_data_variation_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_clear_variation_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_cluster_model_components [] = {defArg("训练图像", dataTypeObj, 0, 0, "Training images that were used for training the model components."),defArg("模型组件", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour regions of rigid model components."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("模糊标准", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Criterion for solving the ambiguities."),defArg("最大轮廓重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum contour overlap of the found initial components."),defArg("聚类阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for clustering the initial components.")};
defARGINFO __arg_compare_ext_variation_model [] = {defArg("图像", dataTypeObj, 0, 0, "Image of the object to be compared."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region containing the points that differ substantially from the model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method used for comparing the variation model.")};
defARGINFO __arg_compare_variation_model [] = {defArg("图像", dataTypeObj, 0, 0, "Image of the object to be compared."),defArg("区域", dataTypeObj, 0, AS_RECEIVE_VAR, "Region containing the points that differ substantially from the model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_create_aniso_shape_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_aniso_shape_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_calib_descriptor_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The parameters of the internal orientation of the camera."),defArg("参考姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The reference pose of the object in the reference image."),defArg("检测器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the detector."),defArg("检测器参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The detector's parameter names."),defArg("检测器参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the detector's parameters."),defArg("描述符参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The descriptor's parameter names."),defArg("描述符参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the descriptor's parameters."),defArg("种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The seed for the random number generator."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The handle to the descriptor model.")};
defARGINFO __arg_create_component_model [] = {defArg("模型的图像", dataTypeObj, 0, 0, "Input image from which the shape models of the model components should be created."),defArg("部分地区", dataTypeObj, 0, 0, "Input regions from which the shape models of the model components should be created."),defArg("变化的行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Variation of the model components in row direction."),defArg("变化列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Variation of the model components in column direction."),defArg("变化角", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Angle variation of the model components."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the component model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation of the component model."),defArg("低对比度的比较", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower hysteresis threshold for the contrast of the components in the model image."),defArg("高对比度比较", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper hysteresis threshold for the contrast of the components in the model image."),defArg("最小尺寸计算", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of the contour regions in the model."),defArg("最小对比度比较", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the components in the search images."),defArg("最小组件得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the components to be found."),defArg("组件最大金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels for the components."),defArg("组件角步长", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution) for the components."),defArg("优化计算", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization for the components."),defArg("度量组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric used for the components."),defArg("预生成组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Complete pregeneration of the shape models for the components if equal to 'true'."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the component model."),defArg("根组件评级", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ranking of the model components expressing the suitability to act as the root component.")};
defARGINFO __arg_create_local_deformable_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Thresholds or hysteresis thresholds for the contrast of the object in the template image."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The generic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_local_deformable_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The generic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_ncc_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_planar_calib_deformable_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The parameters of the internal orientation of the camera."),defArg("参考姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The reference pose of the object in the reference image."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Thresholds or hysteresis thresholds for the contrast of the object in the template image."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the parameters."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_planar_calib_deformable_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The parameters of the internal orientation of the camera."),defArg("参考姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The reference pose of the object."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The generic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameter."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_planar_uncalib_deformable_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Thresholds or hysteresis thresholds for the contrast of the object in the template image."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The generic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameter."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_planar_uncalib_deformable_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the row direction."),defArg("行方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern in the column direction."),defArg("列方向尺度步距", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution) in the column direction."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The generic parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the generic parameters."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_sample_identifier [] = {defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the sample identifier.")};
defARGINFO __arg_create_scaled_shape_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern."),defArg("规模的步骤", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution)."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_scaled_shape_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the pattern."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the pattern."),defArg("规模的步骤", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Scale step length (resolution)."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_shape_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_shape_model_xld [] = {defArg("轮廓", dataTypeObj, 0, 0, "Input contours that will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution)."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization and optionally method used for generating the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_create_template [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be processed for the pattern matching."),defArg("第一个错误", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Not yet in use."),defArg("最大金字塔级数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal number of pyramid levels."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimizing."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of grayvalues."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Template number.")};
defARGINFO __arg_create_template_rot [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be processed for the pattern matching."),defArg("最大金字塔级数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest Rotation of the pattern."),defArg("角度扩展", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum positive Extension of AngleStart."),defArg("角步", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step rate (angle precision) of matching."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimizing."),defArg("灰度值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of grayvalues."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Template number.")};
defARGINFO __arg_create_trained_component_model [] = {defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the component model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation of the component model."),defArg("最小对比度比较", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the components in the search images."),defArg("最小组件得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the components to be found."),defArg("组件最大金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels for the components."),defArg("组件角步长", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Step length of the angles (resolution) for the components."),defArg("优化计算", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization for the components."),defArg("度量组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric used for the components."),defArg("预生成组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Complete pregeneration of the shape models for the components if equal to 'true'."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the component model."),defArg("根组件评级", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ranking of the model components expressing the suitability to act as the root component.")};
defARGINFO __arg_create_uncalib_descriptor_model [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("检测器类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The type of the detector."),defArg("检测器参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The detector's parameter names."),defArg("检测器参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the detector's parameters."),defArg("描述符参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The descriptor's parameter names."),defArg("描述符参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the descriptor's parameters."),defArg("种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The seed for the random number generator."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The handle to the descriptor model.")};
defARGINFO __arg_create_variation_model [] = {defArg("宽度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width of the images to be compared."),defArg("高度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Height of the images to be compared."),defArg("类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of the images to be compared."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Method used for computing the variation model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the variation model.")};
defARGINFO __arg_deserialize_component_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the component model.")};
defARGINFO __arg_deserialize_deformable_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_deserialize_descriptor_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_deserialize_ncc_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_deserialize_sample_identifier [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the sample identifier.")};
defARGINFO __arg_deserialize_shape_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_deserialize_template [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Template number.")};
defARGINFO __arg_deserialize_training_components [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training result.")};
defARGINFO __arg_deserialize_variation_model [] = {defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the serialized item."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the variation model.")};
defARGINFO __arg_determine_deformable_model_params [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The general parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the general parameter."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameters to be determined automatically."),defArg("输出参数名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the automatically determined parameter."),defArg("输出参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the automatically determined parameter.")};
defARGINFO __arg_determine_ncc_model_params [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameters to be determined automatically."),defArg("参数名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the automatically determined parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the automatically determined parameter.")};
defARGINFO __arg_determine_shape_model_params [] = {defArg("模板", dataTypeObj, 0, 0, "Input image whose domain will be used to create the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model."),defArg("优化", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Kind of optimization."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric."),defArg("对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold or hysteresis thresholds for the contrast of the object in the template image and optionally minimum size of the object parts."),defArg("最小对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum contrast of the objects in the search images."),defArg("参数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameters to be determined automatically."),defArg("参数名称", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Name of the automatically determined parameter."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Value of the automatically determined parameter.")};
defARGINFO __arg_fast_match [] = {defArg("图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("匹配", dataTypeObj, 0, AS_RECEIVE_VAR, "All points whose error lies below a certain threshold."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal average difference of the grayvalues.")};
defARGINFO __arg_fast_match_mg [] = {defArg("图像", dataTypeObj, 0, 0, "Input image inside of which the pattern has to be found."),defArg("匹配", dataTypeObj, 0, AS_RECEIVE_VAR, "All points which have an error below a certain threshold."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("最大误差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal average difference of the grayvalues."),defArg("最大金字塔级数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of levels in the pyramid.")};
defARGINFO __arg_find_aniso_shape_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in the column direction."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the model."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the model."),defArg("行尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the model in the row direction."),defArg("列尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the model in the column direction."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_aniso_shape_models [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the models should be found."),defArg("模型IDs", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the models."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the models."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the models in the row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the models in the row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the models in the column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the models in the column direction."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the models to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the models to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the models to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the models."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the models."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the models."),defArg("行尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the models in the row direction."),defArg("列尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the models in the column direction."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the models."),defArg("模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the found instances of the models.")};
defARGINFO __arg_find_calib_descriptor_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image where the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The handle to the descriptor model."),defArg("检测器参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The detector's parameter names."),defArg("检测器参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the detector's parameters."),defArg("描述符参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The descriptor's parameter names."),defArg("描述符参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the descriptor's parameters."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the models to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal number of found instances."),defArg("相机内参", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Camera parameter (inner orientation) obtained from camera calibration."),defArg("分型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Score type to be evaluated in Score."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3D pose of the object."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances according to the ScoreType input.")};
defARGINFO __arg_find_component_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the component model should be found."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("根组件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the root component."),defArg("根组件起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the root component"),defArg("根组件角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation of the root component."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the component model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the component model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the component models to be found."),defArg("如果根没有找到", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Behavior if the root component is missing."),defArg("如果没有找到组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Behavior if a component is missing."),defArg("姿态预测", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pose prediction of components that are not found."),defArg("最小组件评分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the components to be found."),defArg("亚像素组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy of the component poses if not equal to 'none'."),defArg("组件金字塔层数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels for the components used in the matching (and lowest pyramid level to use if |NumLevelsComp| = 2n)."),defArg("组件贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic for the components (0: safe but slow; 1: fast but matches may be missed)."),defArg("起始模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Start index of each found instance of the component model in the tuples describing the component matches."),defArg("终止模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "End index of each found instance of the component model in the tuples describing the component matches."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the component model."),defArg("组件行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found component matches."),defArg("组件列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found component matches."),defArg("组件角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found component matches."),defArg("组件得分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found component matches."),defArg("组件模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the found components.")};
defARGINFO __arg_find_local_deformable_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("图像纠正", dataTypeObj, 0, AS_RECEIVE_VAR, "Rectified image of the found model."),defArg("向量场", dataTypeObj, 0, AS_RECEIVE_VAR, "Vector field of the rectification transformation."),defArg("变形轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contours of the found instances of the model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("行最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in row direction."),defArg("行最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in row direction."),defArg("列最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in column direction."),defArg("列最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in column direction."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minumum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("结果类型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Switch for requested iconic result."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The general parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the general parameters."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scores of the found instances of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of the found instances of the model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of the found instances of the model.")};
defARGINFO __arg_find_ncc_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the model."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the model."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_planar_calib_deformable_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in column direction."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minumum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The general parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the general parameters."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Pose of the object."),defArg("姿态协方差", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "6 standard deviations or 36 covariances of the pose parameters."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_planar_uncalib_deformable_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("行方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in row direction."),defArg("行方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in row direction."),defArg("列方向最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model in column direction."),defArg("列方向最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model in column direction."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minumum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The general parameter names."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the general parameters."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homographies between model and found instances."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_scaled_shape_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the model."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the model."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the model."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the model."),defArg("规模", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the model."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_scaled_shape_models [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the models should be found."),defArg("模型IDs", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the models."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the models."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum scale of the models."),defArg("最大尺度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum scale of the models."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the models to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the models to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the models to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the models."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the models."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the models."),defArg("规模", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale of the found instances of the models."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the models."),defArg("模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the found instances of the models.")};
defARGINFO __arg_find_shape_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the model."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the model to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the model to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the model to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the model."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the model."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the model.")};
defARGINFO __arg_find_shape_models [] = {defArg("图像", dataTypeObj, 0, 0, "Input image in which the models should be found."),defArg("模型IDs", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the models."),defArg("起始角", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Smallest rotation of the models."),defArg("角范围", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Extent of the rotation angles."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the models to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of instances of the models to be found (or 0 for all matches)."),defArg("最大重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum overlap of the instances of the models to be found."),defArg("亚像素", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subpixel accuracy if not equal to 'none'."),defArg("最大金字塔数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Number of pyramid levels used in the matching (and lowest pyramid level to use if |NumLevels| = 2)."),defArg("贪婪", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "\"Greediness\" of the search heuristic (0: safe but slow; 1: fast but matches may be missed)."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of the models."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of the models."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of the models."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of the models."),defArg("模型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Index of the found instances of the models.")};
defARGINFO __arg_find_uncalib_descriptor_model [] = {defArg("图像", dataTypeObj, 0, 0, "Input image where the model should be found."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The handle to the descriptor model."),defArg("检测器参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The detector's parameter names."),defArg("检测器参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the detector's parameters."),defArg("描述符参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "The descriptor's parameter names."),defArg("描述符参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of the descriptor's parameters."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the models to be found."),defArg("匹配个数", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximal number of found instances."),defArg("分型", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Score type to be evaluated in Score."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homography between model and found instance."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances according to the ScoreType input.")};
defARGINFO __arg_gen_bundle_adjusted_mosaic [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("匹配图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3x3 projective transformation matrices."),defArg("堆叠顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stacking order of the images in the mosaic."),defArg("变换域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the domains of the input images also be transformed?"),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "3x3 projective transformation matrix that describes the translation that was necessary to transform all images completely into the output image.")};
defARGINFO __arg_gen_cube_map_mosaic [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("前面", dataTypeObj, 0, AS_RECEIVE_VAR, "Front cube map."),defArg("后方的", dataTypeObj, 0, AS_RECEIVE_VAR, "Rear cube map."),defArg("左边", dataTypeObj, 0, AS_RECEIVE_VAR, "Left cube map."),defArg("正确的", dataTypeObj, 0, AS_RECEIVE_VAR, "Right cube map."),defArg("顶部", dataTypeObj, 0, AS_RECEIVE_VAR, "Top cube map."),defArg("底部", dataTypeObj, 0, AS_RECEIVE_VAR, "Bottom cube map."),defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "(Array of) 3x3 projective camera matrices that determine the internal camera parameters."),defArg("旋转矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3x3 transformation matrices that determine rotation of the camera in the respective image."),defArg("立方体贴图的尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Width and height of the resulting cube maps."),defArg("堆叠顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of adding the images to the mosaic image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of image interpolation.")};
defARGINFO __arg_gen_initial_components [] = {defArg("模型的图像", dataTypeObj, 0, 0, "Input image from which the initial components should be extracted."),defArg("初始组件", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour regions of initial components."),defArg("低对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower hysteresis threshold for the contrast of the initial components in the image."),defArg("高对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper hysteresis threshold for the contrast of the initial components in the image."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of the initial components."),defArg("模式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of automatic segmentation."),defArg("通用名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of optional control parameters."),defArg("通用值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Values of optional control parameters.")};
defARGINFO __arg_gen_projective_mosaic [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("匹配图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("起始图像", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the central input image."),defArg("映射源", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the source images of the transformations."),defArg("映射目标", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Indices of the target images of the transformations."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3x3 projective transformation matrices."),defArg("堆叠顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Stacking order of the images in the mosaic."),defArg("变换域", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Should the domains of the input images also be transformed?"),defArg("二维拼接矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Array of 3x3 projective transformation matrices that determine the position of the images in the mosaic.")};
defARGINFO __arg_gen_spherical_mosaic [] = {defArg("图像", dataTypeObj, 0, 0, "Input images."),defArg("匹配图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Output image."),defArg("相机矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "(Array of) 3x3 projective camera matrices that determine the internal camera parameters."),defArg("旋转矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Array of 3x3 transformation matrices that determine rotation of the camera in the respective image."),defArg("最小纬度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum latitude of points in the spherical mosaic image."),defArg("最大纬度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum latitude of points in the spherical mosaic image."),defArg("最小经度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum longitude of points in the spherical mosaic image."),defArg("最大经度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum longitude of points in the spherical mosaic image."),defArg("经纬度步长", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Latitude and longitude angle step width."),defArg("堆叠顺序", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of adding the images to the mosaic image."),defArg("插值方式", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mode of interpolation when creating the mosaic image.")};
defARGINFO __arg_get_component_model_params [] = {defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("最小组件得分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum score of the instances of the components to be found."),defArg("根组件评级", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Ranking of the model components expressing their suitability to act as root component."),defArg("形状模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handles of the shape models of the individual model components.")};
defARGINFO __arg_get_component_model_tree [] = {defArg("树", dataTypeObj, 0, AS_RECEIVE_VAR, "Search tree."),defArg("关系", dataTypeObj, 0, AS_RECEIVE_VAR, "Relations of components that are connected in the search tree."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("根组件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the root component."),defArg("图像", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image for which the tree is to be returned."),defArg("起始节点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Component index of the start node of an arc in the search tree."),defArg("结束节点", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Component index of the end node of an arc in the search tree."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the rectangle representing the relation."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center of the rectangle representing the relation."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the rectangle representing the relation (radians)."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First radius (half length) of the rectangle representing the relation."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second radius (half width) of the rectangle representing the relation."),defArg("起始角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest relative orientation angle."),defArg("角范围", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extent of the relative orientation angle.")};
defARGINFO __arg_get_component_relations [] = {defArg("关系", dataTypeObj, 0, AS_RECEIVE_VAR, "Region representation of the relations."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("参考组件", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of reference component."),defArg("图像", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image for which the component relations are to be returned."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the center of the rectangle representing the relation."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column index of the center of the rectangle representing the relation."),defArg("方向", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Orientation of the rectangle representing the relation (radians)."),defArg("长度1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "First radius (half length) of the rectangle representing the relation."),defArg("长度2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Second radius (half width) of the rectangle representing the relation."),defArg("起始角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest relative orientation angle."),defArg("角范围", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extent of the relative orientation angles.")};
defARGINFO __arg_get_deformable_model_contours [] = {defArg("模型的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour representation of the deformable model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pyramid level for which the contour representation should be returned.")};
defARGINFO __arg_get_deformable_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the origin of the deformable model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the origin of the deformable model.")};
defARGINFO __arg_get_deformable_model_params [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Names of the generic parameters that are to be queried for the deformable model."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the generic parameters.")};
defARGINFO __arg_get_descriptor_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a descriptor model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of origin in row direction."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Position of origin in column direction.")};
defARGINFO __arg_get_descriptor_model_params [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The object handle to the descriptor model."),defArg("检测器类型", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The type of the detector."),defArg("检测器参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The detectors parameter names."),defArg("检测器参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the detectors parameters."),defArg("描述符参数名", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "The descriptors parameter names."),defArg("描述符参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Values of the descriptors parameters.")};
defARGINFO __arg_get_descriptor_model_points [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The handle to the descriptor model."),defArg("集合", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Set of interest points."),defArg("子集", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Subset of interest points."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinates of interest points."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinates of interest points.")};
defARGINFO __arg_get_descriptor_model_results [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a descriptor model."),defArg("对象ID", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Handle of the object for which the results are queried."),defArg("结果名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Name of the results to be queried."),defArg("结果", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Returned results.")};
defARGINFO __arg_get_found_component_model [] = {defArg("发现部件", dataTypeObj, 0, AS_RECEIVE_VAR, "Found components of the selected component model instance."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("起始模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Start index of each found instance of the component model in the tuples describing the component matches."),defArg("终止模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "End index of each found instance of the component model to the tuples describing the component matches."),defArg("组件行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the found component matches."),defArg("组件列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the found component matches."),defArg("组件角度", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Rotation angle of the found component matches."),defArg("组件得分", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Score of the found component matches."),defArg("组件模型", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the found components."),defArg("模型匹配", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the found instance of the component model to be returned."),defArg("标记方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mark the orientation of the components."),defArg("组件实例行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of all components of the selected model instance."),defArg("组件实例列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of all components of the selected model instance."),defArg("组件实例角度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of all components of the selected model instance."),defArg("组件实例得分", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of all components of the selected model instance.")};
defARGINFO __arg_get_ncc_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the origin of the NCC model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the origin of the NCC model.")};
defARGINFO __arg_get_ncc_model_params [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Step length of the angles (resolution)."),defArg("度量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Match metric.")};
defARGINFO __arg_get_sample_identifier_object_info [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the object for which information is retrieved."),defArg("信息名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Define, for which kind of object information is retrieved."),defArg("信息值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Information about the object.")};
defARGINFO __arg_get_sample_identifier_param [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Parameter value.")};
defARGINFO __arg_get_shape_model_contours [] = {defArg("模型的轮廓", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour representation of the shape model."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("金字塔级别", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Pyramid level for which the contour representation should be returned.")};
defARGINFO __arg_get_shape_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the origin of the shape model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the origin of the shape model.")};
defARGINFO __arg_get_shape_model_params [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("最大金字塔数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Number of pyramid levels."),defArg("起始角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Smallest rotation of the pattern."),defArg("角范围", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Extent of the rotation angles."),defArg("角步", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Step length of the angles (resolution)."),defArg("最小尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum scale of the pattern."),defArg("最大尺度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Maximum scale of the pattern."),defArg("规模的步骤", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Scale step length (resolution)."),defArg("度量", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Match metric."),defArg("最小对比度", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Minimum contrast of the objects in the search images.")};
defARGINFO __arg_get_thresh_images_variation_model [] = {defArg("最小图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Threshold image for the lower threshold."),defArg("最大图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Threshold image for the upper threshold."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_get_training_components [] = {defArg("培训的内容", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour regions of the initial components or of the model components."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Type of returned components or index of an initial component."),defArg("图像", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Image for which the components are to be returned."),defArg("标记方向", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Mark the orientation of the components."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Row coordinate of the found instances of all initial components or model components."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Column coordinate of the found instances of all initial components or model components."),defArg("角", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Rotation angle of the found instances of all components."),defArg("分数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Score of the found instances of all components.")};
defARGINFO __arg_get_variation_model [] = {defArg("图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Image of the trained object."),defArg("变化图像", dataTypeObj, 0, AS_RECEIVE_VAR, "Variation image of the trained object."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_inspect_clustered_components [] = {defArg("模型组件", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour regions of rigid model components."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("模糊标准", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Criterion for solving the ambiguities."),defArg("最大轮廓重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum contour overlap of the found initial components."),defArg("聚类阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for clustering the initial components.")};
defARGINFO __arg_modify_component_relations [] = {defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("参考组件", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Model component(s) relative to which the movement(s) should be modified."),defArg("公差组", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Model component(s) of which the relative movement(s) should be modified."),defArg("位置公差", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Change of the position relation in pixels."),defArg("角度公差", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Change of the orientation relation in radians.")};
defARGINFO __arg_prepare_direct_variation_model [] = {defArg("参考图像", dataTypeObj, 0, 0, "Reference image of the object."),defArg("变化图像", dataTypeObj, 0, 0, "Variation image of the object."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model."),defArg("绝对阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Absolute minimum threshold for the differences between the image and the variation model."),defArg("变化阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the differences based on the variation of the variation model.")};
defARGINFO __arg_prepare_sample_identifier [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("将制备的数据", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Indicates if the preparation data should be removed."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Generic parameter value.")};
defARGINFO __arg_prepare_variation_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model."),defArg("绝对阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Absolute minimum threshold for the differences between the image and the variation model."),defArg("变化阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the differences based on the variation of the variation model.")};
defARGINFO __arg_proj_match_points_distortion_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value match metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate offset of corresponding points."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate offset of corresponding points."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Estimate of the relative rotation of the second image with respect to the first image."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the projective transformation matrix."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for the transformation consistency check."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed homogeneous projective transformation matrix."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed radial distortion coefficient."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square transformation error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_proj_match_points_distortion_ransac_guided [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (row coordinate)."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 1 (column coordinate)."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (row coordinate)."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Input points in image 2 (column coordinate)."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value match metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("二维矩阵向导", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Approximation of the homogeneous projective transformation matrix between the two images."),defArg("畸变系数向导", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Approximation of the radial distortion coefficient in the two images."),defArg("距公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tolerance for the matching search window."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Algorithm for the computation of the projective transformation matrix."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for transformation consistency check."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed homogeneous projective transformation matrix."),defArg("畸变系数", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Computed radial distortion coefficient."),defArg("错误", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Root-Mean-Square transformation error."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_proj_match_points_ransac [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 2."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value comparison metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("行偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average row coordinate shift."),defArg("列偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Average column coordinate shift."),defArg("半高", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half height of matching search window."),defArg("半宽", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Half width of matching search window."),defArg("旋转", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Range of rotation angles."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix estimation algorithm."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for transformation consistency check."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_proj_match_points_ransac_guided [] = {defArg("图像1", dataTypeObj, 0, 0, "Input image 1."),defArg("图像2", dataTypeObj, 0, 0, "Input image 2."),defArg("行1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 1."),defArg("列1", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 1."),defArg("行2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinates of characteristic points in image 2."),defArg("列2", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinates of characteristic points in image 2."),defArg("灰度匹配法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Gray value comparison metric."),defArg("掩码尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Size of gray value masks."),defArg("二维矩阵向导", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Approximation of the Homogeneous projective transformation matrix between the two images."),defArg("距公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Tolerance for the matching search window."),defArg("匹配阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for gray value matching."),defArg("估计方法", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix estimation algorithm."),defArg("距离阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for transformation consistency check."),defArg("随机数种子", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Seed for the random number generator."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Homogeneous projective transformation matrix."),defArg("点集1", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 1."),defArg("点集2", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Indices of matched input points in image 2.")};
defARGINFO __arg_read_component_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the component model.")};
defARGINFO __arg_read_deformable_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_read_descriptor_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_read_ncc_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_read_sample_identifier [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the sample identifier.")};
defARGINFO __arg_read_shape_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the model.")};
defARGINFO __arg_read_template [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "file name."),defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Template number.")};
defARGINFO __arg_read_training_components [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training result.")};
defARGINFO __arg_read_variation_model [] = {defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "ID of the variation model.")};
defARGINFO __arg_remove_sample_identifier_preparation_data [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the preparation object, of which samples should be removed."),defArg("对象样本索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the preparation sample that should be removed.")};
defARGINFO __arg_remove_sample_identifier_training_data [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the training object, from which samples should be removed."),defArg("对象样本索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the training sample that should be removed.")};
defARGINFO __arg_serialize_component_model [] = {defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_deformable_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a model to be saved."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_descriptor_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a model to be saved."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_ncc_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_sample_identifier [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_shape_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_template [] = {defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the template."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_training_components [] = {defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_serialize_variation_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model."),defArg("序列化项目句柄", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the serialized item.")};
defARGINFO __arg_set_deformable_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the origin of the deformable model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the origin of the deformable model.")};
defARGINFO __arg_set_deformable_model_param [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter values.")};
defARGINFO __arg_set_descriptor_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a descriptor model."),defArg("行", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation of origin in row direction."),defArg("列", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Translation of origin in column direction.")};
defARGINFO __arg_set_local_deformable_model_metric [] = {defArg("图像", dataTypeObj, 0, 0, "Input image used for the determination of the polarity."),defArg("向量场", dataTypeObj, 0, 0, "Vector field of the local deformation."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric.")};
defARGINFO __arg_set_ncc_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the origin of the NCC model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the origin of the NCC model.")};
defARGINFO __arg_set_ncc_model_param [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter values.")};
defARGINFO __arg_set_offset_template [] = {defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("灰度偏移", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Offset of gray values.")};
defARGINFO __arg_set_planar_calib_deformable_model_metric [] = {defArg("图像", dataTypeObj, 0, 0, "Input image used for the determination of the polarity."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("姿态", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Pose of the model in the image."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric.")};
defARGINFO __arg_set_planar_uncalib_deformable_model_metric [] = {defArg("图像", dataTypeObj, 0, 0, "Input image used for the determination of the polarity."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric.")};
defARGINFO __arg_set_reference_template [] = {defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Reference position of template (row)."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Reference position of template (column).")};
defARGINFO __arg_set_sample_identifier_object_info [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("对象索引", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Index of the object for which information is set."),defArg("信息名称", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Define, for which kind of object information is set."),defArg("信息值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Information about the object.")};
defARGINFO __arg_set_sample_identifier_param [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value.")};
defARGINFO __arg_set_shape_model_metric [] = {defArg("图像", dataTypeObj, 0, 0, "Input image used for the determination of the polarity."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("二维变换矩阵", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Transformation matrix."),defArg("度量", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Match metric.")};
defARGINFO __arg_set_shape_model_origin [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("行", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Row coordinate of the origin of the shape model."),defArg("列", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Column coordinate of the origin of the shape model.")};
defARGINFO __arg_set_shape_model_param [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("参数名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter names."),defArg("参数值", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Parameter values.")};
defARGINFO __arg_train_model_components [] = {defArg("模型的图像", dataTypeObj, 0, 0, "Input image from which the shape models of the initial components should be created."),defArg("初始组件", dataTypeObj, 0, 0, "Contour regions or enclosing regions of the initial components."),defArg("训练图像", dataTypeObj, 0, 0, "Training images that are used for training the model components."),defArg("模型组件", dataTypeObj, 0, AS_RECEIVE_VAR, "Contour regions of rigid model components."),defArg("低对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Lower hysteresis threshold for the contrast of the initial components in the image."),defArg("高对比度", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Upper hysteresis threshold for the contrast of the initial components in the image."),defArg("最小尺寸", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum size of connected contour regions."),defArg("最小得分", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Minimum score of the instances of the initial components to be found."),defArg("搜索行公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Search tolerance in row direction."),defArg("搜索列公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Search tolerance in column direction."),defArg("搜索角度公差", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Angle search tolerance."),defArg("重点训练", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Decision whether the training emphasis should lie on a fast computation or on a high robustness."),defArg("模糊标准", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Criterion for solving ambiguous matches of the initial components in the training images."),defArg("最大轮廓重叠", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Maximum contour overlap of the found initial components in a training image."),defArg("聚类阈值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Threshold for clustering the initial components."),defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_VAR|AS_DEFAULT_VALUE_IS_EMPTY, "Handle of the training result.")};
defARGINFO __arg_train_sample_identifier [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("参数名", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter name."),defArg("参数值", _SDT_ALL, 0, AS_DEFAULT_VALUE_IS_EMPTY|AS_RECEIVE_ALL_TYPE_DATA, "Parameter value.")};
defARGINFO __arg_train_variation_model [] = {defArg("图像", dataTypeObj, 0, 0, "Images of the object to be trained."),defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model.")};
defARGINFO __arg_write_component_model [] = {defArg("组件模型的ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the component model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_deformable_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a model to be saved."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The path and filename of the model to be saved.")};
defARGINFO __arg_write_descriptor_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of a model to be saved."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "The path and filename of the model to be saved.")};
defARGINFO __arg_write_ncc_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_sample_identifier [] = {defArg("样品标识", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the sample identifier."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_shape_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_template [] = {defArg("模板ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Template number."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "file name.")};
defARGINFO __arg_write_training_components [] = {defArg("组件训练ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "Handle of the training result."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};
defARGINFO __arg_write_variation_model [] = {defArg("模型ID", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "ID of the variation model."),defArg("文件名", _SDT_ALL, 0, AS_RECEIVE_ALL_TYPE_DATA, "File name.")};